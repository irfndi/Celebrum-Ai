<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","lib.rs"],"content":"use worker::*;\n\n// Module declarations\nmod services;\nmod types;\nmod utils;\n\nuse serde_json::json;\nuse services::exchange::{ExchangeInterface, ExchangeService};\nuse services::opportunity::{OpportunityService, OpportunityServiceConfig};\nuse services::positions::{CreatePositionData, PositionsService, UpdatePositionData};\nuse services::telegram::TelegramService;\nuse std::sync::Arc;\nuse types::{ExchangeIdEnum, StructuredTradingPair};\nuse utils::{ArbitrageError, ArbitrageResult};\nuse std::collections::HashMap;\nuse uuid::Uuid;\n\n#[event(fetch)]\npub async fn main(req: Request, env: Env, _ctx: Context) -\u003e Result\u003cResponse\u003e {\n    console_error_panic_hook::set_once();\n\n    let url = req.url()?;\n    let path = url.path();\n\n    match (req.method(), path) {\n        // Health check\n        (Method::Get, \"/health\") =\u003e {\n            Response::ok(\"ArbEdge Rust Worker is running!\")\n        }\n\n        // KV test endpoint\n        (Method::Get, \"/kv-test\") =\u003e {\n            let value = url.query().unwrap_or(\"default\");\n            let kv = env.kv(\"ArbEdgeKV\")?;\n            kv.put(\"test-key\", value)?.execute().await?;\n            let retrieved = kv.get(\"test-key\").text().await?;\n            Response::ok(retrieved.unwrap_or_default())\n        }\n\n        // Exchange API endpoints\n        (Method::Get, \"/exchange/markets\") =\u003e {\n            handle_get_markets(req, env).await\n        }\n\n        (Method::Get, \"/exchange/ticker\") =\u003e {\n            handle_get_ticker(req, env).await\n        }\n\n        (Method::Get, \"/exchange/funding\") =\u003e {\n            handle_funding_rate(req, env).await\n        }\n\n        // Opportunity finding endpoint\n        (Method::Post, \"/find-opportunities\") =\u003e {\n            handle_find_opportunities(req, env).await\n        }\n\n        // Telegram webhook endpoint\n        (Method::Post, \"/webhook\") =\u003e {\n            handle_telegram_webhook(req, env).await\n        }\n\n        // Position management endpoints\n        (Method::Post, \"/positions\") =\u003e {\n            handle_create_position(req, env).await\n        }\n\n        (Method::Get, \"/positions\") =\u003e {\n            handle_get_all_positions(req, env).await\n        }\n\n        (Method::Get, path) if path.starts_with(\"/positions/\") =\u003e {\n            let id = path.strip_prefix(\"/positions/\").unwrap();\n            // Validate UUID format\n            if Uuid::parse_str(id).is_err() {\n                return Response::error(\"Invalid position ID format. Must be a valid UUID.\", 400);\n            }\n            handle_get_position(req, env, id).await\n        }\n\n        (Method::Put, path) if path.starts_with(\"/positions/\") =\u003e {\n            let id = path.strip_prefix(\"/positions/\").unwrap();\n            // Validate UUID format\n            if Uuid::parse_str(id).is_err() {\n                return Response::error(\"Invalid position ID format. Must be a valid UUID.\", 400);\n            }\n            handle_update_position(req, env, id).await\n        }\n\n        (Method::Delete, path) if path.starts_with(\"/positions/\") =\u003e {\n            let id = path.strip_prefix(\"/positions/\").unwrap();\n            // Validate UUID format\n            if Uuid::parse_str(id).is_err() {\n                return Response::error(\"Invalid position ID format. Must be a valid UUID.\", 400);\n            }\n            handle_close_position(req, env, id).await\n        }\n\n        // Default response\n        _ =\u003e Response::ok(\"Hello, ArbEdge in Rust! Available endpoints: /health, /kv-test, /exchange/*, /find-opportunities, /webhook, /positions\"),\n    }\n}\n\n#[event(scheduled)]\npub async fn scheduled(event: ScheduledEvent, env: Env, _ctx: ScheduleContext) {\n    console_error_panic_hook::set_once();\n\n    match event.cron().as_str() {\n        // Monitor opportunities every minute\n        \"* * * * *\" =\u003e {\n            if let Err(e) = monitor_opportunities_scheduled(env).await {\n                console_log!(\"Error in scheduled opportunity monitoring: {}\", e);\n            }\n        }\n        _ =\u003e {\n            console_log!(\"Unknown scheduled event: {}\", event.cron());\n        }\n    }\n}\n\n// Helper functions to reduce code duplication\n\n/// Parse exchanges from environment string, returning error if less than two\nfn parse_exchanges_from_env(exchanges_str: \u0026str) -\u003e std::result::Result\u003cVec\u003cExchangeIdEnum\u003e, ArbitrageError\u003e {\n    let exchanges: Vec\u003cExchangeIdEnum\u003e = exchanges_str\n        .split(',')\n        .filter_map(|s| match s.trim() {\n            \"binance\" =\u003e Some(ExchangeIdEnum::Binance),\n            \"bybit\" =\u003e Some(ExchangeIdEnum::Bybit),\n            \"okx\" =\u003e Some(ExchangeIdEnum::OKX),\n            \"bitget\" =\u003e Some(ExchangeIdEnum::Bitget),\n            _ =\u003e None,\n        })\n        .collect();\n\n    if exchanges.len() \u003c 2 {\n        Err(ArbitrageError::config_error(\"At least two exchanges must be configured\"))\n    } else {\n        Ok(exchanges)\n    }\n}\n\n/// Create OpportunityService by reading environment variables and initializing services\nasync fn create_opportunity_service(custom_env: \u0026types::Env) -\u003e ArbitrageResult\u003cOpportunityService\u003e {\n    // Parse configuration from environment\n    let exchanges_str = custom_env.worker_env.var(\"EXCHANGES\")?.to_string();\n    let exchanges = parse_exchanges_from_env(\u0026exchanges_str)?;\n\n    let monitored_pairs_str = custom_env.worker_env.var(\"MONITORED_PAIRS_CONFIG\")?.to_string();\n    let monitored_pairs: Vec\u003cStructuredTradingPair\u003e =\n        serde_json::from_str(\u0026monitored_pairs_str).map_err(|e| {\n            ArbitrageError::parse_error(format!(\"Failed to parse monitored pairs: {}\", e))\n        })?;\n\n    let threshold: f64 = custom_env.worker_env\n        .var(\"ARBITRAGE_THRESHOLD\")\n        .map(|v| v.to_string())\n        .unwrap_or_else(|_| \"0.001\".to_string())\n        .parse()\n        .unwrap_or(0.001);\n\n    // Create services\n    let exchange_service = Arc::new(ExchangeService::new(custom_env)?);\n\n    let telegram_service = if let (Ok(bot_token), Ok(chat_id)) =\n        (custom_env.worker_env.var(\"TELEGRAM_BOT_TOKEN\"), custom_env.worker_env.var(\"TELEGRAM_CHAT_ID\"))\n    {\n        Some(Arc::new(TelegramService::new(\n            services::telegram::TelegramConfig {\n                bot_token: bot_token.to_string(),\n                chat_id: chat_id.to_string(),\n            },\n        )))\n    } else {\n        None\n    };\n\n    let opportunity_config = OpportunityServiceConfig {\n        exchanges,\n        monitored_pairs,\n        threshold,\n    };\n\n    Ok(OpportunityService::new(opportunity_config, exchange_service, telegram_service))\n}\n\n// Handler implementations\n\nasync fn handle_get_markets(req: Request, env: Env) -\u003e Result\u003cResponse\u003e {\n    let custom_env = types::Env::new(env);\n    let exchange_service = match ExchangeService::new(\u0026custom_env) {\n        Ok(service) =\u003e service,\n        Err(e) =\u003e return Response::error(format!(\"Failed to create exchange service: {}\", e), 500),\n    };\n\n    let url = req.url()?;\n    let exchange_id = url\n        .query_pairs()\n        .find(|(key, _)| key == \"exchange\")\n        .map(|(_, value)| value.to_string())\n        .unwrap_or_else(|| \"binance\".to_string());\n\n    match exchange_service.get_markets(\u0026exchange_id).await {\n        Ok(markets) =\u003e {\n            let market_count = markets.len();\n            let sample_markets: Vec\u003c_\u003e = markets.into_iter().take(5).collect();\n            let response = json!({\n                \"exchange\": exchange_id,\n                \"total_markets\": market_count,\n                \"sample_markets\": sample_markets\n            });\n            Response::from_json(\u0026response)\n        }\n        Err(e) =\u003e Response::error(format!(\"Failed to get markets: {}\", e), 500),\n    }\n}\n\nasync fn handle_get_ticker(req: Request, env: Env) -\u003e Result\u003cResponse\u003e {\n    let custom_env = types::Env::new(env);\n    let exchange_service = match ExchangeService::new(\u0026custom_env) {\n        Ok(service) =\u003e service,\n        Err(e) =\u003e return Response::error(format!(\"Failed to create exchange service: {}\", e), 500),\n    };\n\n    let url = req.url()?;\n    let query_pairs: std::collections::HashMap\u003cString, String\u003e = url\n        .query_pairs()\n        .map(|(k, v)| (k.to_string(), v.to_string()))\n        .collect();\n\n    let exchange_id = query_pairs\n        .get(\"exchange\")\n        .cloned()\n        .unwrap_or_else(|| \"binance\".to_string());\n    let symbol = query_pairs\n        .get(\"symbol\")\n        .cloned()\n        .unwrap_or_else(|| \"BTCUSDT\".to_string());\n\n    match exchange_service.get_ticker(\u0026exchange_id, \u0026symbol).await {\n        Ok(ticker) =\u003e Response::from_json(\u0026ticker),\n        Err(e) =\u003e Response::error(format!(\"Failed to get ticker: {}\", e), 500),\n    }\n}\n\nasync fn handle_funding_rate(req: Request, env: Env) -\u003e Result\u003cResponse\u003e {\n    let url = req.url()?;\n    let query_params: HashMap\u003cString, String\u003e = url.query_pairs().into_owned().collect();\n    \n    let exchange_id = query_params.get(\"exchange\").unwrap_or(\u0026\"binance\".to_string()).clone();\n    let symbol = query_params.get(\"symbol\").unwrap_or(\u0026\"BTCUSDT\".to_string()).clone();\n    \n    let custom_env = types::Env::new(env);\n    let exchange_service = match ExchangeService::new(\u0026custom_env) {\n        Ok(service) =\u003e service,\n        Err(e) =\u003e return Response::error(format!(\"Failed to create exchange service: {}\", e), 500),\n    };\n    \n    match exchange_service\n        .fetch_funding_rates(\u0026exchange_id, Some(\u0026symbol))\n        .await\n    {\n        Ok(rates) =\u003e Response::from_json(\u0026rates),\n        Err(e) =\u003e Response::error(format!(\"Failed to fetch funding rate: {}\", e), 500),\n    }\n}\n\nasync fn handle_find_opportunities(mut req: Request, env: Env) -\u003e Result\u003cResponse\u003e {\n    // Create custom env first \n    let custom_env = types::Env::new(env);\n    \n    // Parse request body for trading pairs (optional)\n    let request_data: serde_json::Value = match req.json().await {\n        Ok(data) =\u003e data,\n        Err(_) =\u003e {\n            // Default trading pairs if no body provided\n            json!({\n                \"trading_pairs\": [\"BTCUSDT\", \"ETHUSDT\", \"ADAUSDT\", \"DOTUSDT\", \"SOLUSDT\"],\n                \"min_threshold\": 0.01\n            })\n        }\n    };\n\n    let _trading_pairs: Vec\u003cString\u003e = request_data[\"trading_pairs\"]\n        .as_array()\n        .unwrap_or(\u0026vec![])\n        .iter()\n        .filter_map(|v| v.as_str().map(|s| s.to_string()))\n        .collect();\n\n    let _min_threshold = request_data[\"min_threshold\"]\n        .as_f64()\n        .unwrap_or(0.01);\n\n    // Create opportunity service using helper\n    let opportunity_service = match create_opportunity_service(\u0026custom_env).await {\n        Ok(service) =\u003e service,\n        Err(e) =\u003e return Response::error(format!(\"Failed to create opportunity service: {}\", e), 500),\n    };\n\n    // Find opportunities\n    match opportunity_service.monitor_opportunities().await {\n        Ok(opportunities) =\u003e {\n            // Process opportunities (send notifications)\n            if let Err(e) = opportunity_service\n                .process_opportunities(\u0026opportunities)\n                .await\n            {\n                console_log!(\"Failed to process opportunities: {}\", e);\n            }\n\n            let response = json!({\n                \"status\": \"success\",\n                \"opportunities_found\": opportunities.len(),\n                \"opportunities\": opportunities\n            });\n            Response::from_json(\u0026response)\n        }\n        Err(e) =\u003e Response::error(format!(\"Failed to find opportunities: {}\", e), 500),\n    }\n}\n\nasync fn handle_telegram_webhook(mut req: Request, env: Env) -\u003e Result\u003cResponse\u003e {\n    let update: serde_json::Value = req.json().await?;\n\n    let telegram_service = if let (Ok(bot_token), Ok(chat_id)) =\n        (env.var(\"TELEGRAM_BOT_TOKEN\"), env.var(\"TELEGRAM_CHAT_ID\"))\n    {\n        TelegramService::new(services::telegram::TelegramConfig {\n            bot_token: bot_token.to_string(),\n            chat_id: chat_id.to_string(),\n        })\n    } else {\n        return Response::error(\"Telegram configuration not found\", 500);\n    };\n\n    match telegram_service.handle_webhook(update).await {\n        Ok(Some(response_text)) =\u003e Response::ok(response_text),\n        Ok(None) =\u003e Response::ok(\"OK\"),\n        Err(e) =\u003e Response::error(format!(\"Webhook processing error: {}\", e), 500),\n    }\n}\n\nasync fn handle_create_position(mut req: Request, env: Env) -\u003e Result\u003cResponse\u003e {\n    let kv = env.kv(\"ArbEdgeKV\")?;\n    let positions_service = PositionsService::new(kv);\n\n    let position_data: CreatePositionData = req.json().await?;\n\n    match positions_service.create_position(position_data).await {\n        Ok(position) =\u003e Response::from_json(\u0026position),\n        Err(e) =\u003e Response::error(format!(\"Failed to create position: {}\", e), 500),\n    }\n}\n\nasync fn handle_get_all_positions(_req: Request, env: Env) -\u003e Result\u003cResponse\u003e {\n    let kv = env.kv(\"ArbEdgeKV\")?;\n    let positions_service = PositionsService::new(kv);\n\n    match positions_service.get_all_positions().await {\n        Ok(positions) =\u003e Response::from_json(\u0026positions),\n        Err(e) =\u003e Response::error(format!(\"Failed to get positions: {}\", e), 500),\n    }\n}\n\nasync fn handle_get_position(_req: Request, env: Env, id: \u0026str) -\u003e Result\u003cResponse\u003e {\n    let kv = env.kv(\"ArbEdgeKV\")?;\n    let positions_service = PositionsService::new(kv);\n\n    match positions_service.get_position(id).await {\n        Ok(Some(position)) =\u003e Response::from_json(\u0026position),\n        Ok(None) =\u003e Response::error(\"Position not found\", 404),\n        Err(e) =\u003e Response::error(format!(\"Failed to get position: {}\", e), 500),\n    }\n}\n\nasync fn handle_update_position(mut req: Request, env: Env, id: \u0026str) -\u003e Result\u003cResponse\u003e {\n    let kv = env.kv(\"ArbEdgeKV\")?;\n    let positions_service = PositionsService::new(kv);\n\n    let update_data: UpdatePositionData = req.json().await?;\n\n    match positions_service.update_position(id, update_data).await {\n        Ok(Some(position)) =\u003e Response::from_json(\u0026position),\n        Ok(None) =\u003e Response::error(\"Position not found\", 404),\n        Err(e) =\u003e Response::error(format!(\"Failed to update position: {}\", e), 500),\n    }\n}\n\nasync fn handle_close_position(_req: Request, env: Env, id: \u0026str) -\u003e Result\u003cResponse\u003e {\n    let kv = env.kv(\"ArbEdgeKV\")?;\n    let positions_service = PositionsService::new(kv);\n\n    match positions_service.close_position(id).await {\n        Ok(true) =\u003e Response::ok(\"Position closed\"),\n        Ok(false) =\u003e Response::error(\"Position not found\", 404),\n        Err(e) =\u003e Response::error(format!(\"Failed to close position: {}\", e), 500),\n    }\n}\n\nasync fn monitor_opportunities_scheduled(env: Env) -\u003e ArbitrageResult\u003c()\u003e {\n    let custom_env = types::Env::new(env);\n    \n    // Create opportunity service using helper\n    let opportunity_service = create_opportunity_service(\u0026custom_env).await?;\n\n    // Find and process opportunities\n    let opportunities = opportunity_service.monitor_opportunities().await?;\n\n    if !opportunities.is_empty() {\n        console_log!(\"Found {} opportunities\", opportunities.len());\n        opportunity_service\n            .process_opportunities(\u0026opportunities)\n            .await?;\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n    use types::ExchangeIdEnum;\n\n    // Tests for parse_exchanges_from_env function\n    #[test]\n    fn test_parse_exchanges_from_env_valid_input() {\n        let exchanges_str = \"binance,bybit,okx\";\n        let result = parse_exchanges_from_env(exchanges_str).unwrap();\n        \n        assert_eq!(result.len(), 3);\n        assert!(result.contains(\u0026ExchangeIdEnum::Binance));\n        assert!(result.contains(\u0026ExchangeIdEnum::Bybit));\n        assert!(result.contains(\u0026ExchangeIdEnum::OKX));\n    }\n\n    #[test]\n    fn test_parse_exchanges_from_env_with_whitespace() {\n        let exchanges_str = \" binance , bybit , okx \";\n        let result = parse_exchanges_from_env(exchanges_str).unwrap();\n        \n        assert_eq!(result.len(), 3);\n        assert!(result.contains(\u0026ExchangeIdEnum::Binance));\n        assert!(result.contains(\u0026ExchangeIdEnum::Bybit));\n        assert!(result.contains(\u0026ExchangeIdEnum::OKX));\n    }\n\n    #[test]\n    fn test_parse_exchanges_from_env_invalid_exchange() {\n        let exchanges_str = \"binance,invalid_exchange,okx\";\n        let result = parse_exchanges_from_env(exchanges_str).unwrap();\n        \n        // Should only contain valid exchanges\n        assert_eq!(result.len(), 2);\n        assert!(result.contains(\u0026ExchangeIdEnum::Binance));\n        assert!(result.contains(\u0026ExchangeIdEnum::OKX));\n    }\n\n    #[test]\n    fn test_parse_exchanges_from_env_insufficient_exchanges() {\n        let exchanges_str = \"binance\";\n        let result = parse_exchanges_from_env(exchanges_str);\n        \n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"At least two exchanges must be configured\"));\n    }\n\n    #[test]\n    fn test_parse_exchanges_from_env_empty_string() {\n        let exchanges_str = \"\";\n        let result = parse_exchanges_from_env(exchanges_str);\n        \n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_parse_exchanges_from_env_all_supported() {\n        let exchanges_str = \"binance,bybit,okx,bitget\";\n        let result = parse_exchanges_from_env(exchanges_str).unwrap();\n        \n        assert_eq!(result.len(), 4);\n        assert!(result.contains(\u0026ExchangeIdEnum::Binance));\n        assert!(result.contains(\u0026ExchangeIdEnum::Bybit));\n        assert!(result.contains(\u0026ExchangeIdEnum::OKX));\n        assert!(result.contains(\u0026ExchangeIdEnum::Bitget));\n    }\n\n    // Tests for route matching logic\n    mod route_tests {\n        use super::*;\n\n        #[test]\n        fn test_health_endpoint_routing() {\n            let method = Method::Get;\n            let path = \"/health\";\n            \n            match (method, path) {\n                (Method::Get, \"/health\") =\u003e {\n                    // This should match the health endpoint\n                    assert!(true, \"Health endpoint route should match\");\n                }\n                _ =\u003e panic!(\"Health endpoint route should match\"),\n            }\n        }\n\n        #[test]\n        fn test_kv_test_endpoint_routing() {\n            let method = Method::Get;\n            let path = \"/kv-test\";\n            \n            match (method, path) {\n                (Method::Get, \"/kv-test\") =\u003e {\n                    assert!(true, \"KV test endpoint route should match\");\n                }\n                _ =\u003e panic!(\"KV test endpoint route should match\"),\n            }\n        }\n\n        #[test]\n        fn test_exchange_endpoints_routing() {\n            let exchange_routes = vec![\n                (Method::Get, \"/exchange/markets\"),\n                (Method::Get, \"/exchange/ticker\"),\n                (Method::Get, \"/exchange/funding\"),\n            ];\n\n            for (method, path) in exchange_routes {\n                match (method, path) {\n                    (Method::Get, \"/exchange/markets\") |\n                    (Method::Get, \"/exchange/ticker\") |\n                    (Method::Get, \"/exchange/funding\") =\u003e {\n                        assert!(true, \"Exchange endpoint should match\");\n                    }\n                    _ =\u003e panic!(\"Exchange endpoint should match for {}\", path),\n                }\n            }\n        }\n\n        #[test]\n        fn test_opportunity_endpoint_routing() {\n            let method = Method::Post;\n            let path = \"/find-opportunities\";\n            \n            match (method, path) {\n                (Method::Post, \"/find-opportunities\") =\u003e {\n                    assert!(true, \"Find opportunities endpoint should match\");\n                }\n                _ =\u003e panic!(\"Find opportunities endpoint should match\"),\n            }\n        }\n\n        #[test]\n        fn test_telegram_webhook_routing() {\n            let method = Method::Post;\n            let path = \"/webhook\";\n            \n            match (method, path) {\n                (Method::Post, \"/webhook\") =\u003e {\n                    assert!(true, \"Telegram webhook endpoint should match\");\n                }\n                _ =\u003e panic!(\"Telegram webhook endpoint should match\"),\n            }\n        }\n\n        #[test]\n        fn test_positions_routing() {\n            let position_routes = vec![\n                (Method::Post, \"/positions\"),\n                (Method::Get, \"/positions\"),\n                (Method::Get, \"/positions/123e4567-e89b-12d3-a456-426614174000\"),\n                (Method::Put, \"/positions/123e4567-e89b-12d3-a456-426614174000\"),\n                (Method::Delete, \"/positions/123e4567-e89b-12d3-a456-426614174000\"),\n            ];\n\n            for (method, path) in position_routes {\n                match (\u0026method, path) {\n                    (Method::Post, \"/positions\") |\n                    (Method::Get, \"/positions\") =\u003e {\n                        assert!(true, \"Positions endpoint should match\");\n                    }\n                    (Method::Get, path) if path.starts_with(\"/positions/\") =\u003e {\n                        let id = path.strip_prefix(\"/positions/\").unwrap();\n                        if Uuid::parse_str(id).is_ok() {\n                            assert!(true, \"GET position by ID should match with valid UUID\");\n                        }\n                    }\n                    (Method::Put, path) if path.starts_with(\"/positions/\") =\u003e {\n                        let id = path.strip_prefix(\"/positions/\").unwrap();\n                        if Uuid::parse_str(id).is_ok() {\n                            assert!(true, \"PUT position by ID should match with valid UUID\");\n                        }\n                    }\n                    (Method::Delete, path) if path.starts_with(\"/positions/\") =\u003e {\n                        let id = path.strip_prefix(\"/positions/\").unwrap();\n                        if Uuid::parse_str(id).is_ok() {\n                            assert!(true, \"DELETE position by ID should match with valid UUID\");\n                        }\n                    }\n                    _ =\u003e {\n                        let method_str = format!(\"{:?}\", method);\n                        panic!(\"Position endpoint should match for {} {}\", method_str, path);\n                    }\n                }\n            }\n        }\n\n        #[test]\n        fn test_uuid_validation_in_position_routes() {\n            let valid_uuid = \"123e4567-e89b-12d3-a456-426614174000\";\n            let invalid_uuid = \"invalid-uuid-format\";\n\n            // Valid UUID should pass validation\n            assert!(Uuid::parse_str(valid_uuid).is_ok());\n\n            // Invalid UUID should fail validation\n            assert!(Uuid::parse_str(invalid_uuid).is_err());\n        }\n\n        #[test]\n        fn test_default_route_fallback() {\n            let unmatched_routes = vec![\n                (Method::Get, \"/unknown\"),\n                (Method::Post, \"/invalid\"),\n                (Method::Put, \"/nonexistent\"),\n            ];\n\n            for (method, path) in unmatched_routes {\n                match (method, path) {\n                    (Method::Get, \"/health\") |\n                    (Method::Get, \"/kv-test\") |\n                    (Method::Get, \"/exchange/markets\") |\n                    (Method::Get, \"/exchange/ticker\") |\n                    (Method::Get, \"/exchange/funding\") |\n                    (Method::Post, \"/find-opportunities\") |\n                    (Method::Post, \"/webhook\") |\n                    (Method::Post, \"/positions\") |\n                    (Method::Get, \"/positions\") =\u003e {\n                        panic!(\"Route should not match known endpoints\");\n                    }\n                    (Method::Get, path) if path.starts_with(\"/positions/\") =\u003e {\n                        panic!(\"Route should not match position endpoints\");\n                    }\n                    (Method::Put, path) if path.starts_with(\"/positions/\") =\u003e {\n                        panic!(\"Route should not match position endpoints\");\n                    }\n                    (Method::Delete, path) if path.starts_with(\"/positions/\") =\u003e {\n                        panic!(\"Route should not match position endpoints\");\n                    }\n                    _ =\u003e {\n                        assert!(true, \"Unknown routes should fall through to default\");\n                    }\n                }\n            }\n        }\n    }\n\n    // Tests for scheduled event handling\n    mod scheduled_tests {\n        #[test]\n        fn test_scheduled_cron_pattern_matching() {\n            let cron_patterns = vec![\n                \"* * * * *\",      // Every minute (should match)\n                \"0 * * * *\",      // Every hour (should not match)\n                \"0 0 * * *\",      // Every day (should not match)\n                \"invalid\",        // Invalid pattern (should not match)\n            ];\n\n            for cron in cron_patterns {\n                match cron {\n                    \"* * * * *\" =\u003e {\n                        assert!(true, \"Every minute cron should be recognized\");\n                    }\n                    _ =\u003e {\n                        assert!(true, \"Other cron patterns should not trigger opportunity monitoring\");\n                    }\n                }\n            }\n        }\n    }\n\n    // Tests for query parameter parsing\n    mod query_parsing_tests {\n        #[test]\n        fn test_exchange_query_parameter_parsing() {\n            // Test default exchange\n            let default_exchange = \"binance\".to_string();\n            assert_eq!(default_exchange, \"binance\");\n\n            // Test explicit exchange parameter\n            let exchange_param = \"bybit\";\n            assert_eq!(exchange_param, \"bybit\");\n        }\n\n        #[test]\n        fn test_symbol_query_parameter_parsing() {\n            // Test default symbol\n            let default_symbol = \"BTCUSDT\".to_string();\n            assert_eq!(default_symbol, \"BTCUSDT\");\n\n            // Test explicit symbol parameter\n            let symbol_param = \"ETHUSDT\";\n            assert_eq!(symbol_param, \"ETHUSDT\");\n        }\n\n        #[test]\n        fn test_query_pairs_collection() {\n            // Simulate query parameter collection\n            let query_params = vec![\n                (\"exchange\".to_string(), \"binance\".to_string()),\n                (\"symbol\".to_string(), \"BTCUSDT\".to_string()),\n                (\"limit\".to_string(), \"100\".to_string()),\n            ];\n\n            let query_map: std::collections::HashMap\u003cString, String\u003e = query_params.into_iter().collect();\n\n            assert_eq!(query_map.get(\"exchange\"), Some(\u0026\"binance\".to_string()));\n            assert_eq!(query_map.get(\"symbol\"), Some(\u0026\"BTCUSDT\".to_string()));\n            assert_eq!(query_map.get(\"limit\"), Some(\u0026\"100\".to_string()));\n        }\n    }\n\n    // Tests for JSON request/response handling\n    mod json_handling_tests {\n        use super::*;\n\n        #[test]\n        fn test_find_opportunities_request_parsing() {\n            // Test default request data when no body provided\n            let default_data = json!({\n                \"trading_pairs\": [\"BTCUSDT\", \"ETHUSDT\", \"ADAUSDT\", \"DOTUSDT\", \"SOLUSDT\"],\n                \"min_threshold\": 0.01\n            });\n\n            assert_eq!(default_data[\"trading_pairs\"].as_array().unwrap().len(), 5);\n            assert_eq!(default_data[\"min_threshold\"].as_f64().unwrap(), 0.01);\n        }\n\n        #[test]\n        fn test_trading_pairs_parsing() {\n            let request_data = json!({\n                \"trading_pairs\": [\"BTCUSDT\", \"ETHUSDT\", \"BNBUSDT\"],\n                \"min_threshold\": 0.02\n            });\n\n            let trading_pairs: Vec\u003cString\u003e = request_data[\"trading_pairs\"]\n                .as_array()\n                .unwrap_or(\u0026vec![])\n                .iter()\n                .filter_map(|v| v.as_str().map(|s| s.to_string()))\n                .collect();\n\n            assert_eq!(trading_pairs.len(), 3);\n            assert!(trading_pairs.contains(\u0026\"BTCUSDT\".to_string()));\n            assert!(trading_pairs.contains(\u0026\"ETHUSDT\".to_string()));\n            assert!(trading_pairs.contains(\u0026\"BNBUSDT\".to_string()));\n        }\n\n        #[test]\n        fn test_min_threshold_parsing() {\n            let request_data = json!({\n                \"trading_pairs\": [\"BTCUSDT\"],\n                \"min_threshold\": 0.05\n            });\n\n            let min_threshold = request_data[\"min_threshold\"]\n                .as_f64()\n                .unwrap_or(0.01);\n\n            assert_eq!(min_threshold, 0.05);\n        }\n\n        #[test]\n        fn test_response_format() {\n            // Test opportunities response format\n            let opportunities_response = json!({\n                \"status\": \"success\",\n                \"opportunities_found\": 2,\n                \"opportunities\": [\n                    {\n                        \"trading_pair\": \"BTCUSDT\",\n                        \"exchange_a\": \"binance\",\n                        \"exchange_b\": \"bybit\",\n                        \"funding_rate_diff\": 0.02\n                    }\n                ]\n            });\n\n            assert_eq!(opportunities_response[\"status\"], \"success\");\n            assert_eq!(opportunities_response[\"opportunities_found\"], 2);\n            assert!(opportunities_response[\"opportunities\"].is_array());\n        }\n\n        #[test]\n        fn test_error_response_format() {\n            let error_message = \"Failed to create exchange service\";\n            let error_response = format!(\"Failed to create exchange service: {}\", error_message);\n            \n            assert!(error_response.contains(\"Failed to create exchange service\"));\n        }\n    }\n\n    // Tests for environment variable handling\n    mod env_tests {\n        #[test]\n        fn test_telegram_config_validation() {\n            // Test when both bot token and chat ID are available\n            let bot_token = \"123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11\";\n            let chat_id = \"-123456789\";\n\n            assert!(!bot_token.is_empty());\n            assert!(!chat_id.is_empty());\n            assert!(bot_token.contains(\":\"));\n            assert!(chat_id.starts_with(\"-\") || chat_id.parse::\u003ci64\u003e().is_ok());\n        }\n\n        #[test]\n        fn test_arbitrage_threshold_parsing() {\n            // Test default threshold\n            let default_threshold = \"0.001\".parse::\u003cf64\u003e().unwrap();\n            assert_eq!(default_threshold, 0.001);\n\n            // Test custom threshold\n            let custom_threshold = \"0.005\".parse::\u003cf64\u003e().unwrap();\n            assert_eq!(custom_threshold, 0.005);\n\n            // Test invalid threshold fallback\n            let invalid_threshold = \"invalid\".parse::\u003cf64\u003e().unwrap_or(0.001);\n            assert_eq!(invalid_threshold, 0.001);\n        }\n\n        #[test]\n        fn test_monitored_pairs_config_parsing() {\n            let pairs_config = r#\"[\n                {\"base\": \"BTC\", \"quote\": \"USDT\", \"type\": \"spot\"},\n                {\"base\": \"ETH\", \"quote\": \"USDT\", \"type\": \"spot\"}\n            ]\"#;\n\n            let parsed: std::result::Result\u003cserde_json::Value, serde_json::Error\u003e = serde_json::from_str(pairs_config);\n            assert!(parsed.is_ok());\n\n            let pairs = parsed.unwrap();\n            assert!(pairs.is_array());\n            assert_eq!(pairs.as_array().unwrap().len(), 2);\n        }\n    }\n\n    // Tests for utility functions used in handlers\n    mod handler_utilities_tests {\n        use super::*;\n\n        #[test]\n        fn test_url_path_extraction() {\n            let path = \"/positions/123e4567-e89b-12d3-a456-426614174000\";\n            let id = path.strip_prefix(\"/positions/\").unwrap();\n            \n            assert_eq!(id, \"123e4567-e89b-12d3-a456-426614174000\");\n            assert!(Uuid::parse_str(id).is_ok());\n        }\n\n        #[test]\n        fn test_invalid_uuid_handling() {\n            let invalid_ids = vec![\n                \"invalid-uuid\",\n                \"123\",\n                \"\",\n                \"not-a-uuid-at-all\",\n                \"123e4567-e89b-12d3-a456\", // Too short\n            ];\n\n            for invalid_id in invalid_ids {\n                assert!(Uuid::parse_str(invalid_id).is_err());\n            }\n        }\n\n        #[test]\n        fn test_valid_uuid_formats() {\n            let valid_ids = vec![\n                \"123e4567-e89b-12d3-a456-426614174000\",\n                \"550e8400-e29b-41d4-a716-446655440000\",\n                \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\",\n            ];\n\n            for valid_id in valid_ids {\n                assert!(Uuid::parse_str(valid_id).is_ok());\n            }\n        }\n\n        #[test]\n        fn test_content_type_handling() {\n            // Test that we expect JSON content type for POST/PUT requests\n            let content_type = \"application/json\";\n            assert_eq!(content_type, \"application/json\");\n        }\n\n        #[test]\n        fn test_http_status_codes() {\n            // Test common status codes used in handlers\n            let success_code = 200;\n            let bad_request_code = 400;\n            let not_found_code = 404;\n            let server_error_code = 500;\n\n            assert_eq!(success_code, 200);\n            assert_eq!(bad_request_code, 400);\n            assert_eq!(not_found_code, 404);\n            assert_eq!(server_error_code, 500);\n        }\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":6}},{"line":126,"address":[],"length":0,"stats":{"Line":6}},{"line":128,"address":[],"length":0,"stats":{"Line":21}},{"line":129,"address":[],"length":0,"stats":{"Line":20}},{"line":130,"address":[],"length":0,"stats":{"Line":13}},{"line":131,"address":[],"length":0,"stats":{"Line":11}},{"line":132,"address":[],"length":0,"stats":{"Line":4}},{"line":133,"address":[],"length":0,"stats":{"Line":2}},{"line":137,"address":[],"length":0,"stats":{"Line":6}},{"line":138,"address":[],"length":0,"stats":{"Line":2}},{"line":140,"address":[],"length":0,"stats":{"Line":4}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}}],"covered":11,"coverable":213},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","services","ai_integration.rs"],"content":"use crate::types::{UserProfile, UserApiKey, ApiKeyProvider};\nuse crate::utils::{ArbitrageError, ArbitrageResult};\nuse reqwest::Client;\nuse serde::{Deserialize, Serialize};\nuse serde_json::{json, Value};\nuse std::collections::HashMap;\nuse worker::console_log;\nuse worker::kv::KvStore;\nuse uuid;\n\n/// Configuration for AI integration service\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AiIntegrationConfig {\n    pub enabled: bool,\n    pub default_timeout_seconds: u64,\n    pub max_retries: u32,\n    pub supported_providers: Vec\u003cApiKeyProvider\u003e,\n    pub max_ai_keys_per_user: u32,\n}\n\nimpl Default for AiIntegrationConfig {\n    fn default() -\u003e Self {\n        Self {\n            enabled: true,\n            default_timeout_seconds: 30,\n            max_retries: 3,\n            max_ai_keys_per_user: 10,\n            supported_providers: vec![\n                ApiKeyProvider::OpenAI,\n                ApiKeyProvider::Anthropic,\n                ApiKeyProvider::Custom,\n            ],\n        }\n    }\n}\n\n/// AI provider interface for different AI services\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum AiProvider {\n    OpenAI {\n        api_key: String,\n        base_url: Option\u003cString\u003e,\n        model: Option\u003cString\u003e,\n    },\n    Anthropic {\n        api_key: String,\n        base_url: Option\u003cString\u003e,\n        model: Option\u003cString\u003e,\n    },\n    Custom {\n        api_key: String,\n        base_url: String,\n        headers: HashMap\u003cString, String\u003e,\n        model: Option\u003cString\u003e,\n    },\n}\n\n/// Request structure for AI analysis\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AiAnalysisRequest {\n    pub prompt: String,\n    pub market_data: Value,\n    pub user_context: Option\u003cValue\u003e,\n    pub max_tokens: Option\u003cu32\u003e,\n    pub temperature: Option\u003cf32\u003e,\n}\n\n/// Response structure from AI analysis\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AiAnalysisResponse {\n    pub analysis: String,\n    pub confidence: Option\u003cf32\u003e,\n    pub recommendations: Vec\u003cString\u003e,\n    pub metadata: HashMap\u003cString, Value\u003e,\n}\n\n/// AI Integration Service for managing user AI configurations\npub struct AiIntegrationService {\n    config: AiIntegrationConfig,\n    http_client: Client,\n    kv_store: KvStore,\n    encryption_key: String,\n}\n\nimpl AiIntegrationService {\n    /// Create new AI integration service\n    pub fn new(config: AiIntegrationConfig, kv_store: KvStore, encryption_key: String) -\u003e Self {\n        Self {\n            config,\n            http_client: Client::new(),\n            kv_store,\n            encryption_key,\n        }\n    }\n\n    /// Store AI credentials for a user\n    pub async fn store_ai_credentials(\n        \u0026self,\n        user_id: \u0026str,\n        provider: ApiKeyProvider,\n        api_key: \u0026str,\n        metadata: Option\u003cValue\u003e,\n    ) -\u003e ArbitrageResult\u003cString\u003e {\n        // Check if user has reached the maximum number of AI keys\n        let existing_keys = self.get_user_ai_keys(user_id).await?;\n        let ai_key_count = existing_keys.iter().filter(|key| key.is_ai_key()).count();\n        \n        if ai_key_count \u003e= self.config.max_ai_keys_per_user as usize {\n            return Err(ArbitrageError::validation_error(\n                \u0026format!(\"Maximum AI keys limit ({}) reached\", self.config.max_ai_keys_per_user)\n            ));\n        }\n\n        // Validate provider is supported\n        if !self.is_provider_supported(\u0026provider) {\n            return Err(ArbitrageError::validation_error(\"AI provider not supported\"));\n        }\n\n        // Encrypt the API key\n        let encrypted_key = self.encrypt_string(api_key)?;\n\n        // Create the UserApiKey\n        let api_key_id = uuid::Uuid::new_v4().to_string();\n        let user_api_key = UserApiKey::new_ai_key(\n            user_id.to_string(),\n            provider,\n            encrypted_key,\n            metadata.unwrap_or(json!({})),\n        );\n\n        // Store the key\n        let key = format!(\"ai_key:{}:{}\", user_id, api_key_id);\n        let serialized = serde_json::to_string(\u0026user_api_key)\n            .map_err(|e| ArbitrageError::parse_error(format!(\"Failed to serialize AI key: {}\", e)))?;\n        \n        self.kv_store.put(\u0026key, \u0026serialized)\n            .map_err(|e| ArbitrageError::storage_error(format!(\"Failed to prepare AI key storage: {}\", e)))?\n            .execute()\n            .await\n            .map_err(|e| ArbitrageError::storage_error(format!(\"Failed to store AI key: {}\", e)))?;\n\n        // Update user's AI key index\n        self.update_user_ai_key_index(user_id, \u0026api_key_id, true).await?;\n\n        Ok(api_key_id)\n    }\n\n    /// Remove AI credentials for a user\n    pub async fn remove_ai_credentials(\n        \u0026self,\n        user_id: \u0026str,\n        api_key_id: \u0026str,\n    ) -\u003e ArbitrageResult\u003cbool\u003e {\n        // Remove from storage\n        let key = format!(\"ai_key:{}:{}\", user_id, api_key_id);\n        self.kv_store.delete(\u0026key)\n            .await\n            .map_err(|e| ArbitrageError::storage_error(format!(\"Failed to delete AI key: {}\", e)))?;\n\n        // Update user's AI key index\n        self.update_user_ai_key_index(user_id, api_key_id, false).await?;\n\n        Ok(true)\n    }\n\n    /// Get all AI credentials for a user\n    pub async fn get_user_ai_keys(\u0026self, user_id: \u0026str) -\u003e ArbitrageResult\u003cVec\u003cUserApiKey\u003e\u003e {\n        let index_key = format!(\"ai_key_index:{}\", user_id);\n        let index_data = self.kv_store.get(\u0026index_key)\n            .text()\n            .await\n            .map_err(|e| ArbitrageError::storage_error(format!(\"Failed to get AI key index: {}\", e)))?;\n\n        let key_ids: Vec\u003cString\u003e = if let Some(data) = index_data {\n            serde_json::from_str(\u0026data)\n                .unwrap_or_default()\n        } else {\n            Vec::new()\n        };\n\n        let mut ai_keys = Vec::new();\n        for key_id in key_ids {\n            let key = format!(\"ai_key:{}:{}\", user_id, key_id);\n            if let Ok(Some(data)) = self.kv_store.get(\u0026key).text().await {\n                if let Ok(api_key) = serde_json::from_str::\u003cUserApiKey\u003e(\u0026data) {\n                    ai_keys.push(api_key);\n                }\n            }\n        }\n\n        Ok(ai_keys)\n    }\n\n    /// Validate and test AI credentials\n    pub async fn validate_and_test_credentials(\n        \u0026self,\n        user_id: \u0026str,\n        api_key_id: \u0026str,\n    ) -\u003e ArbitrageResult\u003cbool\u003e {\n        // Get the AI key\n        let ai_keys = self.get_user_ai_keys(user_id).await?;\n        let ai_key = ai_keys.iter()\n            .find(|key| key.id == api_key_id)\n            .ok_or_else(|| ArbitrageError::not_found(\"AI key not found\"))?;\n\n        // Decrypt the key and create provider\n        let decrypted_key = self.decrypt_string(\u0026ai_key.encrypted_key)?;\n        let provider = self.create_ai_provider_from_key(ai_key, \u0026decrypted_key)?;\n\n        // Test connectivity\n        match self.test_ai_connectivity(\u0026provider).await {\n            Ok(_) =\u003e {\n                // Update last_used timestamp\n                self.update_ai_key_last_used(user_id, api_key_id).await?;\n                Ok(true)\n            }\n            Err(e) =\u003e {\n                // Return validation error with details\n                Err(ArbitrageError::validation_error(\u0026format!(\"AI credentials validation failed: {}\", e)))\n            }\n        }\n    }\n\n    /// Get AI provider instance for user\n    pub async fn get_user_ai_provider(\n        \u0026self,\n        user_id: \u0026str,\n        provider_type: \u0026ApiKeyProvider,\n    ) -\u003e ArbitrageResult\u003cAiProvider\u003e {\n        let ai_keys = self.get_user_ai_keys(user_id).await?;\n        let ai_key = ai_keys.iter()\n            .find(|key| key.provider == *provider_type \u0026\u0026 key.is_active)\n            .ok_or_else(|| ArbitrageError::not_found(\"Active AI key not found for provider\"))?;\n\n        let decrypted_key = self.decrypt_string(\u0026ai_key.encrypted_key)?;\n        self.create_ai_provider_from_key(ai_key, \u0026decrypted_key)\n    }\n\n    /// Validate AI provider credentials\n    pub async fn validate_ai_credentials(\u0026self, provider: \u0026AiProvider) -\u003e ArbitrageResult\u003cbool\u003e {\n        match provider {\n            AiProvider::OpenAI { api_key, base_url, .. } =\u003e {\n                self.validate_openai_credentials(api_key, base_url.as_deref()).await\n            }\n            AiProvider::Anthropic { api_key, base_url, .. } =\u003e {\n                self.validate_anthropic_credentials(api_key, base_url.as_deref()).await\n            }\n            AiProvider::Custom { api_key, base_url, headers, .. } =\u003e {\n                self.validate_custom_credentials(api_key, base_url, headers).await\n            }\n        }\n    }\n\n    /// Test connectivity to AI provider\n    pub async fn test_ai_connectivity(\u0026self, provider: \u0026AiProvider) -\u003e ArbitrageResult\u003cString\u003e {\n        let test_request = AiAnalysisRequest {\n            prompt: \"Test connectivity. Please respond with 'OK' if you receive this message.\".to_string(),\n            market_data: json!({}),\n            user_context: None,\n            max_tokens: Some(10),\n            temperature: Some(0.1),\n        };\n\n        let response = self.call_ai_provider(provider, \u0026test_request).await?;\n        Ok(response.analysis)\n    }\n\n    /// Call AI provider with analysis request\n    pub async fn call_ai_provider(\n        \u0026self,\n        provider: \u0026AiProvider,\n        request: \u0026AiAnalysisRequest,\n    ) -\u003e ArbitrageResult\u003cAiAnalysisResponse\u003e {\n        if !self.config.enabled {\n            return Err(ArbitrageError::config_error(\"AI integration is disabled\"));\n        }\n\n        match provider {\n            AiProvider::OpenAI { api_key, base_url, model } =\u003e {\n                self.call_openai(api_key, base_url.as_deref(), model.as_deref(), request).await\n            }\n            AiProvider::Anthropic { api_key, base_url, model } =\u003e {\n                self.call_anthropic(api_key, base_url.as_deref(), model.as_deref(), request).await\n            }\n            AiProvider::Custom { api_key, base_url, headers, model } =\u003e {\n                self.call_custom_provider(api_key, base_url, headers, model.as_deref(), request).await\n            }\n        }\n    }\n\n    /// Create AI provider from user API key\n    pub fn create_ai_provider(\u0026self, api_key: \u0026UserApiKey) -\u003e ArbitrageResult\u003cAiProvider\u003e {\n        match api_key.provider {\n            ApiKeyProvider::OpenAI =\u003e Ok(AiProvider::OpenAI {\n                api_key: api_key.encrypted_key.clone(),\n                base_url: api_key.metadata.get(\"base_url\").and_then(|v| v.as_str()).map(String::from),\n                model: api_key.metadata.get(\"model\").and_then(|v| v.as_str()).map(String::from),\n            }),\n            ApiKeyProvider::Anthropic =\u003e Ok(AiProvider::Anthropic {\n                api_key: api_key.encrypted_key.clone(),\n                base_url: api_key.metadata.get(\"base_url\").and_then(|v| v.as_str()).map(String::from),\n                model: api_key.metadata.get(\"model\").and_then(|v| v.as_str()).map(String::from),\n            }),\n            ApiKeyProvider::Custom =\u003e {\n                let base_url = api_key.metadata.get(\"base_url\")\n                    .and_then(|v| v.as_str())\n                    .ok_or_else(|| ArbitrageError::validation_error(\"Custom provider requires base_url\"))?;\n                \n                let headers = api_key.metadata.get(\"headers\")\n                    .and_then(|v| v.as_object())\n                    .map(|obj| {\n                        obj.iter()\n                            .filter_map(|(k, v)| v.as_str().map(|s| (k.clone(), s.to_string())))\n                            .collect()\n                    })\n                    .unwrap_or_default();\n\n                Ok(AiProvider::Custom {\n                    api_key: api_key.encrypted_key.clone(),\n                    base_url: base_url.to_string(),\n                    headers,\n                    model: api_key.metadata.get(\"model\").and_then(|v| v.as_str()).map(String::from),\n                })\n            }\n            ApiKeyProvider::Exchange(_) =\u003e {\n                Err(ArbitrageError::validation_error(\"Cannot create AI provider from exchange API key\"))\n            }\n        }\n    }\n\n    /// Get supported AI providers\n    pub fn get_supported_providers(\u0026self) -\u003e \u0026[ApiKeyProvider] {\n        \u0026self.config.supported_providers\n    }\n\n    /// Check if provider is supported\n    pub fn is_provider_supported(\u0026self, provider: \u0026ApiKeyProvider) -\u003e bool {\n        self.config.supported_providers.contains(provider)\n    }\n\n    // Private methods for specific AI providers\n\n    async fn validate_openai_credentials(\u0026self, api_key: \u0026str, base_url: Option\u003c\u0026str\u003e) -\u003e ArbitrageResult\u003cbool\u003e {\n        let url = format!(\"{}/v1/models\", base_url.unwrap_or(\"https://api.openai.com\"));\n        \n        let response = self.http_client\n            .get(\u0026url)\n            .header(\"Authorization\", format!(\"Bearer {}\", api_key))\n            .timeout(std::time::Duration::from_secs(self.config.default_timeout_seconds))\n            .send()\n            .await\n            .map_err(|e| ArbitrageError::network_error(\u0026format!(\"OpenAI validation failed: {}\", e)))?;\n\n        Ok(response.status().is_success())\n    }\n\n    async fn validate_anthropic_credentials(\u0026self, api_key: \u0026str, base_url: Option\u003c\u0026str\u003e) -\u003e ArbitrageResult\u003cbool\u003e {\n        let url = format!(\"{}/v1/messages\", base_url.unwrap_or(\"https://api.anthropic.com\"));\n        \n        // Send a minimal test request\n        let test_payload = json!({\n            \"model\": \"claude-3-haiku-20240307\",\n            \"max_tokens\": 1,\n            \"messages\": [{\"role\": \"user\", \"content\": \"test\"}]\n        });\n\n        let response = self.http_client\n            .post(\u0026url)\n            .header(\"x-api-key\", api_key)\n            .header(\"anthropic-version\", \"2023-06-01\")\n            .header(\"content-type\", \"application/json\")\n            .json(\u0026test_payload)\n            .timeout(std::time::Duration::from_secs(self.config.default_timeout_seconds))\n            .send()\n            .await\n            .map_err(|e| ArbitrageError::network_error(\u0026format!(\"Anthropic validation failed: {}\", e)))?;\n\n        // Accept both success and rate limit as valid (credentials are correct)\n        Ok(response.status().is_success() || response.status() == 429)\n    }\n\n    async fn validate_custom_credentials(\n        \u0026self,\n        api_key: \u0026str,\n        base_url: \u0026str,\n        headers: \u0026HashMap\u003cString, String\u003e,\n    ) -\u003e ArbitrageResult\u003cbool\u003e {\n        let mut request = self.http_client\n            .get(base_url)\n            .header(\"Authorization\", format!(\"Bearer {}\", api_key))\n            .timeout(std::time::Duration::from_secs(self.config.default_timeout_seconds));\n\n        for (key, value) in headers {\n            request = request.header(key, value);\n        }\n\n        let response = request\n            .send()\n            .await\n            .map_err(|e| ArbitrageError::network_error(\u0026format!(\"Custom provider validation failed: {}\", e)))?;\n\n        Ok(response.status().is_success())\n    }\n\n    async fn call_openai(\n        \u0026self,\n        api_key: \u0026str,\n        base_url: Option\u003c\u0026str\u003e,\n        model: Option\u003c\u0026str\u003e,\n        request: \u0026AiAnalysisRequest,\n    ) -\u003e ArbitrageResult\u003cAiAnalysisResponse\u003e {\n        let url = format!(\"{}/v1/chat/completions\", base_url.unwrap_or(\"https://api.openai.com\"));\n        let model_name = model.unwrap_or(\"gpt-3.5-turbo\");\n\n        let payload = json!({\n            \"model\": model_name,\n            \"messages\": [\n                {\n                    \"role\": \"system\",\n                    \"content\": \"You are an expert cryptocurrency trading analyst. Analyze the provided market data and provide insights for arbitrage opportunities.\"\n                },\n                {\n                    \"role\": \"user\",\n                    \"content\": format!(\"Prompt: {}\\nMarket Data: {}\", request.prompt, request.market_data)\n                }\n            ],\n            \"max_tokens\": request.max_tokens.unwrap_or(500),\n            \"temperature\": request.temperature.unwrap_or(0.7)\n        });\n\n        let response = self.http_client\n            .post(\u0026url)\n            .header(\"Authorization\", format!(\"Bearer {}\", api_key))\n            .header(\"Content-Type\", \"application/json\")\n            .json(\u0026payload)\n            .timeout(std::time::Duration::from_secs(self.config.default_timeout_seconds))\n            .send()\n            .await\n            .map_err(|e| ArbitrageError::network_error(\u0026format!(\"OpenAI API call failed: {}\", e)))?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_else(|_| \"Unknown error\".to_string());\n            return Err(ArbitrageError::api_error(\u0026format!(\"OpenAI API error: {}\", error_text)));\n        }\n\n        let response_data: Value = response.json().await\n            .map_err(|e| ArbitrageError::parse_error(\u0026format!(\"Failed to parse OpenAI response: {}\", e)))?;\n\n        let analysis = response_data[\"choices\"][0][\"message\"][\"content\"]\n            .as_str()\n            .unwrap_or(\"No response\")\n            .to_string();\n\n        Ok(AiAnalysisResponse {\n            analysis,\n            confidence: None,\n            recommendations: vec![],\n            metadata: HashMap::new(),\n        })\n    }\n\n    async fn call_anthropic(\n        \u0026self,\n        api_key: \u0026str,\n        base_url: Option\u003c\u0026str\u003e,\n        model: Option\u003c\u0026str\u003e,\n        request: \u0026AiAnalysisRequest,\n    ) -\u003e ArbitrageResult\u003cAiAnalysisResponse\u003e {\n        let url = format!(\"{}/v1/messages\", base_url.unwrap_or(\"https://api.anthropic.com\"));\n        let model_name = model.unwrap_or(\"claude-3-haiku-20240307\");\n\n        let payload = json!({\n            \"model\": model_name,\n            \"max_tokens\": request.max_tokens.unwrap_or(500),\n            \"messages\": [\n                {\n                    \"role\": \"user\",\n                    \"content\": format!(\"As a cryptocurrency trading analyst, analyze this market data for arbitrage opportunities:\\n\\nPrompt: {}\\nMarket Data: {}\", request.prompt, request.market_data)\n                }\n            ]\n        });\n\n        let response = self.http_client\n            .post(\u0026url)\n            .header(\"x-api-key\", api_key)\n            .header(\"anthropic-version\", \"2023-06-01\")\n            .header(\"content-type\", \"application/json\")\n            .json(\u0026payload)\n            .timeout(std::time::Duration::from_secs(self.config.default_timeout_seconds))\n            .send()\n            .await\n            .map_err(|e| ArbitrageError::network_error(\u0026format!(\"Anthropic API call failed: {}\", e)))?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_else(|_| \"Unknown error\".to_string());\n            return Err(ArbitrageError::api_error(\u0026format!(\"Anthropic API error: {}\", error_text)));\n        }\n\n        let response_data: Value = response.json().await\n            .map_err(|e| ArbitrageError::parse_error(\u0026format!(\"Failed to parse Anthropic response: {}\", e)))?;\n\n        let analysis = response_data[\"content\"][0][\"text\"]\n            .as_str()\n            .unwrap_or(\"No response\")\n            .to_string();\n\n        Ok(AiAnalysisResponse {\n            analysis,\n            confidence: None,\n            recommendations: vec![],\n            metadata: HashMap::new(),\n        })\n    }\n\n    async fn call_custom_provider(\n        \u0026self,\n        api_key: \u0026str,\n        base_url: \u0026str,\n        headers: \u0026HashMap\u003cString, String\u003e,\n        model: Option\u003c\u0026str\u003e,\n        request: \u0026AiAnalysisRequest,\n    ) -\u003e ArbitrageResult\u003cAiAnalysisResponse\u003e {\n        let payload = json!({\n            \"prompt\": request.prompt,\n            \"market_data\": request.market_data,\n            \"max_tokens\": request.max_tokens.unwrap_or(500),\n            \"temperature\": request.temperature.unwrap_or(0.7),\n            \"model\": model\n        });\n\n        let mut http_request = self.http_client\n            .post(base_url)\n            .header(\"Authorization\", format!(\"Bearer {}\", api_key))\n            .header(\"Content-Type\", \"application/json\")\n            .json(\u0026payload)\n            .timeout(std::time::Duration::from_secs(self.config.default_timeout_seconds));\n\n        for (key, value) in headers {\n            http_request = http_request.header(key, value);\n        }\n\n        let response = http_request\n            .send()\n            .await\n            .map_err(|e| ArbitrageError::network_error(\u0026format!(\"Custom provider API call failed: {}\", e)))?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_else(|_| \"Unknown error\".to_string());\n            return Err(ArbitrageError::api_error(\u0026format!(\"Custom provider API error: {}\", error_text)));\n        }\n\n        let response_data: Value = response.json().await\n            .map_err(|e| ArbitrageError::parse_error(\u0026format!(\"Failed to parse custom provider response: {}\", e)))?;\n\n        // Try to extract analysis from common response formats\n        let analysis = response_data[\"response\"]\n            .as_str()\n            .or_else(|| response_data[\"text\"].as_str())\n            .or_else(|| response_data[\"analysis\"].as_str())\n            .or_else(|| response_data[\"content\"].as_str())\n            .unwrap_or(\"No response\")\n            .to_string();\n\n        Ok(AiAnalysisResponse {\n            analysis,\n            confidence: response_data[\"confidence\"].as_f64().map(|v| v as f32),\n            recommendations: response_data[\"recommendations\"]\n                .as_array()\n                .map(|arr| {\n                    arr.iter()\n                        .filter_map(|v| v.as_str().map(String::from))\n                        .collect()\n                })\n                .unwrap_or_default(),\n            metadata: HashMap::new(),\n        })\n    }\n\n    // Helper methods\n\n    async fn update_user_ai_key_index(\n        \u0026self,\n        user_id: \u0026str,\n        api_key_id: \u0026str,\n        add: bool,\n    ) -\u003e ArbitrageResult\u003c()\u003e {\n        let index_key = format!(\"ai_key_index:{}\", user_id);\n        let index_data = self.kv_store.get(\u0026index_key)\n            .text()\n            .await\n            .map_err(|e| ArbitrageError::storage_error(format!(\"Failed to get AI key index: {}\", e)))?;\n\n        let mut key_ids: Vec\u003cString\u003e = if let Some(data) = index_data {\n            serde_json::from_str(\u0026data)\n                .unwrap_or_default()\n        } else {\n            Vec::new()\n        };\n\n        if add {\n            if !key_ids.contains(\u0026api_key_id.to_string()) {\n                key_ids.push(api_key_id.to_string());\n            }\n        } else {\n            key_ids.retain(|id| id != api_key_id);\n        }\n\n        let serialized = serde_json::to_string(\u0026key_ids)\n            .map_err(|e| ArbitrageError::parse_error(format!(\"Failed to serialize key index: {}\", e)))?;\n\n        self.kv_store.put(\u0026index_key, \u0026serialized)\n            .map_err(|e| ArbitrageError::storage_error(format!(\"Failed to prepare AI key index storage: {}\", e)))?\n            .execute()\n            .await\n            .map_err(|e| ArbitrageError::storage_error(format!(\"Failed to update AI key index: {}\", e)))?;\n\n        Ok(())\n    }\n\n    async fn update_ai_key_last_used(\n        \u0026self,\n        user_id: \u0026str,\n        api_key_id: \u0026str,\n    ) -\u003e ArbitrageResult\u003c()\u003e {\n        let key = format!(\"ai_key:{}:{}\", user_id, api_key_id);\n        if let Ok(Some(data)) = self.kv_store.get(\u0026key).text().await {\n            if let Ok(mut api_key) = serde_json::from_str::\u003cUserApiKey\u003e(\u0026data) {\n                api_key.update_last_used();\n                \n                let serialized = serde_json::to_string(\u0026api_key)\n                    .map_err(|e| ArbitrageError::parse_error(format!(\"Failed to serialize AI key: {}\", e)))?;\n                \n                self.kv_store.put(\u0026key, \u0026serialized)\n                    .map_err(|e| ArbitrageError::storage_error(format!(\"Failed to prepare AI key storage: {}\", e)))?\n                    .execute()\n                    .await\n                    .map_err(|e| ArbitrageError::storage_error(format!(\"Failed to update AI key: {}\", e)))?;\n            }\n        }\n        Ok(())\n    }\n\n    fn create_ai_provider_from_key(\n        \u0026self,\n        api_key: \u0026UserApiKey,\n        decrypted_key: \u0026str,\n    ) -\u003e ArbitrageResult\u003cAiProvider\u003e {\n        match api_key.provider {\n            ApiKeyProvider::OpenAI =\u003e Ok(AiProvider::OpenAI {\n                api_key: decrypted_key.to_string(),\n                base_url: api_key.metadata.get(\"base_url\").and_then(|v| v.as_str()).map(String::from),\n                model: api_key.metadata.get(\"model\").and_then(|v| v.as_str()).map(String::from),\n            }),\n            ApiKeyProvider::Anthropic =\u003e Ok(AiProvider::Anthropic {\n                api_key: decrypted_key.to_string(),\n                base_url: api_key.metadata.get(\"base_url\").and_then(|v| v.as_str()).map(String::from),\n                model: api_key.metadata.get(\"model\").and_then(|v| v.as_str()).map(String::from),\n            }),\n            ApiKeyProvider::Custom =\u003e {\n                let base_url = api_key.metadata.get(\"base_url\")\n                    .and_then(|v| v.as_str())\n                    .ok_or_else(|| ArbitrageError::validation_error(\"Custom provider requires base_url\"))?;\n                \n                let headers = api_key.metadata.get(\"headers\")\n                    .and_then(|v| v.as_object())\n                    .map(|obj| {\n                        obj.iter()\n                            .filter_map(|(k, v)| v.as_str().map(|s| (k.clone(), s.to_string())))\n                            .collect()\n                    })\n                    .unwrap_or_default();\n\n                Ok(AiProvider::Custom {\n                    api_key: decrypted_key.to_string(),\n                    base_url: base_url.to_string(),\n                    headers,\n                    model: api_key.metadata.get(\"model\").and_then(|v| v.as_str()).map(String::from),\n                })\n            }\n            ApiKeyProvider::Exchange(_) =\u003e {\n                Err(ArbitrageError::validation_error(\"Cannot create AI provider from exchange API key\"))\n            }\n        }\n    }\n\n    fn encrypt_string(\u0026self, plaintext: \u0026str) -\u003e ArbitrageResult\u003cString\u003e {\n        use base64::{Engine as _, engine::general_purpose};\n        \n        let key_bytes = self.encryption_key.as_bytes();\n        let encrypted: Vec\u003cu8\u003e = plaintext\n            .as_bytes()\n            .iter()\n            .enumerate()\n            .map(|(i, \u0026byte)| byte ^ key_bytes[i % key_bytes.len()])\n            .collect();\n        \n        Ok(general_purpose::STANDARD.encode(encrypted))\n    }\n\n    fn decrypt_string(\u0026self, ciphertext: \u0026str) -\u003e ArbitrageResult\u003cString\u003e {\n        use base64::{Engine as _, engine::general_purpose};\n        \n        let encrypted = general_purpose::STANDARD.decode(ciphertext).map_err(|e| {\n            ArbitrageError::parse_error(format!(\"Failed to decode base64: {}\", e))\n        })?;\n        \n        let key_bytes = self.encryption_key.as_bytes();\n        let decrypted: Vec\u003cu8\u003e = encrypted\n            .iter()\n            .enumerate()\n            .map(|(i, \u0026byte)| byte ^ key_bytes[i % key_bytes.len()])\n            .collect();\n        \n        String::from_utf8(decrypted).map_err(|e| {\n            ArbitrageError::parse_error(format!(\"Failed to convert decrypted bytes to string: {}\", e))\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    // Mock KV store for testing\n    #[derive(Debug, Clone)]\n    struct MockKvStore {\n        data: std::sync::Arc\u003cstd::sync::Mutex\u003cHashMap\u003cString, String\u003e\u003e\u003e,\n    }\n\n    impl MockKvStore {\n        fn new() -\u003e Self {\n            Self {\n                data: std::sync::Arc::new(std::sync::Mutex::new(HashMap::new())),\n            }\n        }\n\n        async fn get(\u0026self, key: \u0026str) -\u003e Option\u003cString\u003e {\n            let data = self.data.lock().unwrap();\n            data.get(key).cloned()\n        }\n\n        async fn put(\u0026self, key: \u0026str, value: \u0026str) -\u003e Result\u003c(), String\u003e {\n            let mut data = self.data.lock().unwrap();\n            data.insert(key.to_string(), value.to_string());\n            Ok(())\n        }\n\n        async fn delete(\u0026self, key: \u0026str) -\u003e Result\u003c(), String\u003e {\n            let mut data = self.data.lock().unwrap();\n            data.remove(key);\n            Ok(())\n        }\n    }\n\n    fn create_test_config() -\u003e AiIntegrationConfig {\n        AiIntegrationConfig::default()\n    }\n\n    fn create_test_service() -\u003e AiIntegrationService {\n        let config = create_test_config();\n        // Create minimal service for testing (KV store not used in these tests)\n        AiIntegrationService {\n            config,\n            http_client: reqwest::Client::new(),\n            kv_store: unsafe { std::mem::zeroed() }, // Not used in encryption tests\n            encryption_key: \"test-encryption-key-123\".to_string(),\n        }\n    }\n\n    #[test]\n    fn test_ai_integration_config_creation() {\n        let config = create_test_config();\n        assert!(config.enabled);\n        assert_eq!(config.default_timeout_seconds, 30);\n        assert_eq!(config.max_retries, 3);\n        assert_eq!(config.max_ai_keys_per_user, 10);\n        assert_eq!(config.supported_providers.len(), 3);\n    }\n\n    #[test]\n    fn test_ai_integration_service_creation() {\n        // Test that the service can be created with proper configuration\n        let config = create_test_config();\n        assert!(config.enabled);\n        // Note: actual service creation test would require KV mock\n    }\n\n    #[test]\n    fn test_openai_provider_creation() {\n        let provider = AiProvider::OpenAI {\n            api_key: \"test-key\".to_string(),\n            base_url: Some(\"https://api.openai.com\".to_string()),\n            model: Some(\"gpt-4\".to_string()),\n        };\n\n        match provider {\n            AiProvider::OpenAI { api_key, base_url, model } =\u003e {\n                assert_eq!(api_key, \"test-key\");\n                assert_eq!(base_url, Some(\"https://api.openai.com\".to_string()));\n                assert_eq!(model, Some(\"gpt-4\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected OpenAI provider\"),\n        }\n    }\n\n    #[test]\n    fn test_anthropic_provider_creation() {\n        let provider = AiProvider::Anthropic {\n            api_key: \"test-anthropic-key\".to_string(),\n            base_url: None,\n            model: Some(\"claude-3-sonnet\".to_string()),\n        };\n\n        match provider {\n            AiProvider::Anthropic { api_key, base_url, model } =\u003e {\n                assert_eq!(api_key, \"test-anthropic-key\");\n                assert_eq!(base_url, None);\n                assert_eq!(model, Some(\"claude-3-sonnet\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected Anthropic provider\"),\n        }\n    }\n\n    #[test]\n    fn test_custom_provider_creation() {\n        let mut headers = HashMap::new();\n        headers.insert(\"X-API-Key\".to_string(), \"custom-key\".to_string());\n\n        let provider = AiProvider::Custom {\n            api_key: \"custom-api-key\".to_string(),\n            base_url: \"https://custom-ai.example.com\".to_string(),\n            headers: headers.clone(),\n            model: Some(\"custom-model\".to_string()),\n        };\n\n        match provider {\n            AiProvider::Custom { api_key, base_url, headers: provider_headers, model } =\u003e {\n                assert_eq!(api_key, \"custom-api-key\");\n                assert_eq!(base_url, \"https://custom-ai.example.com\");\n                assert_eq!(provider_headers, headers);\n                assert_eq!(model, Some(\"custom-model\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected Custom provider\"),\n        }\n    }\n\n    #[test]\n    fn test_custom_provider_missing_base_url() {\n        let metadata = json!({\n            \"model\": \"test-model\"\n            // Missing base_url\n        });\n\n        let api_key = UserApiKey::new_ai_key(\n            \"user123\".to_string(),\n            ApiKeyProvider::Custom,\n            \"encrypted_key\".to_string(),\n            metadata,\n        );\n\n        // This should be tested in the service context\n        // We expect validation error for missing base_url\n        assert_eq!(api_key.provider, ApiKeyProvider::Custom);\n    }\n\n    #[test]\n    fn test_ai_analysis_request_creation() {\n        let request = AiAnalysisRequest {\n            prompt: \"Analyze this market data\".to_string(),\n            market_data: json!({\"price\": 100.0, \"volume\": 1000}),\n            user_context: Some(json!({\"risk_tolerance\": \"medium\"})),\n            max_tokens: Some(500),\n            temperature: Some(0.7),\n        };\n\n        assert_eq!(request.prompt, \"Analyze this market data\");\n        assert_eq!(request.max_tokens, Some(500));\n        assert_eq!(request.temperature, Some(0.7));\n    }\n\n    #[test]\n    fn test_ai_analysis_response_creation() {\n        let mut metadata = HashMap::new();\n        metadata.insert(\"model\".to_string(), json!(\"gpt-4\"));\n        metadata.insert(\"tokens_used\".to_string(), json!(250));\n\n        let response = AiAnalysisResponse {\n            analysis: \"Market shows bullish trends\".to_string(),\n            confidence: Some(0.8),\n            recommendations: vec![\"Buy\".to_string(), \"Hold\".to_string()],\n            metadata,\n        };\n\n        assert_eq!(response.analysis, \"Market shows bullish trends\");\n        assert_eq!(response.confidence, Some(0.8));\n        assert_eq!(response.recommendations.len(), 2);\n    }\n\n    #[test]\n    fn test_disabled_ai_integration() {\n        let mut config = create_test_config();\n        config.enabled = false;\n        \n        // Test configuration\n        assert!(!config.enabled);\n        assert_eq!(config.max_ai_keys_per_user, 10);\n    }\n\n    #[test]\n    fn test_exchange_key_rejection() {\n        // Test that exchange API keys are properly rejected for AI use\n        let api_key = UserApiKey::new_exchange_key(\n            \"user123\".to_string(),\n            crate::types::ExchangeIdEnum::Binance,\n            \"encrypted_key\".to_string(),\n            \"encrypted_secret\".to_string(),\n            vec![\"trade\".to_string()],\n        );\n\n        // Verify it's an exchange key, not AI key\n        assert!(api_key.is_exchange_key());\n        assert!(!api_key.is_ai_key());\n    }\n\n    #[test]\n    fn test_encryption_decryption() {\n        let service = create_test_service();\n        let plaintext = \"test-api-key-12345\";\n        \n        let encrypted = service.encrypt_string(plaintext).unwrap();\n        assert_ne!(encrypted, plaintext);\n        \n        let decrypted = service.decrypt_string(\u0026encrypted).unwrap();\n        assert_eq!(decrypted, plaintext);\n        \n        // Forget the service to avoid drop issues\n        std::mem::forget(service);\n    }\n\n    #[test]\n    fn test_supported_providers() {\n        let service = create_test_service();\n        \n        let providers = service.get_supported_providers();\n        assert!(providers.contains(\u0026ApiKeyProvider::OpenAI));\n        assert!(providers.contains(\u0026ApiKeyProvider::Anthropic));\n        assert!(providers.contains(\u0026ApiKeyProvider::Custom));\n        \n        assert!(service.is_provider_supported(\u0026ApiKeyProvider::OpenAI));\n        assert!(service.is_provider_supported(\u0026ApiKeyProvider::Anthropic));\n        assert!(service.is_provider_supported(\u0026ApiKeyProvider::Custom));\n        assert!(!service.is_provider_supported(\u0026ApiKeyProvider::Exchange(crate::types::ExchangeIdEnum::Binance)));\n        \n        // Forget the service to avoid drop issues\n        std::mem::forget(service);\n    }\n\n    #[test]\n    fn test_ai_analysis_request_validation() {\n        let request = AiAnalysisRequest {\n            prompt: \"Analyze this market data\".to_string(),\n            market_data: json!({\"symbol\": \"BTCUSDT\", \"price\": 50000.0}),\n            user_context: Some(json!({\"risk_tolerance\": \"medium\"})),\n            max_tokens: Some(1000),\n            temperature: Some(0.7),\n        };\n\n        assert_eq!(request.prompt, \"Analyze this market data\");\n        assert!(request.user_context.is_some());\n        assert_eq!(request.max_tokens, Some(1000));\n        assert_eq!(request.temperature, Some(0.7));\n    }\n\n    #[test]\n    fn test_ai_analysis_response_creation_comprehensive() {\n        let mut metadata = HashMap::new();\n        metadata.insert(\"model\".to_string(), json!(\"gpt-4\"));\n        metadata.insert(\"usage\".to_string(), json!({\"tokens\": 150}));\n\n        let response = AiAnalysisResponse {\n            analysis: \"Market shows bullish trend\".to_string(),\n            confidence: Some(0.85),\n            recommendations: vec![\"Buy\".to_string(), \"Hold\".to_string()],\n            metadata,\n        };\n\n        assert_eq!(response.analysis, \"Market shows bullish trend\");\n        assert_eq!(response.confidence, Some(0.85));\n        assert_eq!(response.recommendations.len(), 2);\n        assert!(response.metadata.contains_key(\"model\"));\n    }\n\n    #[test]\n    fn test_create_ai_provider_from_user_api_key() {\n        let service = create_test_service();\n        \n        // Test OpenAI provider creation\n        let openai_key = UserApiKey::new_ai_key(\n            \"user123\".to_string(),\n            ApiKeyProvider::OpenAI,\n            \"encrypted-key\".to_string(),\n            json!({\"model\": \"gpt-4\", \"base_url\": \"https://api.openai.com\"}),\n        );\n\n        let provider = service.create_ai_provider(\u0026openai_key).unwrap();\n        match provider {\n            AiProvider::OpenAI { model, base_url, .. } =\u003e {\n                assert_eq!(model, Some(\"gpt-4\".to_string()));\n                assert_eq!(base_url, Some(\"https://api.openai.com\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected OpenAI provider\"),\n        }\n\n        // Test Anthropic provider creation\n        let anthropic_key = UserApiKey::new_ai_key(\n            \"user123\".to_string(),\n            ApiKeyProvider::Anthropic,\n            \"encrypted-key\".to_string(),\n            json!({\"model\": \"claude-3\"}),\n        );\n\n        let provider = service.create_ai_provider(\u0026anthropic_key).unwrap();\n        match provider {\n            AiProvider::Anthropic { model, .. } =\u003e {\n                assert_eq!(model, Some(\"claude-3\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected Anthropic provider\"),\n        }\n\n        // Test Custom provider creation\n        let custom_key = UserApiKey::new_ai_key(\n            \"user123\".to_string(),\n            ApiKeyProvider::Custom,\n            \"encrypted-key\".to_string(),\n            json!({\n                \"base_url\": \"https://custom-ai.com/api\",\n                \"model\": \"custom-model\",\n                \"headers\": {\"Authorization\": \"Bearer token\"}\n            }),\n        );\n\n        let provider = service.create_ai_provider(\u0026custom_key).unwrap();\n        match provider {\n            AiProvider::Custom { base_url, model, headers, .. } =\u003e {\n                assert_eq!(base_url, \"https://custom-ai.com/api\");\n                assert_eq!(model, Some(\"custom-model\".to_string()));\n                assert!(headers.contains_key(\"Authorization\"));\n            }\n            _ =\u003e panic!(\"Expected Custom provider\"),\n        }\n        \n        // Forget the service to avoid drop issues\n        std::mem::forget(service);\n    }\n\n    #[test]\n    fn test_create_ai_provider_custom_missing_base_url() {\n        let service = create_test_service();\n        \n        let custom_key = UserApiKey::new_ai_key(\n            \"user123\".to_string(),\n            ApiKeyProvider::Custom,\n            \"encrypted-key\".to_string(),\n            json!({\"model\": \"custom-model\"}), // Missing base_url\n        );\n\n        let result = service.create_ai_provider(\u0026custom_key);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"Custom provider requires base_url\"));\n        \n        // Forget the service to avoid drop issues\n        std::mem::forget(service);\n    }\n\n    #[test]\n    fn test_create_ai_provider_from_exchange_key() {\n        let service = create_test_service();\n        \n        let exchange_key = UserApiKey::new_exchange_key(\n            \"user123\".to_string(),\n            crate::types::ExchangeIdEnum::Binance,\n            \"encrypted-key\".to_string(),\n            \"encrypted-secret\".to_string(),\n            vec![\"spot\".to_string()],\n        );\n\n        let result = service.create_ai_provider(\u0026exchange_key);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"Cannot create AI provider from exchange API key\"));\n        \n        // Forget the service to avoid drop issues\n        std::mem::forget(service);\n    }\n} ","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":8}},{"line":28,"address":[],"length":0,"stats":{"Line":8}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":5}},{"line":293,"address":[],"length":0,"stats":{"Line":5}},{"line":294,"address":[],"length":0,"stats":{"Line":1}},{"line":295,"address":[],"length":0,"stats":{"Line":1}},{"line":296,"address":[],"length":0,"stats":{"Line":2}},{"line":297,"address":[],"length":0,"stats":{"Line":1}},{"line":299,"address":[],"length":0,"stats":{"Line":1}},{"line":300,"address":[],"length":0,"stats":{"Line":1}},{"line":301,"address":[],"length":0,"stats":{"Line":2}},{"line":302,"address":[],"length":0,"stats":{"Line":3}},{"line":305,"address":[],"length":0,"stats":{"Line":3}},{"line":306,"address":[],"length":0,"stats":{"Line":5}},{"line":307,"address":[],"length":0,"stats":{"Line":6}},{"line":310,"address":[],"length":0,"stats":{"Line":1}},{"line":311,"address":[],"length":0,"stats":{"Line":1}},{"line":312,"address":[],"length":0,"stats":{"Line":1}},{"line":313,"address":[],"length":0,"stats":{"Line":5}},{"line":314,"address":[],"length":0,"stats":{"Line":1}},{"line":322,"address":[],"length":0,"stats":{"Line":1}},{"line":326,"address":[],"length":0,"stats":{"Line":1}},{"line":332,"address":[],"length":0,"stats":{"Line":1}},{"line":333,"address":[],"length":0,"stats":{"Line":1}},{"line":337,"address":[],"length":0,"stats":{"Line":4}},{"line":338,"address":[],"length":0,"stats":{"Line":4}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":1}},{"line":689,"address":[],"length":0,"stats":{"Line":1}},{"line":690,"address":[],"length":0,"stats":{"Line":1}},{"line":694,"address":[],"length":0,"stats":{"Line":20}},{"line":697,"address":[],"length":0,"stats":{"Line":1}},{"line":700,"address":[],"length":0,"stats":{"Line":1}},{"line":703,"address":[],"length":0,"stats":{"Line":2}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":18}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}}],"covered":34,"coverable":312},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","services","exchange.rs"],"content":"// src/services/exchange.rs\n\nuse chrono::Utc;\nuse reqwest::{Client, Method};\nuse serde_json::{json, Value};\n\nuse crate::types::*;\nuse crate::utils::{ArbitrageError, ArbitrageResult};\n\n// Exchange authentication helper\nuse hmac::{Hmac, Mac};\nuse sha2::Sha256;\nuse hex;\n\n#[allow(dead_code)]\npub trait ExchangeInterface {\n    async fn save_api_key(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n    ) -\u003e ArbitrageResult\u003c()\u003e;\n\n    async fn get_api_key(\u0026self, exchange_id: \u0026str) -\u003e ArbitrageResult\u003cOption\u003cExchangeCredentials\u003e\u003e;\n    async fn delete_api_key(\u0026self, exchange_id: \u0026str) -\u003e ArbitrageResult\u003c()\u003e;\n\n    async fn get_markets(\u0026self, exchange_id: \u0026str) -\u003e ArbitrageResult\u003cVec\u003cMarket\u003e\u003e;\n    async fn get_ticker(\u0026self, exchange_id: \u0026str, symbol: \u0026str) -\u003e ArbitrageResult\u003cTicker\u003e;\n    async fn get_orderbook(\n        \u0026self,\n        exchange_id: \u0026str,\n        symbol: \u0026str,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e ArbitrageResult\u003cOrderBook\u003e;\n\n    async fn fetch_funding_rates(\n        \u0026self,\n        exchange_id: \u0026str,\n        symbol: Option\u003c\u0026str\u003e,\n    ) -\u003e ArbitrageResult\u003cVec\u003cValue\u003e\u003e;\n\n    async fn get_balance(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n    ) -\u003e ArbitrageResult\u003cValue\u003e;\n\n    async fn create_order(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n        symbol: \u0026str,\n        side: \u0026str,\n        amount: f64,\n        price: Option\u003cf64\u003e,\n    ) -\u003e ArbitrageResult\u003cValue\u003e;\n\n    async fn cancel_order(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n        order_id: \u0026str,\n        symbol: \u0026str,\n    ) -\u003e ArbitrageResult\u003cValue\u003e;\n\n    async fn get_open_orders(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n        symbol: Option\u003c\u0026str\u003e,\n    ) -\u003e ArbitrageResult\u003cVec\u003cValue\u003e\u003e;\n\n    async fn get_open_positions(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n        symbol: Option\u003c\u0026str\u003e,\n    ) -\u003e ArbitrageResult\u003cVec\u003cValue\u003e\u003e;\n\n    async fn set_leverage(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n        symbol: \u0026str,\n        leverage: u32,\n    ) -\u003e ArbitrageResult\u003cValue\u003e;\n\n    async fn get_trading_fees(\n        \u0026self,\n        exchange_id: \u0026str,\n        _credentials: \u0026ExchangeCredentials,\n        symbol: \u0026str,\n    ) -\u003e ArbitrageResult\u003cValue\u003e;\n}\n\npub struct ExchangeService {\n    client: Client,\n    kv: worker::kv::KvStore,\n}\n\nimpl ExchangeService {\n    #[allow(clippy::result_large_err)]\n    pub fn new(env: \u0026Env) -\u003e ArbitrageResult\u003cSelf\u003e {\n        let kv = env.get_kv_store(\"ARBITRAGE_KV\").ok_or_else(|| {\n            ArbitrageError::internal_error(\n                \"Failed to get KV store: ARBITRAGE_KV binding not found\".to_string()\n            )\n        })?;\n\n        let client = Client::new();\n\n        Ok(Self {\n            client,\n            kv,\n        })\n    }\n\n    #[allow(clippy::result_large_err)]\n    fn parse_binance_ticker(\u0026self, data: \u0026Value, symbol: \u0026str) -\u003e ArbitrageResult\u003cTicker\u003e {\n        Ok(Ticker {\n            symbol: symbol.to_string(),\n            bid: data[\"bidPrice\"].as_str().and_then(|s| s.parse().ok()),\n            ask: data[\"askPrice\"].as_str().and_then(|s| s.parse().ok()),\n            last: data[\"price\"].as_str().and_then(|s| s.parse().ok()),\n            high: data[\"highPrice\"].as_str().and_then(|s| s.parse().ok()),\n            low: data[\"lowPrice\"].as_str().and_then(|s| s.parse().ok()),\n            volume: data[\"volume\"].as_str().and_then(|s| s.parse().ok()),\n            timestamp: Some(Utc::now()),\n            datetime: Some(Utc::now().to_rfc3339()),\n        })\n    }\n\n    #[allow(clippy::result_large_err)]\n    fn parse_bybit_ticker(\u0026self, data: \u0026Value, symbol: \u0026str) -\u003e ArbitrageResult\u003cTicker\u003e {\n        Ok(Ticker {\n            symbol: symbol.to_string(),\n            bid: data[\"bid1Price\"].as_str().and_then(|s| s.parse().ok()),\n            ask: data[\"ask1Price\"].as_str().and_then(|s| s.parse().ok()),\n            last: data[\"lastPrice\"].as_str().and_then(|s| s.parse().ok()),\n            high: data[\"highPrice24h\"].as_str().and_then(|s| s.parse().ok()),\n            low: data[\"lowPrice24h\"].as_str().and_then(|s| s.parse().ok()),\n            volume: data[\"volume24h\"].as_str().and_then(|s| s.parse().ok()),\n            timestamp: Some(Utc::now()),\n            datetime: Some(Utc::now().to_rfc3339()),\n        })\n    }\n\n    // Exchange-specific implementations\n    async fn binance_request(\n        \u0026self,\n        endpoint: \u0026str,\n        method: Method,\n        params: Option\u003cValue\u003e,\n        auth: Option\u003c\u0026ExchangeCredentials\u003e,\n    ) -\u003e ArbitrageResult\u003cValue\u003e {\n        let base_url = \"https://api.binance.com\";\n        let url = format!(\"{}{}\", base_url, endpoint);\n\n        let mut request = self.client.request(method, \u0026url);\n\n        // Collect all query parameters\n        let mut query_params = Vec::new();\n        \n        // Add query parameters from the params argument\n        if let Some(params) = params {\n            if let Some(obj) = params.as_object() {\n                for (key, value) in obj {\n                    if let Some(str_val) = value.as_str() {\n                        query_params.push((key.clone(), str_val.to_string()));\n                    } else {\n                        query_params.push((key.clone(), value.to_string()));\n                    }\n                }\n            }\n        }\n\n        // Add authentication if provided\n        if let Some(creds) = auth {\n            let timestamp = Utc::now().timestamp_millis();\n            \n            // Add timestamp to query parameters\n            query_params.push((\"timestamp\".to_string(), timestamp.to_string()));\n            \n            // Sort query parameters for consistent signature generation\n            query_params.sort();\n            let query_string = query_params\n                .iter()\n                .map(|(k, v)| format!(\"{}={}\", k, v))\n                .collect::\u003cVec\u003c_\u003e\u003e()\n                .join(\"\u0026\");\n\n            // Create signature\n            let mut mac = Hmac::\u003cSha256\u003e::new_from_slice(creds.secret.as_bytes()).map_err(|e| {\n                ArbitrageError::authentication_error(format!(\"Invalid secret key: {}\", e))\n            })?;\n            mac.update(query_string.as_bytes());\n            let signature = hex::encode(mac.finalize().into_bytes());\n\n            // Add signature to query params\n            query_params.push((\"signature\".to_string(), signature));\n            \n            // Set query parameters\n            request = request.query(\u0026query_params);\n            request = request.header(\"X-MBX-APIKEY\", \u0026creds.api_key);\n        } else {\n            // If no auth, just add the regular parameters\n            if !query_params.is_empty() {\n                request = request.query(\u0026query_params);\n            }\n        }\n\n        let response = request\n            .send()\n            .await\n            .map_err(|e| ArbitrageError::network_error(format!(\"HTTP request failed: {}\", e)))?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_default();\n            return Err(ArbitrageError::api_error(format!(\n                \"Binance API error: {}\",\n                error_text\n            )));\n        }\n\n        let json: Value = response\n            .json()\n            .await\n            .map_err(|e| ArbitrageError::parse_error(format!(\"Failed to parse JSON: {}\", e)))?;\n        Ok(json)\n    }\n\n    async fn bybit_request(\n        \u0026self,\n        endpoint: \u0026str,\n        method: Method,\n        params: Option\u003cValue\u003e,\n        auth: Option\u003c\u0026ExchangeCredentials\u003e,\n    ) -\u003e ArbitrageResult\u003cValue\u003e {\n        let base_url = \"https://api.bybit.com\";\n        let url = format!(\"{}{}\", base_url, endpoint);\n\n        let mut request = self.client.request(method, \u0026url);\n\n        // Add authentication if provided\n        if let Some(creds) = auth {\n            let timestamp = Utc::now().timestamp_millis();\n            let recv_window = \"5000\";\n\n            let param_str = if let Some(params) = \u0026params {\n                serde_json::to_string(params).unwrap_or_default()\n            } else {\n                \"{}\".to_string()\n            };\n\n            let sign_str = format!(\"{}{}{}{}\", timestamp, \u0026creds.api_key, recv_window, param_str);\n\n            let mut mac = Hmac::\u003cSha256\u003e::new_from_slice(creds.secret.as_bytes()).map_err(|e| {\n                ArbitrageError::authentication_error(format!(\"Invalid secret key: {}\", e))\n            })?;\n            mac.update(sign_str.as_bytes());\n            let signature = hex::encode(mac.finalize().into_bytes());\n\n            request = request\n                .header(\"X-BAPI-API-KEY\", \u0026creds.api_key)\n                .header(\"X-BAPI-SIGN\", signature)\n                .header(\"X-BAPI-TIMESTAMP\", timestamp.to_string())\n                .header(\"X-BAPI-RECV-WINDOW\", recv_window)\n                .header(\"Content-Type\", \"application/json\");\n\n            if let Some(params) = params {\n                request = request.json(\u0026params);\n            }\n        }\n\n        let response = request\n            .send()\n            .await\n            .map_err(|e| ArbitrageError::network_error(format!(\"HTTP request failed: {}\", e)))?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_default();\n            return Err(ArbitrageError::api_error(format!(\n                \"Bybit API error: {}\",\n                error_text\n            )));\n        }\n\n        let json: Value = response\n            .json()\n            .await\n            .map_err(|e| ArbitrageError::parse_error(format!(\"Failed to parse JSON: {}\", e)))?;\n        Ok(json)\n    }\n}\n\nimpl ExchangeInterface for ExchangeService {\n    async fn save_api_key(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n    ) -\u003e ArbitrageResult\u003c()\u003e {\n        let key = format!(\"exchange_credentials_{}\", exchange_id);\n        let value = serde_json::to_string(credentials).map_err(|e| {\n            ArbitrageError::serialization_error(format!(\"Failed to serialize credentials: {}\", e))\n        })?;\n\n        self.kv.put(\u0026key, value)\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to save credentials: {}\", e))\n            })?\n            .execute()\n            .await\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to execute save: {}\", e))\n            })?;\n\n        Ok(())\n    }\n\n    async fn get_api_key(\u0026self, exchange_id: \u0026str) -\u003e ArbitrageResult\u003cOption\u003cExchangeCredentials\u003e\u003e {\n        let key = format!(\"exchange_credentials_{}\", exchange_id);\n        \n        match self.kv.get(\u0026key).text().await {\n            Ok(Some(value)) =\u003e {\n                let credentials: ExchangeCredentials = serde_json::from_str(\u0026value).map_err(|e| {\n                    ArbitrageError::parse_error(format!(\"Failed to deserialize credentials: {}\", e))\n                })?;\n                Ok(Some(credentials))\n            }\n            Ok(None) =\u003e Ok(None),\n            Err(e) =\u003e Err(ArbitrageError::database_error(format!(\"Failed to get credentials: {}\", e))),\n        }\n    }\n\n    async fn delete_api_key(\u0026self, exchange_id: \u0026str) -\u003e ArbitrageResult\u003c()\u003e {\n        let key = format!(\"exchange_credentials_{}\", exchange_id);\n        self.kv.delete(\u0026key)\n            .await\n            .map_err(|e| ArbitrageError::database_error(format!(\"Failed to delete credentials: {}\", e)))?;\n        Ok(())\n    }\n\n    async fn get_markets(\u0026self, exchange_id: \u0026str) -\u003e ArbitrageResult\u003cVec\u003cMarket\u003e\u003e {\n        let markets = match exchange_id {\n            \"binance\" =\u003e {\n                let response = self.binance_request(\"/api/v3/exchangeInfo\", Method::GET, None, None).await?;\n                let empty_vec = vec![];\n                let symbols = response[\"symbols\"].as_array().unwrap_or(\u0026empty_vec);\n                \n                symbols.iter().map(|symbol| {\n                    Market {\n                        id: symbol[\"symbol\"].as_str().unwrap_or(\"\").to_string(),\n                        symbol: symbol[\"symbol\"].as_str().unwrap_or(\"\").to_string(),\n                        base: symbol[\"baseAsset\"].as_str().unwrap_or(\"\").to_string(),\n                        quote: symbol[\"quoteAsset\"].as_str().unwrap_or(\"\").to_string(),\n                        active: symbol[\"status\"].as_str() == Some(\"TRADING\"),\n                        precision: Precision {\n                            amount: symbol[\"baseAssetPrecision\"].as_i64().map(|x| x as i32),\n                            price: symbol[\"quotePrecision\"].as_i64().map(|x| x as i32),\n                        },\n                        limits: Limits {\n                            amount: MinMax { min: Some(0.0), max: None },\n                            price: MinMax { min: Some(0.0), max: None },\n                            cost: MinMax { min: Some(0.0), max: None },\n                        },\n                        fees: None,\n                    }\n                }).collect()\n            }\n            \"bybit\" =\u003e {\n                let response = self.bybit_request(\"/v5/market/instruments-info\", Method::GET, Some(json!({\"category\": \"spot\"})), None).await?;\n                let empty_vec = vec![];\n                let symbols = response[\"result\"][\"list\"].as_array().unwrap_or(\u0026empty_vec);\n                \n                symbols.iter().map(|symbol| {\n                    Market {\n                        id: symbol[\"symbol\"].as_str().unwrap_or(\"\").to_string(),\n                        symbol: symbol[\"symbol\"].as_str().unwrap_or(\"\").to_string(),\n                        base: symbol[\"baseCoin\"].as_str().unwrap_or(\"\").to_string(),\n                        quote: symbol[\"quoteCoin\"].as_str().unwrap_or(\"\").to_string(),\n                        active: symbol[\"status\"].as_str() == Some(\"Trading\"),\n                        precision: Precision {\n                            amount: None,\n                            price: None,\n                        },\n                        limits: Limits {\n                            amount: MinMax { min: Some(0.0), max: None },\n                            price: MinMax { min: Some(0.0), max: None },\n                            cost: MinMax { min: Some(0.0), max: None },\n                        },\n                        fees: None,\n                    }\n                }).collect()\n            }\n            _ =\u003e return Err(ArbitrageError::validation_error(format!(\"Unsupported exchange: {}\", exchange_id))),\n        };\n\n        Ok(markets)\n    }\n\n    async fn get_ticker(\u0026self, exchange_id: \u0026str, symbol: \u0026str) -\u003e ArbitrageResult\u003cTicker\u003e {\n        match exchange_id {\n            \"binance\" =\u003e {\n                let response = self.binance_request(\n                    \"/api/v3/ticker/24hr\",\n                    Method::GET,\n                    Some(json!({\"symbol\": symbol})),\n                    None,\n                ).await?;\n                self.parse_binance_ticker(\u0026response, symbol)\n            }\n            \"bybit\" =\u003e {\n                let response = self.bybit_request(\n                    \"/v5/market/tickers\",\n                    Method::GET,\n                    Some(json!({\"category\": \"spot\", \"symbol\": symbol})),\n                    None,\n                ).await?;\n                \n                if let Some(list) = response[\"result\"][\"list\"].as_array() {\n                    if let Some(ticker_data) = list.first() {\n                        return self.parse_bybit_ticker(ticker_data, symbol);\n                    }\n                }\n                Err(ArbitrageError::not_found(format!(\"Ticker not found for symbol: {}\", symbol)))\n            }\n            _ =\u003e Err(ArbitrageError::validation_error(format!(\"Unsupported exchange: {}\", exchange_id))),\n        }\n    }\n\n    async fn get_orderbook(\n        \u0026self,\n        exchange_id: \u0026str,\n        symbol: \u0026str,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e ArbitrageResult\u003cOrderBook\u003e {\n        let limit = limit.unwrap_or(100);\n        \n        match exchange_id {\n            \"binance\" =\u003e {\n                let response = self.binance_request(\n                    \"/api/v3/depth\",\n                    Method::GET,\n                    Some(json!({\"symbol\": symbol, \"limit\": limit})),\n                    None,\n                ).await?;\n                \n                let empty_vec = vec![];\n                let bids: Vec\u003c[f64; 2]\u003e = response[\"bids\"].as_array()\n                    .unwrap_or(\u0026empty_vec)\n                    .iter()\n                    .filter_map(|bid| {\n                        if let Some(arr) = bid.as_array() {\n                            if arr.len() \u003e= 2 {\n                                let price = arr[0].as_str()?.parse().ok()?;\n                                let amount = arr[1].as_str()?.parse().ok()?;\n                                Some([price, amount])\n                            } else { None }\n                        } else { None }\n                    })\n                    .collect();\n                \n                let empty_vec2 = vec![];\n                let asks: Vec\u003c[f64; 2]\u003e = response[\"asks\"].as_array()\n                    .unwrap_or(\u0026empty_vec2)\n                    .iter()\n                    .filter_map(|ask| {\n                        if let Some(arr) = ask.as_array() {\n                            if arr.len() \u003e= 2 {\n                                let price = arr[0].as_str()?.parse().ok()?;\n                                let amount = arr[1].as_str()?.parse().ok()?;\n                                Some([price, amount])\n                            } else { None }\n                        } else { None }\n                    })\n                    .collect();\n                \n                Ok(OrderBook {\n                    symbol: symbol.to_string(),\n                    bids,\n                    asks,\n                    timestamp: Some(Utc::now()),\n                    datetime: Some(Utc::now().to_rfc3339()),\n                })\n            }\n            _ =\u003e Err(ArbitrageError::validation_error(format!(\"Unsupported exchange: {}\", exchange_id))),\n        }\n    }\n\n    async fn fetch_funding_rates(\n        \u0026self,\n        exchange_id: \u0026str,\n        symbol: Option\u003c\u0026str\u003e,\n    ) -\u003e ArbitrageResult\u003cVec\u003cValue\u003e\u003e {\n        match exchange_id {\n            \"binance\" =\u003e {\n                let mut params = json!({});\n                if let Some(s) = symbol {\n                    params[\"symbol\"] = json!(s);\n                }\n                \n                let response = self.binance_request(\n                    \"/fapi/v1/premiumIndex\",\n                    Method::GET,\n                    Some(params),\n                    None,\n                ).await?;\n                \n                if response.is_array() {\n                    Ok(response.as_array().unwrap().clone())\n                } else {\n                    Ok(vec![response])\n                }\n            }\n            _ =\u003e Err(ArbitrageError::validation_error(format!(\"Unsupported exchange: {}\", exchange_id))),\n        }\n    }\n\n    async fn get_balance(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n    ) -\u003e ArbitrageResult\u003cValue\u003e {\n        Err(ArbitrageError::not_implemented(format!(\n            \"get_balance not implemented for exchange: {}\", \n            exchange_id\n        )))\n    }\n\n    async fn create_order(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n        symbol: \u0026str,\n        side: \u0026str,\n        amount: f64,\n        price: Option\u003cf64\u003e,\n    ) -\u003e ArbitrageResult\u003cValue\u003e {\n        Err(ArbitrageError::not_implemented(format!(\n            \"create_order not implemented for exchange: {}\", \n            exchange_id\n        )))\n    }\n\n    async fn cancel_order(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n        order_id: \u0026str,\n        symbol: \u0026str,\n    ) -\u003e ArbitrageResult\u003cValue\u003e {\n        Err(ArbitrageError::not_implemented(format!(\n            \"cancel_order not implemented for exchange: {}\", \n            exchange_id\n        )))\n    }\n\n    async fn get_open_orders(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n        symbol: Option\u003c\u0026str\u003e,\n    ) -\u003e ArbitrageResult\u003cVec\u003cValue\u003e\u003e {\n        Err(ArbitrageError::not_implemented(format!(\n            \"get_open_orders not implemented for exchange: {}\", \n            exchange_id\n        )))\n    }\n\n    async fn get_open_positions(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n        symbol: Option\u003c\u0026str\u003e,\n    ) -\u003e ArbitrageResult\u003cVec\u003cValue\u003e\u003e {\n        Err(ArbitrageError::not_implemented(format!(\n            \"get_open_positions not implemented for exchange: {}\", \n            exchange_id\n        )))\n    }\n\n    async fn set_leverage(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n        symbol: \u0026str,\n        leverage: u32,\n    ) -\u003e ArbitrageResult\u003cValue\u003e {\n        Err(ArbitrageError::not_implemented(format!(\n            \"set_leverage not implemented for exchange: {}\", \n            exchange_id\n        )))\n    }\n\n    async fn get_trading_fees(\n        \u0026self,\n        exchange_id: \u0026str,\n        _credentials: \u0026ExchangeCredentials,\n        symbol: \u0026str,\n    ) -\u003e ArbitrageResult\u003cValue\u003e {\n        match exchange_id {\n            \"binance\" =\u003e {\n                // Binance trading fees endpoint\n                let response = self.binance_request(\n                    \"/api/v3/exchangeInfo\",\n                    Method::GET,\n                    Some(json!({\"symbol\": symbol})),\n                    None,\n                ).await?;\n                \n                // Extract trading fees from exchange info\n                if let Some(symbols) = response[\"symbols\"].as_array() {\n                    for symbol_info in symbols {\n                        if symbol_info[\"symbol\"].as_str() == Some(symbol) {\n                            // Default Binance fees if not specified in response\n                            return Ok(json!({\n                                \"symbol\": symbol,\n                                \"maker\": 0.001,  // 0.1% default maker fee\n                                \"taker\": 0.001,  // 0.1% default taker fee\n                                \"exchange\": \"binance\"\n                            }));\n                        }\n                    }\n                }\n                \n                // Fallback to default fees\n                Ok(json!({\n                    \"symbol\": symbol,\n                    \"maker\": 0.001,\n                    \"taker\": 0.001,\n                    \"exchange\": \"binance\"\n                }))\n            }\n            \"bybit\" =\u003e {\n                // Bybit trading fees - using default rates as API requires authentication\n                Ok(json!({\n                    \"symbol\": symbol,\n                    \"maker\": 0.001,  // 0.1% default maker fee\n                    \"taker\": 0.001,  // 0.1% default taker fee  \n                    \"exchange\": \"bybit\"\n                }))\n            }\n            _ =\u003e Err(ArbitrageError::validation_error(format!(\n                \"get_trading_fees not implemented for exchange: {}\", \n                exchange_id\n            ))),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n    use chrono::Utc;\n    use std::collections::HashMap;\n\n    // Mock environment for testing\n    struct MockEnv {\n        kv: HashMap\u003cString, String\u003e,\n    }\n\n    impl MockEnv {\n        fn new() -\u003e Self {\n            Self {\n                kv: HashMap::new(),\n            }\n        }\n\n        fn with_kv_data(mut self, key: \u0026str, value: \u0026str) -\u003e Self {\n            self.kv.insert(key.to_string(), value.to_string());\n            self\n        }\n    }\n\n    // Helper function to create test credentials\n    fn create_test_credentials() -\u003e ExchangeCredentials {\n        ExchangeCredentials {\n            api_key: \"test_api_key\".to_string(),\n            secret: \"test_secret_key\".to_string(),\n            default_leverage: 20,\n            exchange_type: \"spot\".to_string(),\n        }\n    }\n\n    // Helper function to create mock Binance ticker data\n    fn create_mock_binance_ticker_data() -\u003e Value {\n        json!({\n            \"bidPrice\": \"50000.50\",\n            \"askPrice\": \"50001.00\",\n            \"price\": \"50000.75\",\n            \"highPrice\": \"51000.00\",\n            \"lowPrice\": \"49000.00\",\n            \"volume\": \"1234.56\"\n        })\n    }\n\n    // Helper function to create mock Bybit ticker data\n    fn create_mock_bybit_ticker_data() -\u003e Value {\n        json!({\n            \"bid1Price\": \"50000.50\",\n            \"ask1Price\": \"50001.00\",\n            \"lastPrice\": \"50000.75\",\n            \"highPrice24h\": \"51000.00\",\n            \"lowPrice24h\": \"49000.00\",\n            \"volume24h\": \"1234.56\"\n        })\n    }\n\n    // Tests for ticker parsing methods\n    mod ticker_parsing_tests {\n        use super::*;\n\n        #[test]\n        fn test_parse_binance_ticker_success() {\n            // Create a mock service (we only need the parsing method)\n            let env = MockEnv::new();\n            // Note: We can't easily create ExchangeService without Worker KV, \n            // so we'll test the data parsing logic directly with mock data\n            \n            let ticker_data = create_mock_binance_ticker_data();\n            let symbol = \"BTCUSDT\";\n\n            // Expected values from mock data\n            assert_eq!(ticker_data[\"bidPrice\"], \"50000.50\");\n            assert_eq!(ticker_data[\"askPrice\"], \"50001.00\");\n            assert_eq!(ticker_data[\"price\"], \"50000.75\");\n            assert_eq!(ticker_data[\"highPrice\"], \"51000.00\");\n            assert_eq!(ticker_data[\"lowPrice\"], \"49000.00\");\n            assert_eq!(ticker_data[\"volume\"], \"1234.56\");\n\n            // Test individual field parsing\n            let bid = ticker_data[\"bidPrice\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let ask = ticker_data[\"askPrice\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let last = ticker_data[\"price\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let high = ticker_data[\"highPrice\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let low = ticker_data[\"lowPrice\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let volume = ticker_data[\"volume\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n\n            assert_eq!(bid, Some(50000.50));\n            assert_eq!(ask, Some(50001.00));\n            assert_eq!(last, Some(50000.75));\n            assert_eq!(high, Some(51000.00));\n            assert_eq!(low, Some(49000.00));\n            assert_eq!(volume, Some(1234.56));\n        }\n\n        #[test]\n        fn test_parse_bybit_ticker_success() {\n            let ticker_data = create_mock_bybit_ticker_data();\n            let symbol = \"BTCUSDT\";\n\n            // Expected values from mock data\n            assert_eq!(ticker_data[\"bid1Price\"], \"50000.50\");\n            assert_eq!(ticker_data[\"ask1Price\"], \"50001.00\");\n            assert_eq!(ticker_data[\"lastPrice\"], \"50000.75\");\n            assert_eq!(ticker_data[\"highPrice24h\"], \"51000.00\");\n            assert_eq!(ticker_data[\"lowPrice24h\"], \"49000.00\");\n            assert_eq!(ticker_data[\"volume24h\"], \"1234.56\");\n\n            // Test individual field parsing (Bybit format)\n            let bid = ticker_data[\"bid1Price\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let ask = ticker_data[\"ask1Price\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let last = ticker_data[\"lastPrice\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let high = ticker_data[\"highPrice24h\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let low = ticker_data[\"lowPrice24h\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let volume = ticker_data[\"volume24h\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n\n            assert_eq!(bid, Some(50000.50));\n            assert_eq!(ask, Some(50001.00));\n            assert_eq!(last, Some(50000.75));\n            assert_eq!(high, Some(51000.00));\n            assert_eq!(low, Some(49000.00));\n            assert_eq!(volume, Some(1234.56));\n        }\n\n        #[test]\n        fn test_binance_ticker_parsing_with_invalid_data() {\n            // Test with malformed price data\n            let invalid_data = json!({\n                \"bidPrice\": \"invalid_price\",\n                \"askPrice\": \"50001.00\",\n                \"price\": \"\",\n                \"highPrice\": null,\n                \"lowPrice\": \"49000.00\",\n                \"volume\": \"not_a_number\"\n            });\n\n            // Test parsing - invalid strings should return None\n            let bid = invalid_data[\"bidPrice\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let ask = invalid_data[\"askPrice\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let last = invalid_data[\"price\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let high = invalid_data[\"highPrice\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let low = invalid_data[\"lowPrice\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let volume = invalid_data[\"volume\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n\n            assert_eq!(bid, None); // Invalid price string\n            assert_eq!(ask, Some(50001.00)); // Valid price\n            assert_eq!(last, None); // Empty string\n            assert_eq!(high, None); // Null value\n            assert_eq!(low, Some(49000.00)); // Valid price\n            assert_eq!(volume, None); // Invalid number string\n        }\n\n        #[test]\n        fn test_ticker_field_extraction_edge_cases() {\n            // Test with missing fields\n            let minimal_data = json!({\n                \"bidPrice\": \"50000.50\"\n                // Missing other fields\n            });\n\n            let bid = minimal_data[\"bidPrice\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let ask = minimal_data[\"askPrice\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let last = minimal_data[\"price\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n\n            assert_eq!(bid, Some(50000.50));\n            assert_eq!(ask, None); // Missing field\n            assert_eq!(last, None); // Missing field\n        }\n    }\n\n    // Tests for signature generation and authentication\n    mod authentication_tests {\n        use super::*;\n        use hmac::{Hmac, Mac};\n        use sha2::Sha256;\n\n        #[test]\n        fn test_hmac_signature_generation() {\n            let secret = \"test_secret_key\";\n            let message = \"timestamp=1234567890\u0026symbol=BTCUSDT\";\n\n            // Test HMAC-SHA256 signature generation (same as used in binance_request)\n            let mut mac = Hmac::\u003cSha256\u003e::new_from_slice(secret.as_bytes()).unwrap();\n            mac.update(message.as_bytes());\n            let signature = hex::encode(mac.finalize().into_bytes());\n\n            // Signature should be consistent\n            assert!(!signature.is_empty());\n            assert_eq!(signature.len(), 64); // SHA256 hex string length\n\n            // Test with same input should produce same signature\n            let mut mac2 = Hmac::\u003cSha256\u003e::new_from_slice(secret.as_bytes()).unwrap();\n            mac2.update(message.as_bytes());\n            let signature2 = hex::encode(mac2.finalize().into_bytes());\n\n            assert_eq!(signature, signature2);\n        }\n\n        #[test]\n        fn test_query_parameter_sorting() {\n            // Test query parameter sorting logic (used in binance authentication)\n            let mut params = vec![\n                (\"symbol\".to_string(), \"BTCUSDT\".to_string()),\n                (\"timestamp\".to_string(), \"1234567890\".to_string()),\n                (\"limit\".to_string(), \"100\".to_string()),\n            ];\n\n            params.sort();\n            let query_string = params\n                .iter()\n                .map(|(k, v)| format!(\"{}={}\", k, v))\n                .collect::\u003cVec\u003c_\u003e\u003e()\n                .join(\"\u0026\");\n\n            assert_eq!(query_string, \"limit=100\u0026symbol=BTCUSDT\u0026timestamp=1234567890\");\n        }\n\n        #[test]\n        fn test_credentials_structure() {\n            let creds = create_test_credentials();\n            \n            assert_eq!(creds.api_key, \"test_api_key\");\n            assert_eq!(creds.secret, \"test_secret_key\");\n            assert_eq!(creds.default_leverage, 20);\n            assert_eq!(creds.exchange_type, \"spot\");\n        }\n\n        #[test]\n        fn test_credentials_serialization() {\n            let credentials = create_test_credentials();\n            \n            // Test that credentials can be serialized and deserialized\n            let serialized = serde_json::to_string(\u0026credentials).unwrap();\n            let deserialized: ExchangeCredentials = serde_json::from_str(\u0026serialized).unwrap();\n            \n            assert_eq!(credentials.api_key, deserialized.api_key);\n            assert_eq!(credentials.secret, deserialized.secret);\n            assert_eq!(credentials.default_leverage, deserialized.default_leverage);\n            assert_eq!(credentials.exchange_type, deserialized.exchange_type);\n        }\n    }\n\n    // Tests for market data parsing\n    mod market_data_tests {\n        use super::*;\n\n        #[test]\n        fn test_binance_market_parsing() {\n            let market_data = json!({\n                \"symbol\": \"BTCUSDT\",\n                \"baseAsset\": \"BTC\",\n                \"quoteAsset\": \"USDT\",\n                \"status\": \"TRADING\",\n                \"baseAssetPrecision\": 8,\n                \"quotePrecision\": 8\n            });\n\n            // Test individual field extraction\n            let symbol = market_data[\"symbol\"].as_str().unwrap_or(\"\");\n            let base = market_data[\"baseAsset\"].as_str().unwrap_or(\"\");\n            let quote = market_data[\"quoteAsset\"].as_str().unwrap_or(\"\");\n            let active = market_data[\"status\"].as_str() == Some(\"TRADING\");\n            let base_precision = market_data[\"baseAssetPrecision\"].as_i64().map(|x| x as i32);\n            let quote_precision = market_data[\"quotePrecision\"].as_i64().map(|x| x as i32);\n\n            assert_eq!(symbol, \"BTCUSDT\");\n            assert_eq!(base, \"BTC\");\n            assert_eq!(quote, \"USDT\");\n            assert_eq!(active, true);\n            assert_eq!(base_precision, Some(8));\n            assert_eq!(quote_precision, Some(8));\n        }\n\n        #[test]\n        fn test_bybit_market_parsing() {\n            let market_data = json!({\n                \"symbol\": \"BTCUSDT\",\n                \"baseCoin\": \"BTC\",\n                \"quoteCoin\": \"USDT\",\n                \"status\": \"Trading\"\n            });\n\n            // Test individual field extraction (Bybit format)\n            let symbol = market_data[\"symbol\"].as_str().unwrap_or(\"\");\n            let base = market_data[\"baseCoin\"].as_str().unwrap_or(\"\");\n            let quote = market_data[\"quoteCoin\"].as_str().unwrap_or(\"\");\n            let active = market_data[\"status\"].as_str() == Some(\"Trading\");\n\n            assert_eq!(symbol, \"BTCUSDT\");\n            assert_eq!(base, \"BTC\");\n            assert_eq!(quote, \"USDT\");\n            assert_eq!(active, true);\n        }\n\n        #[test]\n        fn test_inactive_market_detection() {\n            // Test inactive market for Binance\n            let inactive_binance = json!({\n                \"symbol\": \"OLDCOIN\",\n                \"status\": \"HALT\"\n            });\n            let active = inactive_binance[\"status\"].as_str() == Some(\"TRADING\");\n            assert_eq!(active, false);\n\n            // Test inactive market for Bybit\n            let inactive_bybit = json!({\n                \"symbol\": \"OLDCOIN\",\n                \"status\": \"Closed\"\n            });\n            let active_bybit = inactive_bybit[\"status\"].as_str() == Some(\"Trading\");\n            assert_eq!(active_bybit, false);\n        }\n    }\n\n    // Tests for orderbook parsing\n    mod orderbook_tests {\n        use super::*;\n\n        #[test]\n        fn test_binance_orderbook_parsing() {\n            let orderbook_data = json!({\n                \"bids\": [\n                    [\"50000.50\", \"1.5\"],\n                    [\"50000.00\", \"2.0\"],\n                    [\"49999.50\", \"0.5\"]\n                ],\n                \"asks\": [\n                    [\"50001.00\", \"1.2\"],\n                    [\"50001.50\", \"1.8\"],\n                    [\"50002.00\", \"0.3\"]\n                ]\n            });\n\n            // Test bid parsing\n            let empty_vec = vec![];\n            let bids: Vec\u003c[f64; 2]\u003e = orderbook_data[\"bids\"].as_array()\n                .unwrap_or(\u0026empty_vec)\n                .iter()\n                .filter_map(|bid| {\n                    if let Some(arr) = bid.as_array() {\n                        if arr.len() \u003e= 2 {\n                            let price = arr[0].as_str()?.parse().ok()?;\n                            let amount = arr[1].as_str()?.parse().ok()?;\n                            Some([price, amount])\n                        } else { None }\n                    } else { None }\n                })\n                .collect();\n\n            assert_eq!(bids.len(), 3);\n            assert_eq!(bids[0], [50000.50, 1.5]);\n            assert_eq!(bids[1], [50000.00, 2.0]);\n            assert_eq!(bids[2], [49999.50, 0.5]);\n\n            // Test ask parsing\n            let empty_vec2 = vec![];\n            let asks: Vec\u003c[f64; 2]\u003e = orderbook_data[\"asks\"].as_array()\n                .unwrap_or(\u0026empty_vec2)\n                .iter()\n                .filter_map(|ask| {\n                    if let Some(arr) = ask.as_array() {\n                        if arr.len() \u003e= 2 {\n                            let price = arr[0].as_str()?.parse().ok()?;\n                            let amount = arr[1].as_str()?.parse().ok()?;\n                            Some([price, amount])\n                        } else { None }\n                    } else { None }\n                })\n                .collect();\n\n            assert_eq!(asks.len(), 3);\n            assert_eq!(asks[0], [50001.00, 1.2]);\n            assert_eq!(asks[1], [50001.50, 1.8]);\n            assert_eq!(asks[2], [50002.00, 0.3]);\n        }\n\n        #[test]\n        fn test_malformed_orderbook_data() {\n            let malformed_data = json!({\n                \"bids\": [\n                    [\"invalid_price\", \"1.5\"],\n                    [\"50000.00\"], // Missing amount\n                    null, // Null entry\n                    [\"49999.50\", \"invalid_amount\"]\n                ],\n                \"asks\": []\n            });\n\n            // Test that malformed entries are filtered out\n            let empty_vec = vec![];\n            let bids: Vec\u003c[f64; 2]\u003e = malformed_data[\"bids\"].as_array()\n                .unwrap_or(\u0026empty_vec)\n                .iter()\n                .filter_map(|bid| {\n                    if let Some(arr) = bid.as_array() {\n                        if arr.len() \u003e= 2 {\n                            let price = arr[0].as_str()?.parse().ok()?;\n                            let amount = arr[1].as_str()?.parse().ok()?;\n                            Some([price, amount])\n                        } else { None }\n                    } else { None }\n                })\n                .collect();\n\n            // Only valid entries should remain (none in this case)\n            assert_eq!(bids.len(), 0);\n        }\n\n        #[test]\n        fn test_empty_orderbook() {\n            let empty_data = json!({\n                \"bids\": [],\n                \"asks\": []\n            });\n\n            let empty_vec = vec![];\n            let bids: Vec\u003c[f64; 2]\u003e = empty_data[\"bids\"].as_array()\n                .unwrap_or(\u0026empty_vec)\n                .iter()\n                .filter_map(|bid| {\n                    if let Some(arr) = bid.as_array() {\n                        if arr.len() \u003e= 2 {\n                            let price = arr[0].as_str()?.parse().ok()?;\n                            let amount = arr[1].as_str()?.parse().ok()?;\n                            Some([price, amount])\n                        } else { None }\n                    } else { None }\n                })\n                .collect();\n\n            let empty_vec2 = vec![];\n            let asks: Vec\u003c[f64; 2]\u003e = empty_data[\"asks\"].as_array()\n                .unwrap_or(\u0026empty_vec2)\n                .iter()\n                .filter_map(|ask| {\n                    if let Some(arr) = ask.as_array() {\n                        if arr.len() \u003e= 2 {\n                            let price = arr[0].as_str()?.parse().ok()?;\n                            let amount = arr[1].as_str()?.parse().ok()?;\n                            Some([price, amount])\n                        } else { None }\n                    } else { None }\n                })\n                .collect();\n\n            assert_eq!(bids.len(), 0);\n            assert_eq!(asks.len(), 0);\n        }\n    }\n\n    // Tests for funding rate data\n    mod funding_rate_tests {\n        use super::*;\n\n        #[test]\n        fn test_binance_funding_rate_single_symbol() {\n            let funding_data = json!({\n                \"symbol\": \"BTCUSDT\",\n                \"markPrice\": \"50000.12345678\",\n                \"indexPrice\": \"50000.01234567\", \n                \"estimatedSettlePrice\": \"50000.01234567\",\n                \"lastFundingRate\": \"0.00010000\",\n                \"nextFundingTime\": 1234567890000_u64,\n                \"interestRate\": \"0.00010000\",\n                \"time\": 1234567890000_u64\n            });\n\n            // Test that we can extract relevant funding rate information\n            let symbol = funding_data[\"symbol\"].as_str().unwrap_or(\"\");\n            let funding_rate = funding_data[\"lastFundingRate\"].as_str()\n                .and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let next_funding_time = funding_data[\"nextFundingTime\"].as_u64();\n\n            assert_eq!(symbol, \"BTCUSDT\");\n            assert_eq!(funding_rate, Some(0.00010000));\n            assert_eq!(next_funding_time, Some(1234567890000));\n        }\n\n        #[test]\n        fn test_binance_funding_rate_array_response() {\n            let funding_array = json!([\n                {\n                    \"symbol\": \"BTCUSDT\",\n                    \"lastFundingRate\": \"0.00010000\"\n                },\n                {\n                    \"symbol\": \"ETHUSDT\", \n                    \"lastFundingRate\": \"0.00015000\"\n                }\n            ]);\n\n            // Test array processing\n            if let Some(arr) = funding_array.as_array() {\n                assert_eq!(arr.len(), 2);\n                \n                let btc_rate = arr[0][\"lastFundingRate\"].as_str()\n                    .and_then(|s| s.parse::\u003cf64\u003e().ok());\n                let eth_rate = arr[1][\"lastFundingRate\"].as_str()\n                    .and_then(|s| s.parse::\u003cf64\u003e().ok());\n\n                assert_eq!(btc_rate, Some(0.00010000));\n                assert_eq!(eth_rate, Some(0.00015000));\n            } else {\n                panic!(\"Expected array response\");\n            }\n        }\n    }\n\n    // Tests for exchange validation and error handling\n    mod validation_tests {\n        use super::*;\n\n        #[test]\n        fn test_supported_exchanges() {\n            let supported_exchanges = vec![\"binance\", \"bybit\"];\n            \n            for exchange in supported_exchanges {\n                // These should not return validation errors for basic checks\n                assert!(!exchange.is_empty());\n                assert!(exchange.len() \u003e 2);\n            }\n        }\n\n        #[test]\n        fn test_unsupported_exchange_detection() {\n            let unsupported_exchanges = vec![\"coinbase\", \"kraken\", \"ftx\", \"\"];\n            \n            // Test that unsupported exchange names would trigger validation errors\n            for exchange in unsupported_exchanges {\n                match exchange {\n                    \"binance\" | \"bybit\" =\u003e {\n                        // These should be supported\n                        assert!(false, \"Should not reach here for supported exchanges\");\n                    }\n                    _ =\u003e {\n                        // These should be unsupported\n                        assert!(true, \"Correctly identified as unsupported: {}\", exchange);\n                    }\n                }\n            }\n        }\n\n        #[test]\n        fn test_symbol_validation() {\n            let valid_symbols = vec![\"BTCUSDT\", \"ETHUSDT\", \"ADAUSDT\"];\n            let invalid_symbols = vec![\"\", \"BTC\", \"invalid_symbol_format\"];\n\n            for symbol in valid_symbols {\n                assert!(!symbol.is_empty());\n                assert!(symbol.len() \u003e= 6); // Minimum length for base+quote\n                assert!(symbol.chars().all(|c| c.is_ascii_uppercase()));\n            }\n\n            for symbol in invalid_symbols {\n                // These would trigger validation in real implementation\n                if symbol.is_empty() || symbol.len() \u003c 6 {\n                    assert!(true, \"Correctly identified as invalid: {}\", symbol);\n                }\n            }\n        }\n    }\n\n    // Tests for KV storage key generation\n    mod storage_tests {\n        use super::*;\n\n        #[test]\n        fn test_kv_key_generation() {\n            let exchange_id = \"binance\";\n            let expected_key = format!(\"exchange_credentials_{}\", exchange_id);\n            \n            assert_eq!(expected_key, \"exchange_credentials_binance\");\n        }\n\n        #[test]\n        fn test_kv_key_generation_different_exchanges() {\n            let exchanges = vec![\"binance\", \"bybit\", \"okx\"];\n            \n            for exchange in exchanges {\n                let key = format!(\"exchange_credentials_{}\", exchange);\n                assert!(key.starts_with(\"exchange_credentials_\"));\n                assert!(key.ends_with(exchange));\n            }\n        }\n    }\n\n    // Tests for error scenarios that should be handled\n    mod error_handling_tests {\n        use super::*;\n\n        #[test]\n        fn test_error_type_construction() {\n            // Test different error types that the service should handle\n            let network_error = ArbitrageError::network_error(\"Connection failed\".to_string());\n            let api_error = ArbitrageError::api_error(\"API rate limit\".to_string());\n            let parse_error = ArbitrageError::parse_error(\"Invalid JSON\".to_string());\n            let auth_error = ArbitrageError::authentication_error(\"Invalid credentials\".to_string());\n\n            // Verify error messages contain expected content\n            assert!(network_error.to_string().contains(\"Connection failed\"));\n            assert!(api_error.to_string().contains(\"API rate limit\"));\n            assert!(parse_error.to_string().contains(\"Invalid JSON\"));\n            assert!(auth_error.to_string().contains(\"Invalid credentials\"));\n        }\n\n        #[test]\n        fn test_not_implemented_methods() {\n            // Test that not-implemented methods return appropriate errors\n            let exchange_id = \"binance\";\n            let error_msg = format!(\"get_balance not implemented for exchange: {}\", exchange_id);\n            \n            assert!(error_msg.contains(\"not implemented\"));\n            assert!(error_msg.contains(exchange_id));\n        }\n\n        #[test]\n        fn test_empty_response_handling() {\n            // Test handling of empty or null responses\n            let empty_json = json!({});\n            let null_json = json!(null);\n            let missing_field = json!({\"other_field\": \"value\"});\n\n            // Test that missing fields are handled gracefully\n            assert!(empty_json[\"nonexistent\"].is_null());\n            assert!(null_json.is_null());\n            assert!(missing_field[\"expected_field\"].is_null());\n        }\n    }\n\n    // Integration-style tests for business logic\n    mod business_logic_tests {\n        use super::*;\n\n        #[test]\n        fn test_complete_ticker_flow() {\n            // Test the complete flow of ticker data processing\n            let mock_binance_response = create_mock_binance_ticker_data();\n            let symbol = \"BTCUSDT\";\n\n            // Simulate the ticker parsing logic\n            let ticker = Ticker {\n                symbol: symbol.to_string(),\n                bid: mock_binance_response[\"bidPrice\"].as_str().and_then(|s| s.parse().ok()),\n                ask: mock_binance_response[\"askPrice\"].as_str().and_then(|s| s.parse().ok()),\n                last: mock_binance_response[\"price\"].as_str().and_then(|s| s.parse().ok()),\n                high: mock_binance_response[\"highPrice\"].as_str().and_then(|s| s.parse().ok()),\n                low: mock_binance_response[\"lowPrice\"].as_str().and_then(|s| s.parse().ok()),\n                volume: mock_binance_response[\"volume\"].as_str().and_then(|s| s.parse().ok()),\n                timestamp: Some(Utc::now()),\n                datetime: Some(Utc::now().to_rfc3339()),\n            };\n\n            // Verify complete ticker structure\n            assert_eq!(ticker.symbol, \"BTCUSDT\");\n            assert_eq!(ticker.bid, Some(50000.5));\n            assert_eq!(ticker.ask, Some(50001.0));\n            assert_eq!(ticker.last, Some(50000.75));\n            assert_eq!(ticker.high, Some(51000.0));\n            assert_eq!(ticker.low, Some(49000.0));\n            assert_eq!(ticker.volume, Some(1234.56));\n            assert!(ticker.timestamp.is_some());\n            assert!(ticker.datetime.is_some());\n        }\n\n        #[test]\n        fn test_market_structure_creation() {\n            // Test creating a complete Market structure\n            let market = Market {\n                id: \"BTCUSDT\".to_string(),\n                symbol: \"BTCUSDT\".to_string(),\n                base: \"BTC\".to_string(),\n                quote: \"USDT\".to_string(),\n                active: true,\n                precision: Precision {\n                    amount: Some(8),\n                    price: Some(8),\n                },\n                limits: Limits {\n                    amount: MinMax { min: Some(0.001), max: Some(1000.0) },\n                    price: MinMax { min: Some(0.01), max: Some(100000.0) },\n                    cost: MinMax { min: Some(10.0), max: None },\n                },\n                fees: None,\n            };\n\n            // Verify market structure\n            assert_eq!(market.symbol, \"BTCUSDT\");\n            assert_eq!(market.base, \"BTC\");\n            assert_eq!(market.quote, \"USDT\");\n            assert_eq!(market.active, true);\n            assert_eq!(market.precision.amount, Some(8));\n            assert_eq!(market.precision.price, Some(8));\n        }\n\n        #[test]\n        fn test_orderbook_structure_creation() {\n            // Test creating a complete OrderBook structure\n            let orderbook = OrderBook {\n                symbol: \"BTCUSDT\".to_string(),\n                bids: vec![\n                    [50000.50, 1.5],\n                    [50000.00, 2.0],\n                ],\n                asks: vec![\n                    [50001.00, 1.2],\n                    [50001.50, 1.8],\n                ],\n                timestamp: Some(Utc::now()),\n                datetime: Some(Utc::now().to_rfc3339()),\n            };\n\n            // Verify orderbook structure\n            assert_eq!(orderbook.symbol, \"BTCUSDT\");\n            assert_eq!(orderbook.bids.len(), 2);\n            assert_eq!(orderbook.asks.len(), 2);\n            assert_eq!(orderbook.bids[0], [50000.50, 1.5]);\n            assert_eq!(orderbook.asks[0], [50001.00, 1.2]);\n            assert!(orderbook.timestamp.is_some());\n        }\n    }\n\n    mod service_integration_tests {\n        use super::*;\n        use std::collections::HashMap;\n\n        // Test the business logic without requiring actual worker environment\n        \n        #[test]\n        fn test_exchange_service_ticker_parsing_integration() {\n            // Test binance ticker parsing logic\n            let binance_data = create_mock_binance_ticker_data();\n            \n            // Manually test the parsing logic that would be used in parse_binance_ticker\n            let _symbol = \"BTCUSDT\";\n            let bid = binance_data[\"bidPrice\"].as_str().and_then(|s| s.parse().ok());\n            let ask = binance_data[\"askPrice\"].as_str().and_then(|s| s.parse().ok());\n            let last = binance_data[\"price\"].as_str().and_then(|s| s.parse().ok());\n            \n            // Update expected values to match the mock data\n            assert_eq!(bid, Some(50000.5));  // Changed from 50000.0 to 50000.5\n            assert_eq!(ask, Some(50001.0));  // Changed from 50050.0 to 50001.0\n            assert_eq!(last, Some(50000.75)); // Changed from 50025.0 to 50000.75\n            \n            // Test bybit ticker parsing logic\n            let bybit_data = create_mock_bybit_ticker_data();\n            let bid = bybit_data[\"bid1Price\"].as_str().and_then(|s| s.parse().ok());\n            let ask = bybit_data[\"ask1Price\"].as_str().and_then(|s| s.parse().ok());\n            let last = bybit_data[\"lastPrice\"].as_str().and_then(|s| s.parse().ok());\n            \n            // Update expected values to match the mock data  \n            assert_eq!(bid, Some(50000.5));  // Changed from 49999.0 to 50000.5\n            assert_eq!(ask, Some(50001.0));  // Same value\n            assert_eq!(last, Some(50000.75)); // Changed from 50000.0 to 50000.75\n        }\n\n        #[test]\n        fn test_exchange_credentials_key_generation() {\n            // Test the key generation logic for API credentials\n            let exchange_id = \"binance\";\n            let expected_key = format!(\"exchange_credentials_{}\", exchange_id);\n            assert_eq!(expected_key, \"exchange_credentials_binance\");\n            \n            let exchange_id = \"bybit\";\n            let expected_key = format!(\"exchange_credentials_{}\", exchange_id);\n            assert_eq!(expected_key, \"exchange_credentials_bybit\");\n        }\n\n        #[test]\n        fn test_exchange_credentials_serialization() {\n            let credentials = create_test_credentials();\n            \n            // Test that credentials can be serialized and deserialized\n            let serialized = serde_json::to_string(\u0026credentials).unwrap();\n            let deserialized: ExchangeCredentials = serde_json::from_str(\u0026serialized).unwrap();\n            \n            assert_eq!(credentials.api_key, deserialized.api_key);\n            assert_eq!(credentials.secret, deserialized.secret);\n            assert_eq!(credentials.default_leverage, deserialized.default_leverage);\n            assert_eq!(credentials.exchange_type, deserialized.exchange_type);\n        }\n\n        #[test]\n        fn test_exchange_orderbook_parsing_logic() {\n            // Test orderbook parsing logic for Binance format\n            let orderbook_data = json!({\n                \"bids\": [\n                    [\"50000.00\", \"1.50\"],\n                    [\"49999.00\", \"2.00\"],\n                    [\"49998.00\", \"0.50\"]\n                ],\n                \"asks\": [\n                    [\"50001.00\", \"1.00\"],\n                    [\"50002.00\", \"1.20\"],\n                    [\"50003.00\", \"0.80\"]\n                ]\n            });\n            \n            let empty_vec = vec![];\n            let bids: Vec\u003c[f64; 2]\u003e = orderbook_data[\"bids\"].as_array()\n                .unwrap_or(\u0026empty_vec)\n                .iter()\n                .filter_map(|bid| {\n                    if let Some(arr) = bid.as_array() {\n                        if arr.len() \u003e= 2 {\n                            let price = arr[0].as_str()?.parse().ok()?;\n                            let amount = arr[1].as_str()?.parse().ok()?;\n                            Some([price, amount])\n                        } else { None }\n                    } else { None }\n                })\n                .collect();\n            \n            assert_eq!(bids.len(), 3);\n            assert_eq!(bids[0], [50000.0, 1.5]);\n            assert_eq!(bids[1], [49999.0, 2.0]);\n            assert_eq!(bids[2], [49998.0, 0.5]);\n        }\n\n        #[test]\n        fn test_market_data_structure_validation() {\n            // Test that market data structures are properly formed\n            let market = Market {\n                id: \"BTCUSDT\".to_string(),\n                symbol: \"BTCUSDT\".to_string(),\n                base: \"BTC\".to_string(),\n                quote: \"USDT\".to_string(),\n                active: true,\n                precision: Precision {\n                    amount: Some(8),\n                    price: Some(2),\n                },\n                limits: Limits {\n                    amount: MinMax { min: Some(0.001), max: Some(1000.0) },\n                    price: MinMax { min: Some(0.01), max: Some(100000.0) },\n                    cost: MinMax { min: Some(10.0), max: None },\n                },\n                fees: None,\n            };\n            \n            assert_eq!(market.symbol, \"BTCUSDT\");\n            assert_eq!(market.base, \"BTC\");\n            assert_eq!(market.quote, \"USDT\");\n            assert!(market.active);\n            assert_eq!(market.precision.amount, Some(8));\n            assert_eq!(market.precision.price, Some(2));\n        }\n\n        #[test]\n        fn test_orderbook_data_structure_validation() {\n            // Test OrderBook structure creation and validation\n            let orderbook = OrderBook {\n                symbol: \"BTCUSDT\".to_string(),\n                bids: vec![[50000.0, 1.5], [49999.0, 2.0], [49998.0, 0.5]],\n                asks: vec![[50001.0, 1.0], [50002.0, 1.2], [50003.0, 0.8]],\n                timestamp: Some(Utc::now()),\n                datetime: Some(Utc::now().to_rfc3339()),\n            };\n            \n            assert_eq!(orderbook.symbol, \"BTCUSDT\");\n            assert_eq!(orderbook.bids.len(), 3);\n            assert_eq!(orderbook.asks.len(), 3);\n            \n            // Verify bid/ask ordering assumptions\n            assert!(orderbook.bids[0][0] \u003e orderbook.bids[1][0]); // Bids should be descending price\n            assert!(orderbook.asks[0][0] \u003c orderbook.asks[1][0]); // Asks should be ascending price\n            \n            // Verify spread\n            let best_bid = orderbook.bids[0][0];\n            let best_ask = orderbook.asks[0][0];\n            assert!(best_ask \u003e best_bid); // Spread should be positive\n        }\n\n        #[test]\n        fn test_ticker_data_structure_validation() {\n            let ticker = Ticker {\n                symbol: \"BTCUSDT\".to_string(),\n                bid: Some(50000.0),\n                ask: Some(50050.0),\n                last: Some(50025.0),\n                high: Some(51000.0),\n                low: Some(49000.0),\n                volume: Some(1234.56),\n                timestamp: Some(Utc::now()),\n                datetime: Some(Utc::now().to_rfc3339()),\n            };\n            \n            assert_eq!(ticker.symbol, \"BTCUSDT\");\n            assert!(ticker.bid.is_some());\n            assert!(ticker.ask.is_some());\n            assert!(ticker.last.is_some());\n            \n            // Verify bid/ask relationship\n            if let (Some(bid), Some(ask)) = (ticker.bid, ticker.ask) {\n                assert!(ask \u003e= bid); // Ask should be \u003e= bid\n            }\n            \n            // Verify high/low relationship\n            if let (Some(high), Some(low), Some(last)) = (ticker.high, ticker.low, ticker.last) {\n                assert!(high \u003e= low); // High should be \u003e= low\n                assert!(last \u003e= low \u0026\u0026 last \u003c= high); // Last should be within high/low range\n            }\n        }\n\n        #[test]\n        fn test_exchange_credentials_validation() {\n            let credentials = create_test_credentials();\n            \n            // Test that credentials have required fields\n            assert!(!credentials.api_key.is_empty());\n            assert!(!credentials.secret.is_empty());\n            \n            // Test default leverage\n            assert!(credentials.default_leverage \u003e 0);\n            \n            // Test exchange type\n            assert!(!credentials.exchange_type.is_empty());\n        }\n\n        #[test]\n        fn test_funding_rate_data_structure() {\n            // Test funding rate data structure validation\n            let funding_rate_data = json!({\n                \"symbol\": \"BTCUSDT\",\n                \"fundingRate\": \"0.0001\",\n                \"fundingTime\": 1234567890000u64,\n                \"nextFundingTime\": 1234567890000u64 + 28800000\n            });\n            \n            assert_eq!(funding_rate_data[\"symbol\"].as_str().unwrap(), \"BTCUSDT\");\n            assert_eq!(funding_rate_data[\"fundingRate\"].as_str().unwrap(), \"0.0001\");\n            assert!(funding_rate_data[\"fundingTime\"].as_u64().is_some());\n            assert!(funding_rate_data[\"nextFundingTime\"].as_u64().is_some());\n        }\n\n        #[test]\n        fn test_exchange_api_parameter_handling() {\n            // Test parameter handling for API requests\n            let symbol = \"BTCUSDT\";\n            let limit = 100u32;\n            \n            // Test Binance-style parameters\n            let binance_params = json!({\n                \"symbol\": symbol,\n                \"limit\": limit\n            });\n            \n            assert_eq!(binance_params[\"symbol\"].as_str().unwrap(), \"BTCUSDT\");\n            assert_eq!(binance_params[\"limit\"].as_u64().unwrap(), 100);\n            \n            // Test Bybit-style parameters\n            let bybit_params = json!({\n                \"category\": \"spot\",\n                \"symbol\": symbol\n            });\n            \n            assert_eq!(bybit_params[\"category\"].as_str().unwrap(), \"spot\");\n            assert_eq!(bybit_params[\"symbol\"].as_str().unwrap(), \"BTCUSDT\");\n        }\n\n        #[test]\n        fn test_exchange_error_handling_logic() {\n            // Test error handling for various scenarios\n            \n            // Test empty market data\n            let empty_markets: Vec\u003cValue\u003e = vec![];\n            assert_eq!(empty_markets.len(), 0);\n            \n            // Test invalid ticker data\n            let invalid_ticker = json!({\n                \"symbol\": \"INVALID\",\n                \"price\": \"not_a_number\"\n            });\n            \n            let parsed_price = invalid_ticker[\"price\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            assert!(parsed_price.is_none());\n            \n            // Test missing required fields\n            let incomplete_data = json!({\n                \"symbol\": \"BTCUSDT\"\n                // Missing other required fields\n            });\n            \n            assert!(incomplete_data[\"bidPrice\"].as_str().is_none());\n            assert!(incomplete_data[\"askPrice\"].as_str().is_none());\n        }\n    }\n}\n","traces":[{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":295},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","services","global_opportunity.rs"],"content":"// src/services/global_opportunity.rs\n\nuse crate::types::{\n    ArbitrageOpportunity, ArbitrageType, ExchangeIdEnum, FundingRateInfo,\n    GlobalOpportunity, OpportunityQueue, OpportunitySource, DistributionStrategy,\n    UserOpportunityDistribution, GlobalOpportunityConfig, FairnessConfig,\n    UserProfile, SubscriptionTier\n};\nuse crate::utils::{ArbitrageError, ArbitrageResult};\nuse crate::services::exchange::{ExchangeService, ExchangeInterface};\nuse crate::services::user_profile::UserProfileService;\nuse crate::{log_info, log_error, log_debug};\nuse std::sync::Arc;\nuse std::collections::HashMap;\nuse futures::future::join_all;\nuse worker::kv::KvStore;\nuse serde_json;\nuse chrono::Utc;\n\n/// Global Opportunity Service for Task 2\n/// Implements system-wide opportunity detection, queue management, and fair distribution\npub struct GlobalOpportunityService {\n    config: GlobalOpportunityConfig,\n    exchange_service: Arc\u003cExchangeService\u003e,\n    user_profile_service: Arc\u003cUserProfileService\u003e,\n    kv_store: KvStore,\n    current_queue: Option\u003cOpportunityQueue\u003e,\n    distribution_tracking: HashMap\u003cString, UserOpportunityDistribution\u003e,\n}\n\nimpl GlobalOpportunityService {\n    const OPPORTUNITY_QUEUE_KEY: \u0026'static str = \"global_opportunity_queue\";\n    const DISTRIBUTION_TRACKING_PREFIX: \u0026'static str = \"user_opportunity_dist\";\n    const ACTIVE_USERS_KEY: \u0026'static str = \"active_users_list\";\n\n    pub fn new(\n        config: GlobalOpportunityConfig,\n        exchange_service: Arc\u003cExchangeService\u003e,\n        user_profile_service: Arc\u003cUserProfileService\u003e,\n        kv_store: KvStore,\n    ) -\u003e Self {\n        Self {\n            config,\n            exchange_service,\n            user_profile_service,\n            kv_store,\n            current_queue: None,\n            distribution_tracking: HashMap::new(),\n        }\n    }\n\n    /// Load or create the global opportunity queue\n    pub async fn initialize_queue(\u0026mut self) -\u003e ArbitrageResult\u003c()\u003e {\n        match self.load_queue().await {\n            Ok(queue) =\u003e {\n                log_info!(\"Loaded existing global opportunity queue\", serde_json::json!({\n                    \"queue_id\": queue.id,\n                    \"opportunities_count\": queue.opportunities.len(),\n                    \"active_users\": queue.active_users.len()\n                }));\n                self.current_queue = Some(queue);\n            }\n            Err(_) =\u003e {\n                log_info!(\"Creating new global opportunity queue\", serde_json::json!({}));\n                let new_queue = OpportunityQueue {\n                    id: uuid::Uuid::new_v4().to_string(),\n                    opportunities: Vec::new(),\n                    created_at: Utc::now().timestamp_millis() as u64,\n                    updated_at: Utc::now().timestamp_millis() as u64,\n                    total_distributed: 0,\n                    active_users: Vec::new(),\n                };\n                self.save_queue(\u0026new_queue).await?;\n                self.current_queue = Some(new_queue);\n            }\n        }\n        Ok(())\n    }\n\n    /// Main detection loop - discovers new opportunities using default strategy\n    pub async fn detect_opportunities(\u0026mut self) -\u003e ArbitrageResult\u003cVec\u003cGlobalOpportunity\u003e\u003e {\n        log_info!(\"Starting global opportunity detection\", serde_json::json!({\n            \"min_threshold\": self.config.min_threshold,\n            \"max_threshold\": self.config.max_threshold,\n            \"exchanges\": self.config.monitored_exchanges.len(),\n            \"pairs\": self.config.monitored_pairs.len()\n        }));\n\n        let mut new_opportunities = Vec::new();\n\n        // Step 1: Fetch funding rates for all monitored pairs and exchanges\n        let mut funding_rate_data: HashMap\u003cString, HashMap\u003cExchangeIdEnum, Option\u003cFundingRateInfo\u003e\u003e\u003e = HashMap::new();\n\n        // Initialize maps for each pair\n        for pair in \u0026self.config.monitored_pairs {\n            funding_rate_data.insert(pair.clone(), HashMap::new());\n        }\n\n        // Collect funding rate fetch tasks\n        let mut funding_tasks = Vec::new();\n\n        for pair in \u0026self.config.monitored_pairs {\n            for exchange_id in \u0026self.config.monitored_exchanges {\n                let exchange_service = Arc::clone(\u0026self.exchange_service);\n                let pair = pair.clone();\n                let exchange_id = *exchange_id;\n\n                let task = Box::pin(async move {\n                    let result = exchange_service\n                        .fetch_funding_rates(\u0026exchange_id.to_string(), Some(\u0026pair))\n                        .await;\n                    \n                    let funding_info = match result {\n                        Ok(rates) =\u003e {\n                            if let Some(rate_data) = rates.first() {\n                                match rate_data[\"fundingRate\"].as_str() {\n                                    Some(rate_str) =\u003e {\n                                        match rate_str.parse::\u003cf64\u003e() {\n                                            Ok(funding_rate) =\u003e Some(FundingRateInfo {\n                                                symbol: pair.clone(),\n                                                funding_rate,\n                                                timestamp: Some(Utc::now()),\n                                                datetime: Some(Utc::now().to_rfc3339()),\n                                                next_funding_time: None,\n                                                estimated_rate: None,\n                                            }),\n                                            Err(_) =\u003e None,\n                                        }\n                                    }\n                                    None =\u003e None,\n                                }\n                            } else {\n                                None\n                            }\n                        }\n                        Err(_) =\u003e None,\n                    };\n                    \n                    (pair, exchange_id, funding_info)\n                });\n                funding_tasks.push(task);\n            }\n        }\n\n        // Execute all funding rate fetch operations concurrently\n        let funding_results = join_all(funding_tasks).await;\n\n        // Process funding rate results\n        for (pair, exchange_id, funding_info) in funding_results {\n            if let Some(pair_map) = funding_rate_data.get_mut(\u0026pair) {\n                pair_map.insert(exchange_id, funding_info);\n            }\n        }\n\n        // Step 2: Identify arbitrage opportunities using default strategy\n        for pair in \u0026self.config.monitored_pairs {\n            if let Some(pair_funding_rates) = funding_rate_data.get(pair) {\n                let available_exchanges: Vec\u003cExchangeIdEnum\u003e = pair_funding_rates\n                    .iter()\n                    .filter_map(|(exchange_id, rate_info)| {\n                        if rate_info.is_some() {\n                            Some(*exchange_id)\n                        } else {\n                            None\n                        }\n                    })\n                    .collect();\n\n                if available_exchanges.len() \u003c 2 {\n                    continue;\n                }\n\n                // Compare all pairs of exchanges for opportunities\n                for i in 0..available_exchanges.len() {\n                    for j in (i + 1)..available_exchanges.len() {\n                        let exchange_a = available_exchanges[i];\n                        let exchange_b = available_exchanges[j];\n\n                        if let (Some(Some(rate_a)), Some(Some(rate_b))) = (\n                            pair_funding_rates.get(\u0026exchange_a),\n                            pair_funding_rates.get(\u0026exchange_b),\n                        ) {\n                            let rate_diff = (rate_a.funding_rate - rate_b.funding_rate).abs();\n\n                            // Check if opportunity meets our thresholds\n                            if rate_diff \u003e= self.config.min_threshold \u0026\u0026 rate_diff \u003c= self.config.max_threshold {\n                                let (long_exchange, short_exchange, long_rate, short_rate) =\n                                    if rate_a.funding_rate \u003e rate_b.funding_rate {\n                                        (exchange_b, exchange_a, rate_b.funding_rate, rate_a.funding_rate)\n                                    } else {\n                                        (exchange_a, exchange_b, rate_a.funding_rate, rate_b.funding_rate)\n                                    };\n\n                                // Create base arbitrage opportunity\n                                let opportunity = ArbitrageOpportunity {\n                                    id: uuid::Uuid::new_v4().to_string(),\n                                    pair: pair.clone(),\n                                    long_exchange: Some(long_exchange),\n                                    short_exchange: Some(short_exchange),\n                                    long_rate: Some(long_rate),\n                                    short_rate: Some(short_rate),\n                                    rate_difference: rate_diff,\n                                    net_rate_difference: Some(rate_diff), // Simplified for now\n                                    potential_profit_value: Some(rate_diff * 1000.0), // Estimate for $1000 position\n                                    timestamp: Utc::now().timestamp_millis() as u64,\n                                    r#type: ArbitrageType::FundingRate,\n                                    details: Some(format!(\n                                        \"Funding rate arbitrage: Long {} ({:.4}%) vs Short {} ({:.4}%)\",\n                                        long_exchange.as_str(),\n                                        long_rate * 100.0,\n                                        short_exchange.as_str(),\n                                        short_rate * 100.0\n                                    )),\n                                };\n\n                                // Calculate priority score (higher rate difference = higher priority)\n                                let priority_score = rate_diff * 1000.0; // Scale up for easier comparison\n\n                                // Create global opportunity\n                                let global_opportunity = GlobalOpportunity {\n                                    opportunity,\n                                    detection_timestamp: Utc::now().timestamp_millis() as u64,\n                                    expiry_timestamp: Utc::now().timestamp_millis() as u64 + (self.config.opportunity_ttl_minutes as u64 * 60 * 1000),\n                                    priority_score,\n                                    distributed_to: Vec::new(),\n                                    max_participants: Some(10), // Default limit\n                                    current_participants: 0,\n                                    distribution_strategy: self.config.distribution_strategy.clone(),\n                                    source: OpportunitySource::SystemGenerated,\n                                };\n\n                                new_opportunities.push(global_opportunity);\n\n                                log_info!(\"Detected new global opportunity\", serde_json::json!({\n                                    \"pair\": pair,\n                                    \"rate_difference\": rate_diff,\n                                    \"priority_score\": priority_score,\n                                    \"long_exchange\": long_exchange.as_str(),\n                                    \"short_exchange\": short_exchange.as_str()\n                                }));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        log_info!(\"Global opportunity detection completed\", serde_json::json!({\n            \"new_opportunities_count\": new_opportunities.len()\n        }));\n\n        Ok(new_opportunities)\n    }\n\n    /// Add new opportunities to the global queue\n    pub async fn add_opportunities_to_queue(\u0026mut self, opportunities: Vec\u003cGlobalOpportunity\u003e) -\u003e ArbitrageResult\u003c()\u003e {\n        let opportunities_count = opportunities.len(); // Store count before move\n        \n        // Extract the queue to avoid borrowing conflicts\n        if let Some(mut queue) = self.current_queue.take() {\n            // Add new opportunities\n            queue.opportunities.extend(opportunities);\n            \n            // Sort by priority score (highest first)\n            queue.opportunities.sort_by(|a, b| b.priority_score.partial_cmp(\u0026a.priority_score).unwrap_or(std::cmp::Ordering::Equal));\n            \n            // Limit queue size\n            if queue.opportunities.len() \u003e self.config.max_queue_size as usize {\n                queue.opportunities.truncate(self.config.max_queue_size as usize);\n            }\n            \n            // Remove expired opportunities\n            let now = Utc::now().timestamp_millis() as u64;\n            queue.opportunities.retain(|opp| opp.expiry_timestamp \u003e now);\n            \n            queue.updated_at = now;\n            \n            // Save the queue\n            self.save_queue(\u0026queue).await?;\n            \n            log_info!(\"Updated global opportunity queue\", serde_json::json!({\n                \"total_opportunities\": queue.opportunities.len(),\n                \"new_opportunities_added\": opportunities_count\n            }));\n            \n            // Put the queue back\n            self.current_queue = Some(queue);\n        }\n        \n        Ok(())\n    }\n\n    /// Distribute opportunities to eligible users using fairness algorithms\n    pub async fn distribute_opportunities(\u0026mut self) -\u003e ArbitrageResult\u003cVec\u003c(String, GlobalOpportunity)\u003e\u003e {\n        let mut distributions = Vec::new();\n        \n        // Extract the queue to avoid borrowing conflicts\n        if let Some(mut queue) = self.current_queue.take() {\n            // Load active users from KV store\n            let active_users = self.load_active_users().await?;\n            \n            // Load distribution tracking for all users\n            for user_id in \u0026active_users {\n                if !self.distribution_tracking.contains_key(user_id) {\n                    if let Ok(tracking) = self.load_user_distribution_tracking(user_id).await {\n                        self.distribution_tracking.insert(user_id.clone(), tracking);\n                    } else {\n                        // Create new tracking for user\n                        let new_tracking = UserOpportunityDistribution {\n                            user_id: user_id.clone(),\n                            last_opportunity_received: None,\n                            total_opportunities_received: 0,\n                            opportunities_today: 0,\n                            last_daily_reset: Utc::now().timestamp_millis() as u64,\n                            priority_weight: 1.0,\n                            is_eligible: true,\n                        };\n                        self.distribution_tracking.insert(user_id.clone(), new_tracking);\n                    }\n                }\n            }\n\n            // Apply fairness algorithm based on distribution strategy\n            match self.config.distribution_strategy {\n                DistributionStrategy::RoundRobin =\u003e {\n                    distributions = self.distribute_round_robin(\u0026active_users, \u0026mut queue).await?;\n                }\n                DistributionStrategy::FirstComeFirstServe =\u003e {\n                    distributions = self.distribute_first_come_first_serve(\u0026active_users, \u0026mut queue).await?;\n                }\n                DistributionStrategy::PriorityBased =\u003e {\n                    distributions = self.distribute_priority_based(\u0026active_users, \u0026mut queue).await?;\n                }\n                DistributionStrategy::Broadcast =\u003e {\n                    distributions = self.distribute_broadcast(\u0026active_users, \u0026mut queue).await?;\n                }\n            }\n\n            // Update distribution tracking\n            for (user_id, _) in \u0026distributions {\n                if let Some(tracking) = self.distribution_tracking.get_mut(user_id) {\n                    tracking.last_opportunity_received = Some(Utc::now().timestamp_millis() as u64);\n                    tracking.total_opportunities_received += 1;\n                    tracking.opportunities_today += 1;\n                    \n                    // Reset daily count if needed\n                    let now = Utc::now().timestamp_millis() as u64;\n                    let one_day_ms = 24 * 60 * 60 * 1000;\n                    if now - tracking.last_daily_reset \u003e one_day_ms {\n                        tracking.opportunities_today = 1;\n                        tracking.last_daily_reset = now;\n                    }\n                    \n                    // Clone to avoid borrowing issues\n                    let tracking_clone = tracking.clone();\n                    self.save_user_distribution_tracking(\u0026tracking_clone).await?;\n                }\n            }\n\n            queue.total_distributed += distributions.len() as u32;\n            \n            // Clone for saving\n            let queue_clone = queue.clone();\n            self.save_queue(\u0026queue_clone).await?;\n            \n            // Put the queue back\n            self.current_queue = Some(queue);\n        }\n\n        log_info!(\"Distributed opportunities\", serde_json::json!({\n            \"distributions_count\": distributions.len(),\n            \"strategy\": format!(\"{:?}\", self.config.distribution_strategy)\n        }));\n\n        Ok(distributions)\n    }\n\n    /// Round-robin distribution - fair rotation among users\n    async fn distribute_round_robin(\n        \u0026self,\n        active_users: \u0026[String],\n        queue: \u0026mut OpportunityQueue,\n    ) -\u003e ArbitrageResult\u003cVec\u003c(String, GlobalOpportunity)\u003e\u003e {\n        let mut distributions = Vec::new();\n        let mut user_index = 0;\n\n        for opportunity in queue.opportunities.iter_mut() {\n            if opportunity.distributed_to.len() \u003e= opportunity.max_participants.unwrap_or(10) as usize {\n                continue;\n            }\n\n            // Find next eligible user\n            let mut attempts = 0;\n            while attempts \u003c active_users.len() {\n                let user_id = \u0026active_users[user_index % active_users.len()];\n                \n                if self.is_user_eligible_for_opportunity(user_id, opportunity).await? {\n                    opportunity.distributed_to.push(user_id.clone());\n                    opportunity.current_participants += 1;\n                    distributions.push((user_id.clone(), opportunity.clone()));\n                    break;\n                }\n                \n                user_index = (user_index + 1) % active_users.len();\n                attempts += 1;\n            }\n            \n            user_index = (user_index + 1) % active_users.len();\n        }\n\n        Ok(distributions)\n    }\n\n    /// First-come-first-serve distribution\n    async fn distribute_first_come_first_serve(\n        \u0026self,\n        active_users: \u0026[String],\n        queue: \u0026mut OpportunityQueue,\n    ) -\u003e ArbitrageResult\u003cVec\u003c(String, GlobalOpportunity)\u003e\u003e {\n        let mut distributions = Vec::new();\n\n        for opportunity in queue.opportunities.iter_mut() {\n            if opportunity.distributed_to.len() \u003e= opportunity.max_participants.unwrap_or(10) as usize {\n                continue;\n            }\n\n            for user_id in active_users {\n                if opportunity.distributed_to.contains(user_id) {\n                    continue;\n                }\n\n                if self.is_user_eligible_for_opportunity(user_id, opportunity).await? {\n                    opportunity.distributed_to.push(user_id.clone());\n                    opportunity.current_participants += 1;\n                    distributions.push((user_id.clone(), opportunity.clone()));\n                    break;\n                }\n            }\n        }\n\n        Ok(distributions)\n    }\n\n    /// Priority-based distribution considering subscription tiers and activity\n    async fn distribute_priority_based(\n        \u0026self,\n        active_users: \u0026[String],\n        queue: \u0026mut OpportunityQueue,\n    ) -\u003e ArbitrageResult\u003cVec\u003c(String, GlobalOpportunity)\u003e\u003e {\n        let mut distributions = Vec::new();\n\n        // Calculate user priorities\n        let mut user_priorities: Vec\u003c(String, f64)\u003e = Vec::new();\n        \n        for user_id in active_users {\n            let priority = self.calculate_user_priority(user_id).await?;\n            user_priorities.push((user_id.clone(), priority));\n        }\n\n        // Sort by priority (highest first)\n        user_priorities.sort_by(|a, b| b.1.partial_cmp(\u0026a.1).unwrap_or(std::cmp::Ordering::Equal));\n\n        for opportunity in queue.opportunities.iter_mut() {\n            if opportunity.distributed_to.len() \u003e= opportunity.max_participants.unwrap_or(10) as usize {\n                continue;\n            }\n\n            for (user_id, _priority) in \u0026user_priorities {\n                if opportunity.distributed_to.contains(user_id) {\n                    continue;\n                }\n\n                if self.is_user_eligible_for_opportunity(user_id, opportunity).await? {\n                    opportunity.distributed_to.push(user_id.clone());\n                    opportunity.current_participants += 1;\n                    distributions.push((user_id.clone(), opportunity.clone()));\n                    break;\n                }\n            }\n        }\n\n        Ok(distributions)\n    }\n\n    /// Broadcast distribution - send to all eligible users\n    async fn distribute_broadcast(\n        \u0026self,\n        active_users: \u0026[String],\n        queue: \u0026mut OpportunityQueue,\n    ) -\u003e ArbitrageResult\u003cVec\u003c(String, GlobalOpportunity)\u003e\u003e {\n        let mut distributions = Vec::new();\n\n        for opportunity in queue.opportunities.iter_mut() {\n            for user_id in active_users {\n                if opportunity.distributed_to.contains(user_id) {\n                    continue;\n                }\n\n                if self.is_user_eligible_for_opportunity(user_id, opportunity).await? {\n                    opportunity.distributed_to.push(user_id.clone());\n                    opportunity.current_participants += 1;\n                    distributions.push((user_id.clone(), opportunity.clone()));\n                }\n            }\n        }\n\n        Ok(distributions)\n    }\n\n    /// Check if user is eligible to receive an opportunity\n    async fn is_user_eligible_for_opportunity(\n        \u0026self,\n        user_id: \u0026str,\n        _opportunity: \u0026GlobalOpportunity,\n    ) -\u003e ArbitrageResult\u003cbool\u003e {\n        // Check distribution tracking\n        if let Some(tracking) = self.distribution_tracking.get(user_id) {\n            if !tracking.is_eligible {\n                return Ok(false);\n            }\n\n            // Check daily limits\n            if tracking.opportunities_today \u003e= self.config.fairness_config.max_opportunities_per_user_per_day {\n                return Ok(false);\n            }\n\n            // Check cooldown period\n            if let Some(last_received) = tracking.last_opportunity_received {\n                let cooldown_ms = self.config.fairness_config.cooldown_period_minutes as u64 * 60 * 1000;\n                let now = Utc::now().timestamp_millis() as u64;\n                if now - last_received \u003c cooldown_ms {\n                    return Ok(false);\n                }\n            }\n        }\n\n        Ok(true)\n    }\n\n    /// Calculate user priority based on subscription tier and activity\n    async fn calculate_user_priority(\u0026self, user_id: \u0026str) -\u003e ArbitrageResult\u003cf64\u003e {\n        // Load user profile to get subscription tier\n        match self.user_profile_service.get_user_profile(user_id).await {\n            Ok(Some(profile)) =\u003e { // Handle Option\u003cUserProfile\u003e\n                let tier_name = match profile.subscription.tier {\n                    SubscriptionTier::Free =\u003e \"Free\",\n                    SubscriptionTier::Basic =\u003e \"Basic\",\n                    SubscriptionTier::Premium =\u003e \"Premium\",\n                    SubscriptionTier::Enterprise =\u003e \"Enterprise\",\n                };\n\n                let tier_multiplier = self.config.fairness_config.tier_multipliers\n                    .get(tier_name)\n                    .copied()\n                    .unwrap_or(1.0);\n\n                // Base priority with tier multiplier\n                let mut priority = tier_multiplier;\n\n                // Activity boost - check last active time\n                let now = Utc::now().timestamp_millis() as u64;\n                let one_hour_ms = 60 * 60 * 1000;\n                if now - profile.last_active \u003c one_hour_ms {\n                    priority *= self.config.fairness_config.activity_boost_factor;\n                }\n\n                Ok(priority)\n            }\n            Ok(None) =\u003e Ok(1.0), // No profile found, default priority\n            Err(_) =\u003e Ok(1.0), // Error loading profile, default priority\n        }\n    }\n\n    /// Get current queue status\n    pub fn get_queue_status(\u0026self) -\u003e Option\u003c\u0026OpportunityQueue\u003e {\n        self.current_queue.as_ref()\n    }\n\n    /// Update active users list\n    pub async fn update_active_users(\u0026self, user_ids: Vec\u003cString\u003e) -\u003e ArbitrageResult\u003c()\u003e {\n        let data = serde_json::to_string(\u0026user_ids)\n            .map_err(|e| ArbitrageError::serialization_error(format!(\"Failed to serialize active users: {}\", e)))?;\n        \n        self.kv_store\n            .put(Self::ACTIVE_USERS_KEY, data)?\n            .execute()\n            .await\n            .map_err(|e| ArbitrageError::database_error(format!(\"Failed to save active users: {}\", e)))?;\n        \n        Ok(())\n    }\n\n    // Storage operations\n    async fn load_queue(\u0026self) -\u003e ArbitrageResult\u003cOpportunityQueue\u003e {\n        let data = self.kv_store\n            .get(Self::OPPORTUNITY_QUEUE_KEY)\n            .text()\n            .await\n            .map_err(|e| ArbitrageError::database_error(format!(\"Failed to load opportunity queue: {}\", e)))?\n            .ok_or_else(|| ArbitrageError::not_found(\"Opportunity queue not found\".to_string()))?;\n\n        serde_json::from_str(\u0026data)\n            .map_err(|e| ArbitrageError::serialization_error(format!(\"Failed to deserialize opportunity queue: {}\", e)))\n    }\n\n    async fn save_queue(\u0026self, queue: \u0026OpportunityQueue) -\u003e ArbitrageResult\u003c()\u003e {\n        let data = serde_json::to_string(queue)\n            .map_err(|e| ArbitrageError::serialization_error(format!(\"Failed to serialize opportunity queue: {}\", e)))?;\n\n        self.kv_store\n            .put(Self::OPPORTUNITY_QUEUE_KEY, data)?\n            .execute()\n            .await\n            .map_err(|e| ArbitrageError::database_error(format!(\"Failed to save opportunity queue: {}\", e)))?;\n\n        Ok(())\n    }\n\n    async fn load_active_users(\u0026self) -\u003e ArbitrageResult\u003cVec\u003cString\u003e\u003e {\n        match self.kv_store.get(Self::ACTIVE_USERS_KEY).text().await {\n            Ok(Some(data)) =\u003e {\n                serde_json::from_str(\u0026data)\n                    .map_err(|e| ArbitrageError::serialization_error(format!(\"Failed to deserialize active users: {}\", e)))\n            }\n            Ok(None) =\u003e Ok(Vec::new()),\n            Err(e) =\u003e Err(ArbitrageError::database_error(format!(\"Failed to load active users: {}\", e))),\n        }\n    }\n\n    async fn load_user_distribution_tracking(\u0026self, user_id: \u0026str) -\u003e ArbitrageResult\u003cUserOpportunityDistribution\u003e {\n        let key = format!(\"{}:{}\", Self::DISTRIBUTION_TRACKING_PREFIX, user_id);\n        let data = self.kv_store\n            .get(\u0026key)\n            .text()\n            .await\n            .map_err(|e| ArbitrageError::database_error(format!(\"Failed to load user distribution tracking: {}\", e)))?\n            .ok_or_else(|| ArbitrageError::not_found(\"User distribution tracking not found\".to_string()))?;\n\n        serde_json::from_str(\u0026data)\n            .map_err(|e| ArbitrageError::serialization_error(format!(\"Failed to deserialize user distribution tracking: {}\", e)))\n    }\n\n    async fn save_user_distribution_tracking(\u0026self, tracking: \u0026UserOpportunityDistribution) -\u003e ArbitrageResult\u003c()\u003e {\n        let key = format!(\"{}:{}\", Self::DISTRIBUTION_TRACKING_PREFIX, tracking.user_id);\n        let data = serde_json::to_string(tracking)\n            .map_err(|e| ArbitrageError::serialization_error(format!(\"Failed to serialize user distribution tracking: {}\", e)))?;\n\n        self.kv_store\n            .put(\u0026key, data)?\n            .execute()\n            .await\n            .map_err(|e| ArbitrageError::database_error(format!(\"Failed to save user distribution tracking: {}\", e)))?;\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::SubscriptionInfo;\n    use std::collections::HashMap;\n    use uuid::Uuid;\n\n    // Mock structures for testing\n    struct MockKvStore {\n        data: std::sync::Arc\u003cstd::sync::Mutex\u003cHashMap\u003cString, String\u003e\u003e\u003e,\n    }\n\n    impl MockKvStore {\n        fn new() -\u003e Self {\n            Self {\n                data: std::sync::Arc::new(std::sync::Mutex::new(HashMap::new())),\n            }\n        }\n\n        fn with_data(mut self, key: \u0026str, value: \u0026str) -\u003e Self {\n            let mut data = self.data.lock().unwrap();\n            data.insert(key.to_string(), value.to_string());\n            drop(data);\n            self\n        }\n\n        async fn get(\u0026self, key: \u0026str) -\u003e Option\u003cString\u003e {\n            let data = self.data.lock().unwrap();\n            data.get(key).cloned()\n        }\n\n        async fn put(\u0026self, key: \u0026str, value: String) -\u003e Result\u003c(), String\u003e {\n            let mut data = self.data.lock().unwrap();\n            data.insert(key.to_string(), value);\n            Ok(())\n        }\n    }\n\n    fn create_test_config() -\u003e GlobalOpportunityConfig {\n        GlobalOpportunityConfig {\n            detection_interval_seconds: 30,\n            min_threshold: 0.001, // 0.1%\n            max_threshold: 0.02, // 2%\n            max_queue_size: 50,\n            opportunity_ttl_minutes: 10,\n            distribution_strategy: DistributionStrategy::RoundRobin,\n            fairness_config: FairnessConfig::default(),\n            monitored_exchanges: vec![ExchangeIdEnum::Binance, ExchangeIdEnum::Bybit],\n            monitored_pairs: vec![\"BTCUSDT\".to_string(), \"ETHUSDT\".to_string()],\n        }\n    }\n\n    fn create_test_opportunity() -\u003e GlobalOpportunity {\n        let opportunity = ArbitrageOpportunity {\n            id: Uuid::new_v4().to_string(),\n            pair: \"BTCUSDT\".to_string(),\n            long_exchange: Some(ExchangeIdEnum::Binance),\n            short_exchange: Some(ExchangeIdEnum::Bybit),\n            long_rate: Some(0.0005),\n            short_rate: Some(0.0015),\n            rate_difference: 0.001,\n            net_rate_difference: Some(0.001),\n            potential_profit_value: Some(1.0),\n            timestamp: Utc::now().timestamp_millis() as u64,\n            r#type: ArbitrageType::FundingRate,\n            details: Some(\"Test opportunity\".to_string()),\n        };\n\n        GlobalOpportunity {\n            opportunity,\n            detection_timestamp: Utc::now().timestamp_millis() as u64,\n            expiry_timestamp: Utc::now().timestamp_millis() as u64 + 600000, // 10 minutes\n            priority_score: 1.0,\n            distributed_to: Vec::new(),\n            max_participants: Some(5),\n            current_participants: 0,\n            distribution_strategy: DistributionStrategy::RoundRobin,\n            source: OpportunitySource::SystemGenerated,\n        }\n    }\n\n    fn create_test_user_profile(user_id: \u0026str, tier: SubscriptionTier) -\u003e UserProfile {\n        UserProfile {\n            user_id: user_id.to_string(),\n            telegram_user_id: 12345,\n            telegram_username: Some(\"testuser\".to_string()),\n            subscription: SubscriptionInfo {\n                tier,\n                is_active: true,\n                expires_at: None,\n                created_at: Utc::now().timestamp_millis() as u64,\n                features: vec![\"basic_features\".to_string()],\n            },\n            configuration: crate::types::UserConfiguration::default(),\n            api_keys: Vec::new(),\n            invitation_code: None,\n            created_at: Utc::now().timestamp_millis() as u64,\n            updated_at: Utc::now().timestamp_millis() as u64,\n            last_active: Utc::now().timestamp_millis() as u64,\n            is_active: true,\n            total_trades: 0,\n            total_pnl_usdt: 0.0,\n        }\n    }\n\n    #[tokio::test]\n    async fn test_global_opportunity_config_creation() {\n        let config = create_test_config();\n        \n        assert_eq!(config.detection_interval_seconds, 30);\n        assert_eq!(config.min_threshold, 0.001);\n        assert_eq!(config.max_threshold, 0.02);\n        assert_eq!(config.max_queue_size, 50);\n        assert_eq!(config.opportunity_ttl_minutes, 10);\n        assert!(matches!(config.distribution_strategy, DistributionStrategy::RoundRobin));\n        assert_eq!(config.monitored_exchanges.len(), 2);\n        assert_eq!(config.monitored_pairs.len(), 2);\n    }\n\n    #[tokio::test]\n    async fn test_global_opportunity_structure() {\n        let global_opp = create_test_opportunity();\n        \n        assert_eq!(global_opp.opportunity.pair, \"BTCUSDT\");\n        assert_eq!(global_opp.opportunity.rate_difference, 0.001);\n        assert_eq!(global_opp.priority_score, 1.0);\n        assert_eq!(global_opp.distributed_to.len(), 0);\n        assert_eq!(global_opp.max_participants, Some(5));\n        assert_eq!(global_opp.current_participants, 0);\n        assert!(matches!(global_opp.distribution_strategy, DistributionStrategy::RoundRobin));\n        assert!(matches!(global_opp.source, OpportunitySource::SystemGenerated));\n    }\n\n    #[tokio::test]\n    async fn test_opportunity_queue_management() {\n        let mut queue = OpportunityQueue {\n            id: Uuid::new_v4().to_string(),\n            opportunities: Vec::new(),\n            created_at: Utc::now().timestamp_millis() as u64,\n            updated_at: Utc::now().timestamp_millis() as u64,\n            total_distributed: 0,\n            active_users: vec![\"user1\".to_string(), \"user2\".to_string()],\n        };\n\n        // Test adding opportunities\n        let opp1 = create_test_opportunity();\n        let mut opp2 = create_test_opportunity();\n        opp2.priority_score = 2.0; // Higher priority\n\n        queue.opportunities.push(opp1);\n        queue.opportunities.push(opp2);\n\n        // Test sorting by priority\n        queue.opportunities.sort_by(|a, b| b.priority_score.partial_cmp(\u0026a.priority_score).unwrap_or(std::cmp::Ordering::Equal));\n        \n        assert_eq!(queue.opportunities.len(), 2);\n        assert_eq!(queue.opportunities[0].priority_score, 2.0); // Higher priority first\n        assert_eq!(queue.opportunities[1].priority_score, 1.0);\n        assert_eq!(queue.active_users.len(), 2);\n    }\n\n    #[tokio::test]\n    async fn test_user_distribution_tracking() {\n        let tracking = UserOpportunityDistribution {\n            user_id: \"test_user\".to_string(),\n            last_opportunity_received: Some(Utc::now().timestamp_millis() as u64),\n            total_opportunities_received: 5,\n            opportunities_today: 2,\n            last_daily_reset: Utc::now().timestamp_millis() as u64,\n            priority_weight: 1.5,\n            is_eligible: true,\n        };\n\n        assert_eq!(tracking.user_id, \"test_user\");\n        assert_eq!(tracking.total_opportunities_received, 5);\n        assert_eq!(tracking.opportunities_today, 2);\n        assert_eq!(tracking.priority_weight, 1.5);\n        assert!(tracking.is_eligible);\n        assert!(tracking.last_opportunity_received.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_fairness_config_defaults() {\n        let config = FairnessConfig::default();\n        \n        assert_eq!(config.rotation_interval_minutes, 15);\n        assert_eq!(config.max_opportunities_per_user_per_hour, 10);\n        assert_eq!(config.max_opportunities_per_user_per_day, 50);\n        assert_eq!(config.activity_boost_factor, 1.2);\n        assert_eq!(config.cooldown_period_minutes, 5);\n        \n        // Test tier multipliers\n        assert_eq!(config.tier_multipliers.get(\"Free\"), Some(\u00261.0));\n        assert_eq!(config.tier_multipliers.get(\"Basic\"), Some(\u00261.5));\n        assert_eq!(config.tier_multipliers.get(\"Premium\"), Some(\u00262.0));\n        assert_eq!(config.tier_multipliers.get(\"Enterprise\"), Some(\u00263.0));\n    }\n\n    #[tokio::test]\n    async fn test_distribution_strategies() {\n        // Test all distribution strategy variants\n        let strategies = vec![\n            DistributionStrategy::FirstComeFirstServe,\n            DistributionStrategy::RoundRobin,\n            DistributionStrategy::PriorityBased,\n            DistributionStrategy::Broadcast,\n        ];\n\n        for strategy in strategies {\n            match strategy {\n                DistributionStrategy::FirstComeFirstServe =\u003e {\n                    // Test first-come-first-serve logic\n                    assert!(true); // Placeholder for actual implementation test\n                }\n                DistributionStrategy::RoundRobin =\u003e {\n                    // Test round-robin logic\n                    assert!(true); // Placeholder for actual implementation test\n                }\n                DistributionStrategy::PriorityBased =\u003e {\n                    // Test priority-based logic\n                    assert!(true); // Placeholder for actual implementation test\n                }\n                DistributionStrategy::Broadcast =\u003e {\n                    // Test broadcast logic\n                    assert!(true); // Placeholder for actual implementation test\n                }\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_opportunity_source_types() {\n        let sources = vec![\n            OpportunitySource::SystemGenerated,\n            OpportunitySource::UserAI(\"user123\".to_string()),\n            OpportunitySource::External,\n        ];\n\n        for source in sources {\n            match source {\n                OpportunitySource::SystemGenerated =\u003e {\n                    assert!(true); // System-generated opportunities\n                }\n                OpportunitySource::UserAI(user_id) =\u003e {\n                    assert_eq!(user_id, \"user123\"); // User AI-generated\n                }\n                OpportunitySource::External =\u003e {\n                    assert!(true); // External source opportunities\n                }\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_opportunity_expiry_logic() {\n        let now = Utc::now().timestamp_millis() as u64;\n        \n        // Create expired opportunity\n        let mut expired_opp = create_test_opportunity();\n        expired_opp.expiry_timestamp = now - 1000; // 1 second ago\n        \n        // Create valid opportunity\n        let valid_opp = create_test_opportunity();\n        // expiry_timestamp is set in the future by create_test_opportunity()\n        \n        assert!(expired_opp.expiry_timestamp \u003c now);\n        assert!(valid_opp.expiry_timestamp \u003e now);\n        \n        // Test filtering logic\n        let opportunities = vec![expired_opp, valid_opp];\n        let valid_opportunities: Vec\u003c_\u003e = opportunities\n            .into_iter()\n            .filter(|opp| opp.expiry_timestamp \u003e now)\n            .collect();\n        \n        assert_eq!(valid_opportunities.len(), 1);\n    }\n\n    #[tokio::test]\n    async fn test_priority_score_calculation() {\n        let base_rate_diff = 0.001; // 0.1%\n        let priority_score = base_rate_diff * 1000.0; // Scale up\n        \n        assert_eq!(priority_score, 1.0);\n        \n        // Test higher rate difference\n        let higher_rate_diff = 0.005; // 0.5%\n        let higher_priority = higher_rate_diff * 1000.0;\n        \n        assert_eq!(higher_priority, 5.0);\n        assert!(higher_priority \u003e priority_score);\n    }\n\n    #[tokio::test]\n    async fn test_user_eligibility_checks() {\n        let config = FairnessConfig::default();\n        \n        // Test daily limit check\n        let mut tracking = UserOpportunityDistribution {\n            user_id: \"test_user\".to_string(),\n            last_opportunity_received: None,\n            total_opportunities_received: 0,\n            opportunities_today: config.max_opportunities_per_user_per_day,\n            last_daily_reset: Utc::now().timestamp_millis() as u64,\n            priority_weight: 1.0,\n            is_eligible: true,\n        };\n        \n        // User at daily limit should not be eligible\n        assert!(!tracking.is_eligible || tracking.opportunities_today \u003e= config.max_opportunities_per_user_per_day);\n        \n        // Test cooldown period\n        tracking.opportunities_today = 0;\n        tracking.last_opportunity_received = Some(Utc::now().timestamp_millis() as u64 - 1000); // 1 second ago\n        \n        let cooldown_ms = config.cooldown_period_minutes as u64 * 60 * 1000;\n        let time_since_last = 1000u64; // 1 second\n        \n        // Should not be eligible due to cooldown\n        assert!(time_since_last \u003c cooldown_ms);\n    }\n\n    #[tokio::test]\n    async fn test_subscription_tier_priority() {\n        let free_user = create_test_user_profile(\"user1\", SubscriptionTier::Free);\n        let premium_user = create_test_user_profile(\"user2\", SubscriptionTier::Premium);\n        \n        let config = FairnessConfig::default();\n        \n        let free_multiplier = config.tier_multipliers.get(\"Free\").copied().unwrap_or(1.0);\n        let premium_multiplier = config.tier_multipliers.get(\"Premium\").copied().unwrap_or(1.0);\n        \n        assert_eq!(free_multiplier, 1.0);\n        assert_eq!(premium_multiplier, 2.0);\n        assert!(premium_multiplier \u003e free_multiplier);\n    }\n\n    #[tokio::test]\n    async fn test_opportunity_participant_limits() {\n        let mut opportunity = create_test_opportunity();\n        opportunity.max_participants = Some(2);\n        \n        // Test adding participants\n        opportunity.distributed_to.push(\"user1\".to_string());\n        opportunity.current_participants += 1;\n        assert_eq!(opportunity.current_participants, 1);\n        assert!(opportunity.current_participants \u003c opportunity.max_participants.unwrap_or(10));\n        \n        // Add second participant\n        opportunity.distributed_to.push(\"user2\".to_string());\n        opportunity.current_participants += 1;\n        assert_eq!(opportunity.current_participants, 2);\n        assert_eq!(opportunity.current_participants, opportunity.max_participants.unwrap_or(10));\n        \n        // Check if at limit\n        assert_eq!(opportunity.distributed_to.len(), opportunity.max_participants.unwrap_or(10) as usize);\n    }\n\n    #[tokio::test]\n    async fn test_queue_size_limits() {\n        let config = create_test_config();\n        let mut opportunities = Vec::new();\n        \n        // Create more opportunities than max queue size\n        for i in 0..(config.max_queue_size + 10) {\n            let mut opp = create_test_opportunity();\n            opp.priority_score = i as f64; // Different priorities\n            opportunities.push(opp);\n        }\n        \n        // Sort by priority (highest first)\n        opportunities.sort_by(|a, b| b.priority_score.partial_cmp(\u0026a.priority_score).unwrap_or(std::cmp::Ordering::Equal));\n        \n        // Truncate to max size\n        if opportunities.len() \u003e config.max_queue_size as usize {\n            opportunities.truncate(config.max_queue_size as usize);\n        }\n        \n        assert_eq!(opportunities.len(), config.max_queue_size as usize);\n        \n        // Verify highest priority opportunities are kept\n        assert_eq!(opportunities[0].priority_score, (config.max_queue_size + 10 - 1) as f64);\n        assert_eq!(opportunities.last().unwrap().priority_score, 10.0);\n    }\n\n    #[tokio::test]\n    async fn test_activity_boost_calculation() {\n        let config = FairnessConfig::default();\n        let base_priority = 1.0;\n        \n        // Test with recent activity (within 1 hour)\n        let now = Utc::now().timestamp_millis() as u64;\n        let one_hour_ms = 60 * 60 * 1000;\n        let recent_activity = now - (one_hour_ms / 2); // 30 minutes ago\n        \n        let boosted_priority = if now - recent_activity \u003c one_hour_ms {\n            base_priority * config.activity_boost_factor\n        } else {\n            base_priority\n        };\n        \n        assert_eq!(boosted_priority, base_priority * 1.2);\n        \n        // Test with old activity (more than 1 hour)\n        let old_activity = now - (one_hour_ms * 2); // 2 hours ago\n        \n        let unboosted_priority = if now - old_activity \u003c one_hour_ms {\n            base_priority * config.activity_boost_factor\n        } else {\n            base_priority\n        };\n        \n        assert_eq!(unboosted_priority, base_priority);\n    }\n} ","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":305},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","services","mod.rs"],"content":"// src/services/mod.rs\n\npub mod exchange;\npub mod opportunity;\npub mod positions;\npub mod telegram;\npub mod user_profile;\npub mod global_opportunity;\npub mod ai_integration;\n\n// Re-export main service structs\npub use exchange::{ExchangeInterface, ExchangeService};\npub use opportunity::{OpportunityService, OpportunityServiceConfig};\npub use positions::{PositionsService, CreatePositionData, UpdatePositionData};\npub use telegram::{TelegramService, TelegramConfig};\npub use user_profile::UserProfileService;\npub use global_opportunity::GlobalOpportunityService;\npub use ai_integration::{AiIntegrationService, AiIntegrationConfig, AiProvider, AiAnalysisRequest, AiAnalysisResponse};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","services","opportunity.rs"],"content":"// src/services/opportunity.rs\n\nuse crate::log_error;\nuse crate::services::exchange::ExchangeService;\nuse crate::services::telegram::TelegramService;\nuse crate::types::{ArbitrageOpportunity, ArbitrageType, ExchangeIdEnum, FundingRateInfo, StructuredTradingPair};\nuse crate::utils::{ArbitrageError, ArbitrageResult};\nuse crate::services::exchange::ExchangeInterface;\nuse std::sync::Arc;\n\nuse futures::future::join_all;\nuse std::collections::HashMap;\n\n#[derive(Clone)]\npub struct OpportunityServiceConfig {\n    pub exchanges: Vec\u003cExchangeIdEnum\u003e,\n    pub monitored_pairs: Vec\u003cStructuredTradingPair\u003e,\n    pub threshold: f64,\n}\n\npub struct OpportunityService {\n    config: OpportunityServiceConfig,\n    exchange_service: Arc\u003cExchangeService\u003e,\n    telegram_service: Option\u003cArc\u003cTelegramService\u003e\u003e,\n}\n\nimpl OpportunityService {\n    pub fn new(\n        config: OpportunityServiceConfig,\n        exchange_service: Arc\u003cExchangeService\u003e,\n        telegram_service: Option\u003cArc\u003cTelegramService\u003e\u003e,\n    ) -\u003e Self {\n        Self {\n            config,\n            exchange_service,\n            telegram_service,\n        }\n    }\n\n    pub async fn find_opportunities(\n        \u0026self,\n        exchange_ids: \u0026[ExchangeIdEnum],\n        pairs: \u0026[String],\n        threshold: f64,\n    ) -\u003e ArbitrageResult\u003cVec\u003cArbitrageOpportunity\u003e\u003e {\n        let mut opportunities = Vec::new();\n\n        // Step 1: Fetch funding rates for all pairs and exchanges\n        let mut funding_rate_data: HashMap\u003c\n            String,\n            HashMap\u003cExchangeIdEnum, Option\u003cFundingRateInfo\u003e\u003e,\n        \u003e = HashMap::new();\n\n        // Initialize maps\n        for pair in pairs {\n            funding_rate_data.insert(pair.clone(), HashMap::new());\n        }\n\n        // Collect funding rate fetch operations\n        let mut funding_tasks = Vec::new();\n\n        for pair in pairs {\n            for exchange_id in exchange_ids {\n                let exchange_service = Arc::clone(\u0026self.exchange_service);\n                let pair = pair.clone();\n                let exchange_id = *exchange_id;\n\n                let task = Box::pin(async move {\n                    let result = exchange_service\n                        .fetch_funding_rates(\u0026exchange_id.to_string(), Some(\u0026pair))\n                        .await;\n                    \n                    // Parse the result to extract FundingRateInfo\n                    let funding_info = match result {\n                        Ok(rates) =\u003e {\n                            if let Some(rate_data) = rates.first() {\n                                // Extract funding rate from the response - handle parsing errors properly\n                                match rate_data[\"fundingRate\"].as_str() {\n                                    Some(rate_str) =\u003e {\n                                        match rate_str.parse::\u003cf64\u003e() {\n                                            Ok(funding_rate) =\u003e Some(FundingRateInfo {\n                                                symbol: pair.clone(),\n                                                funding_rate,\n                                                timestamp: Some(chrono::Utc::now()),\n                                                datetime: Some(chrono::Utc::now().to_rfc3339()),\n                                                next_funding_time: None,\n                                                estimated_rate: None,\n                                            }),\n                                            Err(parse_err) =\u003e {\n                                                log_error!(\"Failed to parse funding rate\", serde_json::json!({\n                                                    \"exchange\": exchange_id.to_string(),\n                                                    \"pair\": pair,\n                                                    \"raw_value\": rate_str,\n                                                    \"error\": parse_err.to_string()\n                                                }));\n                                                None\n                                            }\n                                        }\n                                    }\n                                    None =\u003e {\n                                        log_error!(\"Missing fundingRate field in response\", serde_json::json!({\n                                            \"exchange\": exchange_id.to_string(),\n                                            \"pair\": pair,\n                                            \"response\": rate_data\n                                        }));\n                                        None\n                                    }\n                                }\n                            } else {\n                                log_error!(\"Empty funding rates response\", serde_json::json!({\n                                    \"exchange\": exchange_id.to_string(),\n                                    \"pair\": pair\n                                }));\n                                None\n                            }\n                        }\n                        Err(fetch_err) =\u003e {\n                            log_error!(\"Failed to fetch funding rates\", serde_json::json!({\n                                \"exchange\": exchange_id.to_string(),\n                                \"pair\": pair,\n                                \"error\": fetch_err.to_string()\n                            }));\n                            None\n                        }\n                    };\n                    \n                    (pair, exchange_id, funding_info)\n                });\n                funding_tasks.push(task);\n            }\n        }\n\n        // Execute all funding rate fetch operations concurrently\n        let funding_results = join_all(funding_tasks).await;\n\n        // Process funding rate results\n        for (pair, exchange_id, funding_info) in funding_results {\n            if let Some(pair_map) = funding_rate_data.get_mut(\u0026pair) {\n                pair_map.insert(exchange_id, funding_info);\n            }\n        }\n\n        // Step 2: Identify opportunities\n        for pair in pairs {\n            if let Some(pair_funding_rates) = funding_rate_data.get(pair) {\n                let available_exchanges: Vec\u003cExchangeIdEnum\u003e = pair_funding_rates\n                    .iter()\n                    .filter_map(|(exchange_id, rate_info)| {\n                        if rate_info.is_some() {\n                            Some(*exchange_id)\n                        } else {\n                            None\n                        }\n                    })\n                    .collect();\n\n                if available_exchanges.len() \u003c 2 {\n                    continue;\n                }\n\n                // Compare all pairs of exchanges\n                for i in 0..available_exchanges.len() {\n                    for j in (i + 1)..available_exchanges.len() {\n                        let exchange_a = available_exchanges[i];\n                        let exchange_b = available_exchanges[j];\n\n                        if let (Some(Some(rate_a)), Some(Some(rate_b))) = (\n                            pair_funding_rates.get(\u0026exchange_a),\n                            pair_funding_rates.get(\u0026exchange_b),\n                        ) {\n                            let rate_diff = (rate_a.funding_rate - rate_b.funding_rate).abs();\n\n                            if rate_diff \u003e= threshold {\n                                // Determine which exchange to go long/short\n                                let (long_exchange, short_exchange, long_rate, short_rate) =\n                                    if rate_a.funding_rate \u003e rate_b.funding_rate {\n                                        (\n                                            exchange_b,\n                                            exchange_a,\n                                            rate_b.funding_rate,\n                                            rate_a.funding_rate,\n                                        )\n                                    } else {\n                                        (\n                                            exchange_a,\n                                            exchange_b,\n                                            rate_a.funding_rate,\n                                            rate_b.funding_rate,\n                                        )\n                                    };\n\n                                // For now, we'll set net difference same as rate difference\n                                // In a real implementation, you'd fetch trading fees and subtract them\n                                let net_difference = Some(rate_diff);\n\n                                // Create opportunity\n                                let opportunity = ArbitrageOpportunity {\n                                    id: uuid::Uuid::new_v4().to_string(),\n                                    pair: pair.clone(),\n                                    r#type: ArbitrageType::FundingRate,\n                                    long_exchange: Some(long_exchange),\n                                    short_exchange: Some(short_exchange),\n                                    long_rate: Some(long_rate),\n                                    short_rate: Some(short_rate),\n                                    rate_difference: rate_diff,\n                                    net_rate_difference: net_difference,\n                                    potential_profit_value: None, // Will be calculated if position size is known\n                                    timestamp: chrono::Utc::now().timestamp_millis() as u64,\n                                    details: Some(format!(\n                                        \"Funding rate arbitrage: Long {} ({}%) / Short {} ({}%)\",\n                                        long_exchange,\n                                        (long_rate * 100.0 * 10000.0).round() / 10000.0,\n                                        short_exchange,\n                                        (short_rate * 100.0 * 10000.0).round() / 10000.0\n                                    )),\n                                };\n\n                                opportunities.push(opportunity);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        Ok(opportunities)\n    }\n\n    pub async fn monitor_opportunities(\u0026self) -\u003e ArbitrageResult\u003cVec\u003cArbitrageOpportunity\u003e\u003e {\n        let pair_symbols: Vec\u003cString\u003e = self\n            .config\n            .monitored_pairs\n            .iter()\n            .map(|p| p.symbol.clone())\n            .collect();\n\n        self.find_opportunities(\u0026self.config.exchanges, \u0026pair_symbols, self.config.threshold)\n            .await\n    }\n\n    pub async fn process_opportunities(\n        \u0026self,\n        opportunities: \u0026[ArbitrageOpportunity],\n    ) -\u003e ArbitrageResult\u003c()\u003e {\n        if opportunities.is_empty() {\n            return Ok(());\n        }\n\n        // Send notifications if Telegram service is available\n        if let Some(telegram_service) = \u0026self.telegram_service {\n            for opportunity in opportunities {\n                if let Err(e) = telegram_service\n                    .send_opportunity_notification(opportunity)\n                    .await\n                {\n                    // Log error but don't fail the whole process\n                    log_error!(\"Failed to send Telegram notification\", serde_json::json!({\n                        \"error\": e.to_string(),\n                        \"opportunity_id\": opportunity.id,\n                        \"pair\": opportunity.pair\n                    }));\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    pub fn get_config(\u0026self) -\u003e \u0026OpportunityServiceConfig {\n        \u0026self.config\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":121},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","services","positions.rs"],"content":"// src/services/positions.rs\n\nuse crate::types::{ArbitragePosition, ExchangeIdEnum, PositionSide, PositionStatus};\nuse crate::utils::{ArbitrageError, ArbitrageResult};\nuse worker::kv::KvStore;\n\npub struct PositionsService {\n    kv_store: KvStore,\n}\n\nimpl PositionsService {\n    pub fn new(kv_store: KvStore) -\u003e Self {\n        Self { kv_store }\n    }\n\n    pub async fn create_position(\n        \u0026self,\n        position_data: CreatePositionData,\n    ) -\u003e ArbitrageResult\u003cArbitragePosition\u003e {\n        let id = uuid::Uuid::new_v4().to_string();\n        let now = chrono::Utc::now().timestamp_millis() as u64;\n\n        let position = ArbitragePosition {\n            id: id.clone(),\n            exchange: position_data.exchange,\n            pair: position_data.pair,\n            side: position_data.side,\n            size: position_data.size,\n            entry_price: position_data.entry_price,\n            current_price: None,\n            pnl: None,\n            status: PositionStatus::Open,\n            created_at: now,\n            updated_at: now,\n        };\n\n        // Store position\n        let key = format!(\"position:{}\", id);\n        let value = serde_json::to_string(\u0026position).map_err(|e| {\n            ArbitrageError::parse_error(format!(\"Failed to serialize position: {}\", e))\n        })?;\n\n        self.kv_store\n            .put(\u0026key, value)\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to store position: {}\", e))\n            })?\n            .execute()\n            .await\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to execute KV put: {}\", e))\n            })?;\n\n        // Update position index\n        self.add_to_position_index(\u0026id).await?;\n\n        Ok(position)\n    }\n\n    pub async fn get_position(\u0026self, id: \u0026str) -\u003e ArbitrageResult\u003cOption\u003cArbitragePosition\u003e\u003e {\n        let key = format!(\"position:{}\", id);\n\n        match self.kv_store.get(\u0026key).text().await {\n            Ok(Some(value)) =\u003e {\n                let position: ArbitragePosition = serde_json::from_str(\u0026value).map_err(|e| {\n                    ArbitrageError::parse_error(format!(\"Failed to deserialize position: {}\", e))\n                })?;\n                Ok(Some(position))\n            }\n            Ok(None) =\u003e Ok(None),\n            Err(e) =\u003e Err(ArbitrageError::database_error(format!(\n                \"Failed to get position: {}\",\n                e\n            ))),\n        }\n    }\n\n    pub async fn update_position(\n        \u0026self,\n        id: \u0026str,\n        update_data: UpdatePositionData,\n    ) -\u003e ArbitrageResult\u003cOption\u003cArbitragePosition\u003e\u003e {\n        let mut position = match self.get_position(id).await? {\n            Some(pos) =\u003e pos,\n            None =\u003e return Ok(None),\n        };\n\n        // Update fields if provided\n        if let Some(size) = update_data.size {\n            position.size = size;\n        }\n        if let Some(current_price) = update_data.current_price {\n            position.current_price = Some(current_price);\n        }\n        if let Some(pnl) = update_data.pnl {\n            position.pnl = Some(pnl);\n        }\n        if let Some(status) = update_data.status {\n            position.status = status;\n        }\n\n        position.updated_at = chrono::Utc::now().timestamp_millis() as u64;\n\n        // Store updated position\n        let key = format!(\"position:{}\", id);\n        let value = serde_json::to_string(\u0026position).map_err(|e| {\n            ArbitrageError::parse_error(format!(\"Failed to serialize position: {}\", e))\n        })?;\n\n        self.kv_store\n            .put(\u0026key, value)\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to store position: {}\", e))\n            })?\n            .execute()\n            .await\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to execute KV put: {}\", e))\n            })?;\n\n        Ok(Some(position))\n    }\n\n    pub async fn close_position(\u0026self, id: \u0026str) -\u003e ArbitrageResult\u003cbool\u003e {\n        let update_data = UpdatePositionData {\n            size: None,\n            current_price: None,\n            pnl: None,\n            status: Some(PositionStatus::Closed),\n        };\n\n        match self.update_position(id, update_data).await? {\n            Some(_) =\u003e Ok(true),\n            None =\u003e Ok(false),\n        }\n    }\n\n    pub async fn get_all_positions(\u0026self) -\u003e ArbitrageResult\u003cVec\u003cArbitragePosition\u003e\u003e {\n        // Get position IDs from index\n        let position_ids = self.get_position_index().await?;\n        let mut positions = Vec::new();\n\n        for id in position_ids {\n            if let Some(position) = self.get_position(\u0026id).await? {\n                positions.push(position);\n            }\n        }\n\n        Ok(positions)\n    }\n\n    pub async fn get_open_positions(\u0026self) -\u003e ArbitrageResult\u003cVec\u003cArbitragePosition\u003e\u003e {\n        let all_positions = self.get_all_positions().await?;\n        Ok(all_positions\n            .into_iter()\n            .filter(|pos| pos.status == PositionStatus::Open)\n            .collect())\n    }\n\n    pub async fn calculate_total_pnl(\u0026self) -\u003e ArbitrageResult\u003cf64\u003e {\n        let positions = self.get_open_positions().await?;\n        let total_pnl = positions.iter().filter_map(|pos| pos.pnl).sum();\n        Ok(total_pnl)\n    }\n\n    // Helper methods for position index management\n    async fn get_position_index(\u0026self) -\u003e ArbitrageResult\u003cVec\u003cString\u003e\u003e {\n        match self.kv_store.get(\"positions:index\").text().await {\n            Ok(Some(value)) =\u003e {\n                let ids: Vec\u003cString\u003e = serde_json::from_str(\u0026value).map_err(|e| {\n                    ArbitrageError::parse_error(format!(\"Failed to deserialize position index: {}\", e))\n                })?;\n                Ok(ids)\n            }\n            Ok(None) =\u003e Ok(Vec::new()),\n            Err(e) =\u003e Err(ArbitrageError::database_error(format!(\n                \"Failed to get position index: {}\",\n                e\n            ))),\n        }\n    }\n\n    async fn add_to_position_index(\u0026self, position_id: \u0026str) -\u003e ArbitrageResult\u003c()\u003e {\n        let mut index = self.get_position_index().await?;\n        if !index.contains(\u0026position_id.to_string()) {\n            index.push(position_id.to_string());\n            self.save_position_index(\u0026index).await?;\n        }\n        Ok(())\n    }\n\n    async fn remove_from_position_index(\u0026self, position_id: \u0026str) -\u003e ArbitrageResult\u003c()\u003e {\n        let mut index = self.get_position_index().await?;\n        index.retain(|id| id != position_id);\n        self.save_position_index(\u0026index).await?;\n        Ok(())\n    }\n\n    async fn save_position_index(\u0026self, index: \u0026[String]) -\u003e ArbitrageResult\u003c()\u003e {\n        let value = serde_json::to_string(index).map_err(|e| {\n            ArbitrageError::parse_error(format!(\"Failed to serialize position index: {}\", e))\n        })?;\n\n        self.kv_store\n            .put(\"positions:index\", value)\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to store position index: {}\", e))\n            })?\n            .execute()\n            .await\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to execute position index put: {}\", e))\n            })?;\n\n        Ok(())\n    }\n}\n\n// Helper structs for position operations\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct CreatePositionData {\n    pub exchange: ExchangeIdEnum,\n    pub pair: String,\n    pub side: PositionSide,\n    pub size: f64,\n    pub entry_price: f64,\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct UpdatePositionData {\n    pub size: Option\u003cf64\u003e,\n    pub current_price: Option\u003cf64\u003e,\n    pub pnl: Option\u003cf64\u003e,\n    pub status: Option\u003cPositionStatus\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::{ArbitragePosition, ExchangeIdEnum, ArbitrageType};\n    use serde_json::json;\n    use std::collections::HashMap;\n\n    // Mock KV storage for testing\n    #[derive(Debug, Clone)]\n    struct MockKvNamespace {\n        data: HashMap\u003cString, String\u003e,\n    }\n\n    impl MockKvNamespace {\n        fn new() -\u003e Self {\n            Self {\n                data: HashMap::new(),\n            }\n        }\n\n        fn with_data(mut self, key: \u0026str, value: \u0026str) -\u003e Self {\n            self.data.insert(key.to_string(), value.to_string());\n            self\n        }\n\n        async fn get(\u0026self, key: \u0026str) -\u003e Option\u003cString\u003e {\n            self.data.get(key).cloned()\n        }\n\n        async fn put(\u0026mut self, key: \u0026str, value: \u0026str) -\u003e Result\u003c(), String\u003e {\n            self.data.insert(key.to_string(), value.to_string());\n            Ok(())\n        }\n\n        async fn delete(\u0026mut self, key: \u0026str) -\u003e Result\u003c(), String\u003e {\n            self.data.remove(key);\n            Ok(())\n        }\n\n        async fn list_with_prefix(\u0026self, prefix: \u0026str) -\u003e Vec\u003cString\u003e {\n            self.data\n                .keys()\n                .filter(|k| k.starts_with(prefix))\n                .cloned()\n                .collect()\n        }\n    }\n\n    fn create_test_position(id: \u0026str, pair: \u0026str) -\u003e ArbitragePosition {\n        ArbitragePosition {\n            id: id.to_string(),\n            exchange: ExchangeIdEnum::Binance,\n            pair: pair.to_string(),\n            side: PositionSide::Long,\n            size: 1000.0,\n            entry_price: 45000.0,\n            current_price: Some(45100.0),\n            pnl: Some(15.5),\n            status: PositionStatus::Open,\n            created_at: chrono::Utc::now().timestamp_millis() as u64,\n            updated_at: chrono::Utc::now().timestamp_millis() as u64,\n        }\n    }\n\n    mod service_initialization {\n        use super::*;\n        use worker::kv::KvStore;\n\n        // Mock KV store for testing\n        fn create_mock_kv_store() -\u003e KvStore {\n            // This would normally be created from worker::Env in real usage\n            // For testing, we'll need to handle this differently\n            panic!(\"Mock KV store creation not implemented - this test needs actual Worker environment\")\n        }\n\n        #[test]\n        #[should_panic(expected = \"Mock KV store creation not implemented\")]\n        fn test_new_positions_service() {\n            let kv_store = create_mock_kv_store();\n            let service = PositionsService::new(kv_store);\n            \n            // Service should be created successfully\n            assert_eq!(std::mem::size_of_val(\u0026service), std::mem::size_of::\u003cPositionsService\u003e());\n        }\n\n        #[test]\n        fn test_positions_service_is_send_sync() {\n            fn assert_send\u003cT: Send\u003e() {}\n            fn assert_sync\u003cT: Sync\u003e() {}\n            \n            assert_send::\u003cPositionsService\u003e();\n            assert_sync::\u003cPositionsService\u003e();\n        }\n    }\n\n    mod position_data_validation {\n        use super::*;\n\n        #[test]\n        fn test_position_structure_creation() {\n            let position = create_test_position(\"test_001\", \"BTCUSDT\");\n            \n            assert_eq!(position.id, \"test_001\");\n            assert_eq!(position.pair, \"BTCUSDT\");\n            assert_eq!(position.size, 1000.0);\n            assert_eq!(position.entry_price, 45000.0);\n            assert_eq!(position.status, PositionStatus::Open);\n            assert_eq!(position.exchange, ExchangeIdEnum::Binance);\n            assert_eq!(position.side, PositionSide::Long);\n        }\n\n        #[test]\n        fn test_position_pnl_calculations() {\n            let position = create_test_position(\"test_002\", \"ETHUSDT\");\n            \n            // Test that PnL values are reasonable\n            assert!(position.pnl.unwrap() \u003e 0.0);\n            \n            // Test price data\n            assert!(position.entry_price \u003e 0.0);\n            assert!(position.current_price.unwrap() \u003e 0.0);\n        }\n\n        #[test]\n        fn test_position_exchange_assignment() {\n            let position = create_test_position(\"test_003\", \"ADAUSDT\");\n            \n            assert_eq!(position.exchange, ExchangeIdEnum::Binance);\n            assert_eq!(position.side, PositionSide::Long);\n        }\n\n        #[test]\n        fn test_position_timing_validation() {\n            let position = create_test_position(\"test_004\", \"SOLUSDT\");\n            \n            // Created at should be recent\n            let now = chrono::Utc::now().timestamp_millis() as u64;\n            assert!(position.created_at \u003c= now);\n            assert!(position.created_at \u003e now - 1000); // Within last second\n            \n            // Updated at should be recent\n            assert!(position.updated_at \u003c= now);\n            assert!(position.updated_at \u003e now - 1000);\n        }\n    }\n\n    mod kv_storage_operations {\n        use super::*;\n\n        #[test]\n        fn test_position_key_generation() {\n            let position_id = \"test_pos_001\";\n            \n            let key = format!(\"position:{}\", position_id);\n            assert_eq!(key, \"position:test_pos_001\");\n        }\n\n        #[test]\n        fn test_index_key_generation() {\n            let key = \"positions:index\";\n            assert_eq!(key, \"positions:index\");\n        }\n\n        #[test]\n        fn test_position_serialization() {\n            let position = create_test_position(\"ser_test\", \"BTCUSDT\");\n            \n            // Test that position can be serialized to JSON\n            let json_result = serde_json::to_string(\u0026position);\n            assert!(json_result.is_ok());\n            \n            let json_str = json_result.unwrap();\n            assert!(json_str.contains(\"ser_test\"));\n            assert!(json_str.contains(\"BTCUSDT\"));\n            assert!(json_str.contains(\"open\")); // Status is serialized as lowercase due to serde rename_all\n        }\n\n        #[test]\n        fn test_position_deserialization() {\n            let position = create_test_position(\"deser_test\", \"ETHUSDT\");\n            \n            // Serialize then deserialize\n            let json_str = serde_json::to_string(\u0026position).unwrap();\n            let deserialized: Result\u003cArbitragePosition, _\u003e = serde_json::from_str(\u0026json_str);\n            \n            assert!(deserialized.is_ok());\n            let deser_position = deserialized.unwrap();\n            \n            assert_eq!(deser_position.id, position.id);\n            assert_eq!(deser_position.pair, position.pair);\n            assert_eq!(deser_position.size, position.size);\n            assert_eq!(deser_position.status, position.status);\n        }\n    }\n\n    mod error_handling {\n        use super::*;\n\n        #[test]\n        fn test_invalid_position_id_handling() {\n            // Test with empty position ID\n            let empty_id = \"\";\n            assert!(empty_id.is_empty());\n            \n            // Test with invalid UUID format\n            let invalid_uuid = \"not-a-uuid\";\n            assert!(!invalid_uuid.contains('-') || invalid_uuid.len() \u003c 36);\n        }\n\n        #[test]\n        fn test_json_parsing_errors() {\n            // Test invalid JSON\n            let invalid_json = r#\"{\"id\": \"test\", \"pair\": }\"#;\n            let result: Result\u003cArbitragePosition, _\u003e = serde_json::from_str(invalid_json);\n            assert!(result.is_err());\n            \n            // Test missing required fields\n            let incomplete_json = r#\"{\"id\": \"test\"}\"#;\n            let result: Result\u003cArbitragePosition, _\u003e = serde_json::from_str(incomplete_json);\n            assert!(result.is_err());\n        }\n\n        #[test]\n        fn test_position_validation_edge_cases() {\n            let mut position = create_test_position(\"edge_test\", \"BTCUSDT\");\n            \n            // Test with zero position size\n            position.size = 0.0;\n            assert_eq!(position.size, 0.0);\n            \n            // Test with negative entry price (should be handled by business logic)\n            position.entry_price = -10.0;\n            assert!(position.entry_price \u003c 0.0);\n            \n            // Test with very large numbers\n            position.size = f64::MAX / 2.0;\n            assert!(position.size \u003e 1e100);\n        }\n    }\n\n    mod business_logic {\n        use super::*;\n\n        #[test]\n        fn test_position_status_transitions() {\n            let mut position = create_test_position(\"status_test\", \"BTCUSDT\");\n            \n            // Initial status should be open\n            assert_eq!(position.status, PositionStatus::Open);\n            \n            // Simulate status change\n            position.status = PositionStatus::Closed;\n            position.updated_at = chrono::Utc::now().timestamp_millis() as u64;\n            \n            assert_eq!(position.status, PositionStatus::Closed);\n        }\n\n        #[test]\n        fn test_pnl_calculation_logic() {\n            let position = create_test_position(\"pnl_test\", \"ETHUSDT\");\n            \n            // Test that PnL calculation inputs are present\n            assert!(position.entry_price \u003e 0.0);\n            assert!(position.current_price.is_some());\n            assert!(position.size \u003e 0.0);\n            \n            // Simulate PnL calculation\n            let entry_price = position.entry_price;\n            let current_price = position.current_price.unwrap();\n            let size = position.size;\n            \n            let calculated_pnl = if position.side == PositionSide::Long {\n                (current_price - entry_price) * size\n            } else {\n                (entry_price - current_price) * size\n            };\n            \n            // Should be able to calculate PnL\n            assert!(calculated_pnl.is_finite());\n        }\n\n        #[test]\n        fn test_position_side_logic() {\n            let long_position = create_test_position(\"long_test\", \"BTCUSDT\");\n            assert_eq!(long_position.side, PositionSide::Long);\n            \n            let mut short_position = create_test_position(\"short_test\", \"ETHUSDT\");\n            short_position.side = PositionSide::Short;\n            assert_eq!(short_position.side, PositionSide::Short);\n        }\n\n        #[test]\n        fn test_exchange_assignment() {\n            let position = create_test_position(\"exchange_test\", \"ADAUSDT\");\n            assert_eq!(position.exchange, ExchangeIdEnum::Binance);\n            \n            let mut bybit_position = create_test_position(\"bybit_test\", \"SOLUSDT\");\n            bybit_position.exchange = ExchangeIdEnum::Bybit;\n            assert_eq!(bybit_position.exchange, ExchangeIdEnum::Bybit);\n        }\n\n        #[test]\n        fn test_risk_metrics_calculation() {\n            let position = create_test_position(\"risk_test\", \"BTCUSDT\");\n            \n            // Calculate percentage return\n            let pnl = position.pnl.unwrap();\n            let notional_value = position.entry_price * position.size;\n            let return_percentage = (pnl / notional_value) * 100.0;\n            \n            assert!(return_percentage.is_finite());\n            assert!(return_percentage \u003e -100.0); // Reasonable bounds\n        }\n\n        #[test]\n        fn test_position_lifecycle_timing() {\n            let position = create_test_position(\"lifecycle_test\", \"ETHUSDT\");\n            \n            let created_at = position.created_at;\n            let updated_at = position.updated_at;\n            let now = chrono::Utc::now().timestamp_millis() as u64;\n            \n            // Created at should be in the past or present\n            assert!(created_at \u003c= now);\n            \n            // Updated at should be \u003e= created at\n            assert!(updated_at \u003e= created_at);\n        }\n    }\n\n    mod service_methods {\n        use super::*;\n\n        #[test]\n        fn test_create_position_data_structure() {\n            let create_data = CreatePositionData {\n                exchange: ExchangeIdEnum::Binance,\n                pair: \"BTCUSDT\".to_string(),\n                side: PositionSide::Long,\n                size: 1000.0,\n                entry_price: 45000.0,\n            };\n            \n            assert_eq!(create_data.exchange, ExchangeIdEnum::Binance);\n            assert_eq!(create_data.pair, \"BTCUSDT\");\n            assert_eq!(create_data.side, PositionSide::Long);\n            assert_eq!(create_data.size, 1000.0);\n            assert_eq!(create_data.entry_price, 45000.0);\n        }\n\n        #[test]\n        fn test_update_position_data_structure() {\n            let update_data = UpdatePositionData {\n                size: Some(1500.0),\n                current_price: Some(45200.0),\n                pnl: Some(25.5),\n                status: Some(PositionStatus::Open),\n            };\n            \n            assert_eq!(update_data.size, Some(1500.0));\n            assert_eq!(update_data.current_price, Some(45200.0));\n            assert_eq!(update_data.pnl, Some(25.5));\n            assert_eq!(update_data.status, Some(PositionStatus::Open));\n        }\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":111},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","services","telegram.rs"],"content":"// src/services/telegram.rs\n\nuse crate::types::ArbitrageOpportunity;\nuse crate::utils::{ArbitrageError, ArbitrageResult};\nuse crate::utils::formatter::{format_opportunity_message, escape_markdown_v2};\nuse chrono::Utc;\nuse reqwest::Client;\nuse serde_json::{json, Value};\n\n#[derive(Clone)]\npub struct TelegramConfig {\n    pub bot_token: String,\n    pub chat_id: String,\n}\n\npub struct TelegramService {\n    config: TelegramConfig,\n    http_client: Client,\n}\n\nimpl TelegramService {\n    pub fn new(config: TelegramConfig) -\u003e Self {\n        Self {\n            config,\n            http_client: Client::new(),\n        }\n    }\n\n    pub async fn send_message(\u0026self, text: \u0026str) -\u003e ArbitrageResult\u003c()\u003e {\n        let url = format!(\"https://api.telegram.org/bot{}/sendMessage\", self.config.bot_token);\n        \n        let payload = json!({\n            \"chat_id\": self.config.chat_id,\n            \"text\": text,\n            \"parse_mode\": \"MarkdownV2\"\n        });\n\n        let response = self.http_client\n            .post(\u0026url)\n            .json(\u0026payload)\n            .send()\n            .await\n            .map_err(|e| ArbitrageError::network_error(format!(\"Failed to send Telegram message: {}\", e)))?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_default();\n            return Err(ArbitrageError::telegram_error(format!(\"Telegram API error: {}\", error_text)));\n        }\n\n        let result: Value = response.json().await\n            .map_err(|e| ArbitrageError::parse_error(format!(\"Failed to parse Telegram response: {}\", e)))?;\n\n        if !result[\"ok\"].as_bool().unwrap_or(false) {\n            let error_description = result[\"description\"].as_str().unwrap_or(\"Unknown error\");\n            return Err(ArbitrageError::telegram_error(format!(\"Telegram API error: {}\", error_description)));\n        }\n\n        Ok(())\n    }\n\n    pub async fn send_opportunity_notification(\u0026self, opportunity: \u0026ArbitrageOpportunity) -\u003e ArbitrageResult\u003c()\u003e {\n        let message = format_opportunity_message(opportunity);\n        self.send_message(\u0026message).await\n    }\n\n    // Bot command handlers (for webhook mode)\n    pub async fn handle_webhook(\u0026self, update: Value) -\u003e ArbitrageResult\u003cOption\u003cString\u003e\u003e {\n        if let Some(message) = update[\"message\"].as_object() {\n            if let Some(text) = message[\"text\"].as_str() {\n                return self.handle_command(text).await;\n            }\n        }\n        Ok(None)\n    }\n\n    async fn handle_command(\u0026self, text: \u0026str) -\u003e ArbitrageResult\u003cOption\u003cString\u003e\u003e {\n        match text {\n            \"/start\" =\u003e Ok(Some(\n                \"Welcome to the Arbitrage Bot!\\n\\\n                I can help you detect funding rate arbitrage opportunities and notify you about them.\\n\\n\\\n                Here are the available commands:\\n\\\n                /help - Show this help message and list all commands.\\n\\\n                /status - Check the bot's current operational status.\\n\\\n                /opportunities - Show recent arbitrage opportunities (currently placeholder).\\n\\\n                /settings - View current bot settings (currently placeholder).\\n\\n\\\n                Use /help to see this list again.\".to_string()\n            )),\n            \"/help\" =\u003e Ok(Some(\n                \"Available commands:\\n\\\n                /help - Show this help message\\n\\\n                /status - Check bot status\\n\\\n                /opportunities - Show recent opportunities\\n\\\n                /settings - View current settings\".to_string()\n            )),\n            \"/status\" =\u003e {\n                let now = chrono::Utc::now().format(\"%Y-%m-%d %H:%M:%S UTC\");\n                Ok(Some(format!(\n                    \"Bot is active and monitoring for arbitrage opportunities.\\nCurrent time: {}\",\n                    now\n                )))\n            }\n            \"/opportunities\" =\u003e Ok(Some(\n                \"No recent opportunities found. Will notify you when new ones are detected.\".to_string()\n            )),\n            \"/settings\" =\u003e Ok(Some(\n                \"Current settings:\\n\\\n                Threshold: 0.001 (0.1%)\\n\\\n                Pairs monitored: BTC/USDT, ETH/USDT\\n\\\n                Exchanges: Binance, Bybit, OKX\".to_string()\n            )),\n            _ =\u003e Ok(None), // Unknown command, no response\n        }\n    }\n\n    pub async fn set_webhook(\u0026self, webhook_url: \u0026str) -\u003e ArbitrageResult\u003c()\u003e {\n        let url = format!(\"https://api.telegram.org/bot{}/setWebhook\", self.config.bot_token);\n        \n        let payload = json!({\n            \"url\": webhook_url\n        });\n\n        let response = self.http_client\n            .post(\u0026url)\n            .json(\u0026payload)\n            .send()\n            .await\n            .map_err(|e| ArbitrageError::network_error(format!(\"Failed to set webhook: {}\", e)))?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_default();\n            return Err(ArbitrageError::telegram_error(format!(\"Failed to set webhook: {}\", error_text)));\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::{ArbitrageOpportunity, ArbitrageType, ExchangeIdEnum};\n    use serde_json::json;\n    use chrono::Datelike; // Import for year(), month(), day() methods\n\n    fn create_test_config() -\u003e TelegramConfig {\n        TelegramConfig {\n            bot_token: \"test_token_123456789:ABCDEF\".to_string(),\n            chat_id: \"-123456789\".to_string(),\n        }\n    }\n\n    fn create_test_opportunity() -\u003e ArbitrageOpportunity {\n        ArbitrageOpportunity {\n            id: \"test_opp_001\".to_string(),\n            pair: \"BTCUSDT\".to_string(),\n            r#type: ArbitrageType::FundingRate,\n            long_exchange: Some(ExchangeIdEnum::Binance),\n            short_exchange: Some(ExchangeIdEnum::Bybit),\n            long_rate: Some(0.001),\n            short_rate: Some(0.003),\n            rate_difference: 0.002,\n            net_rate_difference: Some(0.0018),\n            potential_profit_value: Some(18.0),\n            timestamp: 1640995200000, // Jan 1, 2022\n            details: Some(\"Test funding rate arbitrage opportunity\".to_string()),\n        }\n    }\n\n    mod service_initialization {\n        use super::*;\n\n        #[test]\n        fn test_new_telegram_service() {\n            let config = create_test_config();\n            let service = TelegramService::new(config.clone());\n            \n            // Service should be created successfully\n            assert_eq!(std::mem::size_of_val(\u0026service), std::mem::size_of::\u003cTelegramService\u003e());\n        }\n\n        #[test]\n        fn test_telegram_service_is_send_sync() {\n            fn assert_send\u003cT: Send\u003e() {}\n            fn assert_sync\u003cT: Sync\u003e() {}\n            \n            assert_send::\u003cTelegramService\u003e();\n            assert_sync::\u003cTelegramService\u003e();\n        }\n\n        #[test]\n        fn test_config_validation_valid() {\n            let config = create_test_config();\n            \n            assert!(!config.bot_token.is_empty());\n            assert!(!config.chat_id.is_empty());\n        }\n\n        #[test]\n        fn test_config_basic_structure() {\n            let config = create_test_config();\n            \n            let service = TelegramService::new(config);\n            // Service should be created successfully\n            assert_eq!(std::mem::size_of_val(\u0026service), std::mem::size_of::\u003cTelegramService\u003e());\n        }\n\n        #[test]\n        fn test_disabled_service_handling() {\n            let config = create_test_config();\n            \n            let service = TelegramService::new(config);\n            // Service should be created (enabling/disabling would be handled at application level)\n            assert_eq!(std::mem::size_of_val(\u0026service), std::mem::size_of::\u003cTelegramService\u003e());\n        }\n    }\n\n    mod configuration_validation {\n        use super::*;\n\n        #[test]\n        fn test_bot_token_format() {\n            let config = create_test_config();\n            \n            // Bot token should contain colon\n            assert!(config.bot_token.contains(':'));\n            \n            // Should have reasonable length\n            assert!(config.bot_token.len() \u003e 10);\n        }\n\n        #[test]\n        fn test_chat_id_format() {\n            let config = create_test_config();\n            \n            // Chat ID should be negative for groups\n            assert!(config.chat_id.starts_with('-'));\n            \n            // Should be numeric after the dash\n            let numeric_part = \u0026config.chat_id[1..];\n            assert!(numeric_part.parse::\u003ci64\u003e().is_ok());\n        }\n\n        #[test]\n        fn test_webhook_url_validation() {\n            let config = create_test_config();\n            \n            // Test webhook URL format validation (separate from config)\n            let webhook_url = \"https://example.com/webhook\";\n            assert!(webhook_url.starts_with(\"https://\"));\n            assert!(webhook_url.len() \u003e 10);\n        }\n\n        #[test]\n        fn test_optional_webhook() {\n            let config = create_test_config();\n            \n            let service = TelegramService::new(config);\n            // Should work without webhook URL (webhook is set separately)\n            assert_eq!(std::mem::size_of_val(\u0026service), std::mem::size_of::\u003cTelegramService\u003e());\n        }\n    }\n\n    mod message_formatting {\n        use super::*;\n\n        #[test]\n        fn test_escape_markdown_v2_basic() {\n            let input = \"Hello World!\";\n            let escaped = escape_markdown_v2(input);\n            \n            // Should escape exclamation mark since it's a special MarkdownV2 character\n            assert_eq!(escaped, \"Hello World\\\\!\");\n        }\n\n        #[test]\n        fn test_escape_markdown_v2_special_chars() {\n            let input = \"Price: $1,234.56 (10% gain)\";\n            let escaped = escape_markdown_v2(input);\n            \n            // Should escape special characters that are in the escape list\n            // Note: $ is not a special character in MarkdownV2, so it won't be escaped\n            assert!(escaped.contains(\"\\\\(\"));\n            assert!(escaped.contains(\"\\\\)\"));\n            assert!(escaped.contains(\"\\\\.\"));\n            // $ remains unescaped as it's not a special MarkdownV2 character\n            assert!(escaped.contains(\"$\"));\n        }\n\n        #[test]\n        fn test_escape_markdown_v2_comprehensive() {\n            let input = \"_*[]()~`\u003e#+-=|{}.!\";\n            let escaped = escape_markdown_v2(input);\n            \n            // All special characters should be escaped\n            assert!(escaped.contains(\"\\\\_\"));\n            assert!(escaped.contains(\"\\\\*\"));\n            assert!(escaped.contains(\"\\\\[\"));\n            assert!(escaped.contains(\"\\\\]\"));\n            assert!(escaped.contains(\"\\\\(\"));\n            assert!(escaped.contains(\"\\\\)\"));\n            assert!(escaped.contains(\"\\\\~\"));\n            assert!(escaped.contains(\"\\\\`\"));\n            assert!(escaped.contains(\"\\\\\u003e\"));\n            assert!(escaped.contains(\"\\\\#\"));\n            assert!(escaped.contains(\"\\\\+\"));\n            assert!(escaped.contains(\"\\\\-\"));\n            assert!(escaped.contains(\"\\\\=\"));\n            assert!(escaped.contains(\"\\\\|\"));\n            assert!(escaped.contains(\"\\\\{\"));\n            assert!(escaped.contains(\"\\\\}\"));\n            assert!(escaped.contains(\"\\\\.\"));\n            assert!(escaped.contains(\"\\\\!\"));\n        }\n\n        #[test]\n        fn test_format_percentage() {\n            let rate = 0.001; // 0.1%\n            \n            // Should format as percentage with basis points\n            let formatted_100 = format!(\"{:.2}%\", rate * 100.0);\n            assert_eq!(formatted_100, \"0.10%\");\n            \n            let formatted_10000 = format!(\"{:.1} bps\", rate * 10000.0);\n            assert_eq!(formatted_10000, \"10.0 bps\");\n        }\n\n        #[test]\n        fn test_opportunity_message_components() {\n            let opportunity = create_test_opportunity();\n            \n            // Test individual message components\n            assert_eq!(opportunity.pair, \"BTCUSDT\");\n            assert_eq!(opportunity.rate_difference, 0.002);\n            assert!(opportunity.long_exchange.is_some());\n            assert!(opportunity.short_exchange.is_some());\n            assert!(opportunity.potential_profit_value.is_some());\n        }\n    }\n\n    mod opportunity_notifications {\n        use super::*;\n\n        #[test]\n        fn test_opportunity_data_extraction() {\n            let opportunity = create_test_opportunity();\n            \n            // Verify all required data is present\n            assert!(!opportunity.id.is_empty());\n            assert!(!opportunity.pair.is_empty());\n            assert!(opportunity.rate_difference \u003e 0.0);\n            \n            // Exchange data\n            let long_exchange = opportunity.long_exchange.unwrap();\n            let short_exchange = opportunity.short_exchange.unwrap();\n            assert_ne!(long_exchange, short_exchange);\n            \n            // Rate data\n            let long_rate = opportunity.long_rate.unwrap();\n            let short_rate = opportunity.short_rate.unwrap();\n            assert_ne!(long_rate, short_rate);\n        }\n\n        #[test]\n        fn test_profit_calculation_data() {\n            let opportunity = create_test_opportunity();\n            \n            if let Some(profit) = opportunity.potential_profit_value {\n                assert!(profit \u003e 0.0);\n                assert!(profit.is_finite());\n            }\n            \n            if let Some(net_diff) = opportunity.net_rate_difference {\n                assert!(net_diff \u003e 0.0);\n                assert!(net_diff \u003c= opportunity.rate_difference);\n            }\n        }\n\n        #[test]\n        fn test_message_timestamp_handling() {\n            let opportunity = create_test_opportunity();\n            \n            // Timestamp should be valid\n            assert!(opportunity.timestamp \u003e 0);\n            \n            // Should be reasonable (after year 2020, before year 2030)\n            let min_timestamp = 1577836800000u64; // Jan 1, 2020\n            let max_timestamp = 1893456000000u64; // Jan 1, 2030\n            \n            assert!(opportunity.timestamp \u003e min_timestamp);\n            assert!(opportunity.timestamp \u003c max_timestamp);\n        }\n\n        #[test]\n        fn test_opportunity_type_validation() {\n            let opportunity = create_test_opportunity();\n            \n            assert_eq!(opportunity.r#type, ArbitrageType::FundingRate);\n        }\n    }\n\n    mod error_handling {\n        use super::*;\n\n        #[test]\n        fn test_invalid_config_handling() {\n            // Empty bot token\n            let mut config = create_test_config();\n            config.bot_token = String::new();\n            \n            // Service should still be created but might fail on API calls\n            let service = TelegramService::new(config);\n            assert_eq!(std::mem::size_of_val(\u0026service), std::mem::size_of::\u003cTelegramService\u003e());\n        }\n\n        #[test]\n        fn test_malformed_chat_id() {\n            let mut config = create_test_config();\n            config.chat_id = \"not_a_number\".to_string();\n            \n            // Service creation should work, validation happens at runtime\n            let service = TelegramService::new(config);\n            assert_eq!(std::mem::size_of_val(\u0026service), std::mem::size_of::\u003cTelegramService\u003e());\n        }\n\n        #[test]\n        fn test_disabled_service_handling() {\n            let config = create_test_config();\n            \n            let service = TelegramService::new(config);\n            // Service should be created (enabling/disabling would be handled at application level)\n            assert_eq!(std::mem::size_of_val(\u0026service), std::mem::size_of::\u003cTelegramService\u003e());\n        }\n\n        #[test]\n        fn test_empty_opportunity_data() {\n            let mut opportunity = create_test_opportunity();\n            opportunity.id = String::new();\n            opportunity.pair = String::new();\n            \n            // Should handle empty data gracefully\n            assert!(opportunity.id.is_empty());\n            assert!(opportunity.pair.is_empty());\n        }\n    }\n\n    mod api_interaction {\n        use super::*;\n\n        #[test]\n        fn test_telegram_api_url_construction() {\n            let config = create_test_config();\n            let service = TelegramService::new(config.clone());\n            \n            // Construct expected API URL\n            let expected_base = format!(\"https://api.telegram.org/bot{}\", config.bot_token);\n            assert!(expected_base.contains(\"test_token_123456789\"));\n            assert!(expected_base.contains(\"api.telegram.org\"));\n        }\n\n        #[test]\n        fn test_webhook_url_validation() {\n            let config = create_test_config();\n            \n            // Test webhook URL format validation (separate from config)\n            let webhook_url = \"https://example.com/webhook\";\n            assert!(webhook_url.starts_with(\"https://\"));\n            assert!(webhook_url.len() \u003e 10);\n        }\n\n        #[test]\n        fn test_message_payload_structure() {\n            let config = create_test_config();\n            let opportunity = create_test_opportunity();\n            \n            // Simulate message payload construction\n            let payload = json!({\n                \"chat_id\": config.chat_id,\n                \"text\": \"Test message\",\n                \"parse_mode\": \"MarkdownV2\"\n            });\n            \n            assert_eq!(payload[\"chat_id\"], config.chat_id);\n            assert_eq!(payload[\"parse_mode\"], \"MarkdownV2\");\n            assert!(payload[\"text\"].is_string());\n        }\n    }\n\n    mod webhook_handling {\n        use super::*;\n\n        #[test]\n        fn test_webhook_data_structure() {\n            // Simulate incoming webhook data\n            let webhook_data = json!({\n                \"update_id\": 123456789,\n                \"message\": {\n                    \"message_id\": 1,\n                    \"from\": {\n                        \"id\": 987654321,\n                        \"is_bot\": false,\n                        \"first_name\": \"Test\",\n                        \"username\": \"testuser\"\n                    },\n                    \"chat\": {\n                        \"id\": -123456789,\n                        \"title\": \"Test Group\",\n                        \"type\": \"group\"\n                    },\n                    \"date\": 1640995200,\n                    \"text\": \"/start\"\n                }\n            });\n            \n            // Validate webhook structure\n            assert!(webhook_data[\"update_id\"].is_number());\n            assert!(webhook_data[\"message\"][\"message_id\"].is_number());\n            assert!(webhook_data[\"message\"][\"text\"].is_string());\n            assert_eq!(webhook_data[\"message\"][\"text\"], \"/start\");\n        }\n\n        #[test]\n        fn test_command_extraction() {\n            let command_text = \"/start\";\n            assert!(command_text.starts_with('/'));\n            \n            let command = \u0026command_text[1..]; // Remove '/' prefix\n            assert_eq!(command, \"start\");\n        }\n\n        #[test]\n        fn test_chat_id_extraction() {\n            let webhook_data = json!({\n                \"message\": {\n                    \"chat\": {\n                        \"id\": -123456789\n                    }\n                }\n            });\n            \n            if let Some(chat_id) = webhook_data[\"message\"][\"chat\"][\"id\"].as_i64() {\n                assert_eq!(chat_id, -123456789);\n            }\n        }\n    }\n\n    mod utility_functions {\n        use super::*;\n\n        #[test]\n        fn test_service_configuration_access() {\n            let config = create_test_config();\n            let original_token = config.bot_token.clone();\n            let service = TelegramService::new(config);\n            \n            // Service should store configuration\n            // (In real implementation, there would be a getter method)\n        }\n\n        #[test]\n        fn test_exchange_name_formatting() {\n            let binance = ExchangeIdEnum::Binance;\n            let bybit = ExchangeIdEnum::Bybit;\n            \n            // Test that exchange enums can be formatted\n            let binance_str = format!(\"{:?}\", binance);\n            let bybit_str = format!(\"{:?}\", bybit);\n            \n            assert_eq!(binance_str, \"Binance\");\n            assert_eq!(bybit_str, \"Bybit\");\n        }\n\n        #[test]\n        fn test_rate_difference_formatting() {\n            let rate_diff = 0.002f64; // 0.2%\n            \n            // Test percentage formatting\n            let percentage = rate_diff * 100.0;\n            assert!((percentage - 0.2).abs() \u003c 1e-10);\n            \n            // Test basis points formatting\n            let basis_points = rate_diff * 10000.0;\n            assert!((basis_points - 20.0).abs() \u003c 1e-10);\n        }\n\n        #[test]\n        fn test_timestamp_conversion() {\n            let timestamp = 1640995200000u64; // Jan 1, 2022\n            \n            // Should be convertible to datetime\n            let datetime = chrono::DateTime::from_timestamp_millis(timestamp as i64);\n            assert!(datetime.is_some());\n            \n            if let Some(dt) = datetime {\n                assert_eq!(dt.year(), 2022);\n                assert_eq!(dt.month(), 1);\n                assert_eq!(dt.day(), 1);\n            }\n        }\n    }\n\n    mod integration_scenarios {\n        use super::*;\n\n        #[test]\n        fn test_complete_notification_workflow() {\n            let config = create_test_config();\n            let service = TelegramService::new(config);\n            let opportunity = create_test_opportunity();\n            \n            // Verify all components needed for notification are present\n            assert!(!opportunity.id.is_empty());\n            assert!(!opportunity.pair.is_empty());\n            assert!(opportunity.rate_difference \u003e 0.0);\n            assert!(opportunity.long_exchange.is_some());\n            assert!(opportunity.short_exchange.is_some());\n        }\n\n        #[test]\n        fn test_multiple_opportunities_handling() {\n            let config = create_test_config();\n            let service = TelegramService::new(config);\n            \n            // Create multiple opportunities\n            let mut opp1 = create_test_opportunity();\n            opp1.id = \"opp_001\".to_string();\n            opp1.pair = \"BTCUSDT\".to_string();\n            \n            let mut opp2 = create_test_opportunity();\n            opp2.id = \"opp_002\".to_string();\n            opp2.pair = \"ETHUSDT\".to_string();\n            \n            // Should handle multiple opportunities\n            assert_ne!(opp1.id, opp2.id);\n            assert_ne!(opp1.pair, opp2.pair);\n        }\n\n        #[test]\n        fn test_service_state_consistency() {\n            let config = create_test_config();\n            let service = TelegramService::new(config.clone());\n            \n            // Service should maintain consistent state\n            assert_eq!(std::mem::size_of_val(\u0026service), std::mem::size_of::\u003cTelegramService\u003e());\n        }\n    }\n} ","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":12}},{"line":25,"address":[],"length":0,"stats":{"Line":12}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":73},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","services","user_profile.rs"],"content":"// src/services/user_profile.rs\n\nuse crate::types::{UserProfile, UserApiKey, InvitationCode, UserSession, ExchangeIdEnum, ApiKeyProvider};\nuse crate::utils::{ArbitrageError, ArbitrageResult};\nuse worker::kv::KvStore;\nuse std::collections::HashMap;\n\npub struct UserProfileService {\n    kv_store: KvStore,\n    encryption_key: String, // For encrypting API keys\n}\n\nimpl UserProfileService {\n    pub fn new(kv_store: KvStore, encryption_key: String) -\u003e Self {\n        Self {\n            kv_store,\n            encryption_key,\n        }\n    }\n\n    // User Profile CRUD Operations\n    pub async fn create_user_profile(\n        \u0026self,\n        telegram_user_id: i64,\n        invitation_code: Option\u003cString\u003e,\n        telegram_username: Option\u003cString\u003e,\n    ) -\u003e ArbitrageResult\u003cUserProfile\u003e {\n        // Check if user already exists\n        if let Some(_existing) = self.get_user_by_telegram_id(telegram_user_id).await? {\n            return Err(ArbitrageError::validation_error(\n                \"User profile already exists for this Telegram ID\"\n            ));\n        }\n\n        // Validate invitation code if provided\n        if let Some(ref code) = invitation_code {\n            self.validate_and_use_invitation_code(code).await?;\n        }\n\n        let mut profile = UserProfile::new(telegram_user_id, invitation_code);\n        profile.telegram_username = telegram_username;\n\n        // Store profile\n        self.store_user_profile(\u0026profile).await?;\n\n        // Create user session\n        let session = UserSession::new(profile.user_id.clone(), telegram_user_id);\n        self.store_user_session(\u0026session).await?;\n\n        Ok(profile)\n    }\n\n    pub async fn get_user_profile(\u0026self, user_id: \u0026str) -\u003e ArbitrageResult\u003cOption\u003cUserProfile\u003e\u003e {\n        let key = format!(\"user_profile:{}\", user_id);\n\n        match self.kv_store.get(\u0026key).text().await {\n            Ok(Some(value)) =\u003e {\n                let profile: UserProfile = serde_json::from_str(\u0026value).map_err(|e| {\n                    ArbitrageError::parse_error(format!(\"Failed to deserialize user profile: {}\", e))\n                })?;\n                Ok(Some(profile))\n            }\n            Ok(None) =\u003e Ok(None),\n            Err(e) =\u003e Err(ArbitrageError::database_error(format!(\n                \"Failed to get user profile: {}\",\n                e\n            ))),\n        }\n    }\n\n    pub async fn get_user_by_telegram_id(\u0026self, telegram_user_id: i64) -\u003e ArbitrageResult\u003cOption\u003cUserProfile\u003e\u003e {\n        let key = format!(\"telegram_user:{}\", telegram_user_id);\n\n        match self.kv_store.get(\u0026key).text().await {\n            Ok(Some(user_id)) =\u003e {\n                self.get_user_profile(\u0026user_id).await\n            }\n            Ok(None) =\u003e Ok(None),\n            Err(e) =\u003e Err(ArbitrageError::database_error(format!(\n                \"Failed to get user by Telegram ID: {}\",\n                e\n            ))),\n        }\n    }\n\n    pub async fn update_user_profile(\u0026self, profile: \u0026UserProfile) -\u003e ArbitrageResult\u003c()\u003e {\n        let mut updated_profile = profile.clone();\n        updated_profile.updated_at = chrono::Utc::now().timestamp_millis() as u64;\n\n        self.store_user_profile(\u0026updated_profile).await\n    }\n\n    pub async fn update_user_last_active(\u0026self, user_id: \u0026str) -\u003e ArbitrageResult\u003c()\u003e {\n        if let Some(mut profile) = self.get_user_profile(user_id).await? {\n            profile.update_last_active();\n            self.update_user_profile(\u0026profile).await?;\n        }\n        Ok(())\n    }\n\n    // API Key Management\n    pub async fn add_user_api_key(\n        \u0026self,\n        user_id: \u0026str,\n        exchange: ExchangeIdEnum,\n        api_key: \u0026str,\n        secret: \u0026str,\n        permissions: Vec\u003cString\u003e,\n    ) -\u003e ArbitrageResult\u003c()\u003e {\n        let mut profile = self.get_user_profile(user_id).await?\n            .ok_or_else(|| ArbitrageError::not_found(\"User profile not found\"))?;\n\n        let api_key_encrypted = self.encrypt_string(api_key)?;\n        let secret_encrypted = self.encrypt_string(secret)?;\n\n        let user_api_key = UserApiKey::new_exchange_key(\n            user_id.to_string(),\n            exchange,\n            api_key_encrypted,\n            secret_encrypted,\n            permissions,\n        );\n\n        profile.add_api_key(user_api_key);\n        self.update_user_profile(\u0026profile).await?;\n\n        Ok(())\n    }\n\n    pub async fn remove_user_api_key(\n        \u0026self,\n        user_id: \u0026str,\n        exchange: \u0026ExchangeIdEnum,\n    ) -\u003e ArbitrageResult\u003cbool\u003e {\n        let mut profile = self.get_user_profile(user_id).await?\n            .ok_or_else(|| ArbitrageError::not_found(\"User profile not found\"))?;\n\n        let removed = profile.remove_api_key(exchange);\n        if removed {\n            self.update_user_profile(\u0026profile).await?;\n        }\n\n        Ok(removed)\n    }\n\n    pub async fn get_user_api_keys(\u0026self, user_id: \u0026str) -\u003e ArbitrageResult\u003cVec\u003cUserApiKey\u003e\u003e {\n        let profile = self.get_user_profile(user_id).await?\n            .ok_or_else(|| ArbitrageError::not_found(\"User profile not found\"))?;\n\n        Ok(profile.api_keys.clone())\n    }\n\n    pub async fn decrypt_user_api_key(\n        \u0026self,\n        encrypted_key: \u0026str,\n        encrypted_secret: \u0026str,\n    ) -\u003e ArbitrageResult\u003c(String, String)\u003e {\n        let api_key = self.decrypt_string(encrypted_key)?;\n        let secret = self.decrypt_string(encrypted_secret)?;\n        Ok((api_key, secret))\n    }\n\n    // Session Management\n    pub async fn store_user_session(\u0026self, session: \u0026UserSession) -\u003e ArbitrageResult\u003c()\u003e {\n        let key = format!(\"user_session:{}\", session.telegram_chat_id);\n        let value = serde_json::to_string(session).map_err(|e| {\n            ArbitrageError::parse_error(format!(\"Failed to serialize user session: {}\", e))\n        })?;\n\n        self.kv_store\n            .put(\u0026key, value)\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to store user session: {}\", e))\n            })?\n            .execute()\n            .await\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to execute session put: {}\", e))\n            })?;\n\n        Ok(())\n    }\n\n    pub async fn get_user_session(\u0026self, telegram_chat_id: i64) -\u003e ArbitrageResult\u003cOption\u003cUserSession\u003e\u003e {\n        let key = format!(\"user_session:{}\", telegram_chat_id);\n\n        match self.kv_store.get(\u0026key).text().await {\n            Ok(Some(value)) =\u003e {\n                let session: UserSession = serde_json::from_str(\u0026value).map_err(|e| {\n                    ArbitrageError::parse_error(format!(\"Failed to deserialize user session: {}\", e))\n                })?;\n\n                // Check if session is expired\n                if session.is_expired() {\n                    self.delete_user_session(telegram_chat_id).await?;\n                    Ok(None)\n                } else {\n                    Ok(Some(session))\n                }\n            }\n            Ok(None) =\u003e Ok(None),\n            Err(e) =\u003e Err(ArbitrageError::database_error(format!(\n                \"Failed to get user session: {}\",\n                e\n            ))),\n        }\n    }\n\n    pub async fn update_user_session(\u0026self, session: \u0026UserSession) -\u003e ArbitrageResult\u003c()\u003e {\n        self.store_user_session(session).await\n    }\n\n    pub async fn delete_user_session(\u0026self, telegram_chat_id: i64) -\u003e ArbitrageResult\u003c()\u003e {\n        let key = format!(\"user_session:{}\", telegram_chat_id);\n\n        self.kv_store\n            .delete(\u0026key)\n            .await\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to delete user session: {}\", e))\n            })?;\n\n        Ok(())\n    }\n\n    // Invitation Code Management\n    pub async fn create_invitation_code(\n        \u0026self,\n        purpose: String,\n        max_uses: Option\u003cu32\u003e,\n        expires_in_days: Option\u003cu32\u003e,\n        created_by: Option\u003cString\u003e,\n    ) -\u003e ArbitrageResult\u003cInvitationCode\u003e {\n        let mut invitation = InvitationCode::new(purpose, max_uses, expires_in_days);\n        invitation.created_by = created_by;\n\n        self.store_invitation_code(\u0026invitation).await?;\n\n        Ok(invitation)\n    }\n\n    pub async fn validate_and_use_invitation_code(\u0026self, code: \u0026str) -\u003e ArbitrageResult\u003c()\u003e {\n        let mut invitation = self.get_invitation_code(code).await?\n            .ok_or_else(|| ArbitrageError::not_found(\"Invitation code not found\"))?;\n\n        if !invitation.can_be_used() {\n            return Err(ArbitrageError::validation_error(\n                \"Invitation code is expired or has reached maximum uses\"\n            ));\n        }\n\n        invitation.use_code();\n        self.store_invitation_code(\u0026invitation).await?;\n\n        Ok(())\n    }\n\n    pub async fn get_invitation_code(\u0026self, code: \u0026str) -\u003e ArbitrageResult\u003cOption\u003cInvitationCode\u003e\u003e {\n        let key = format!(\"invitation_code:{}\", code);\n\n        match self.kv_store.get(\u0026key).text().await {\n            Ok(Some(value)) =\u003e {\n                let invitation: InvitationCode = serde_json::from_str(\u0026value).map_err(|e| {\n                    ArbitrageError::parse_error(format!(\"Failed to deserialize invitation code: {}\", e))\n                })?;\n                Ok(Some(invitation))\n            }\n            Ok(None) =\u003e Ok(None),\n            Err(e) =\u003e Err(ArbitrageError::database_error(format!(\n                \"Failed to get invitation code: {}\",\n                e\n            ))),\n        }\n    }\n\n    // Helper methods\n    async fn store_user_profile(\u0026self, profile: \u0026UserProfile) -\u003e ArbitrageResult\u003c()\u003e {\n        let user_key = format!(\"user_profile:{}\", profile.user_id);\n        let telegram_key = format!(\"telegram_user:{}\", profile.telegram_user_id);\n\n        let profile_value = serde_json::to_string(profile).map_err(|e| {\n            ArbitrageError::parse_error(format!(\"Failed to serialize user profile: {}\", e))\n        })?;\n\n        // Store profile by user ID\n        self.kv_store\n            .put(\u0026user_key, \u0026profile_value)\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to store user profile: {}\", e))\n            })?\n            .execute()\n            .await\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to execute profile put: {}\", e))\n            })?;\n\n        // Store mapping from Telegram ID to user ID\n        self.kv_store\n            .put(\u0026telegram_key, \u0026profile.user_id)\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to store telegram mapping: {}\", e))\n            })?\n            .execute()\n            .await\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to execute telegram mapping put: {}\", e))\n            })?;\n\n        Ok(())\n    }\n\n    async fn store_invitation_code(\u0026self, invitation: \u0026InvitationCode) -\u003e ArbitrageResult\u003c()\u003e {\n        let key = format!(\"invitation_code:{}\", invitation.code);\n        let value = serde_json::to_string(invitation).map_err(|e| {\n            ArbitrageError::parse_error(format!(\"Failed to serialize invitation code: {}\", e))\n        })?;\n\n        self.kv_store\n            .put(\u0026key, value)\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to store invitation code: {}\", e))\n            })?\n            .execute()\n            .await\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to execute invitation put: {}\", e))\n            })?;\n\n        Ok(())\n    }\n\n    // Simple encryption/decryption (in production, use proper encryption)\n    fn encrypt_string(\u0026self, plaintext: \u0026str) -\u003e ArbitrageResult\u003cString\u003e {\n        // For MVP, we'll use base64 encoding with a simple XOR cipher\n        // In production, use proper encryption like AES-GCM\n        use base64::{Engine as _, engine::general_purpose};\n        \n        let key_bytes = self.encryption_key.as_bytes();\n        let plaintext_bytes = plaintext.as_bytes();\n        \n        let encrypted: Vec\u003cu8\u003e = plaintext_bytes\n            .iter()\n            .enumerate()\n            .map(|(i, \u0026byte)| byte ^ key_bytes[i % key_bytes.len()])\n            .collect();\n        \n        Ok(general_purpose::STANDARD.encode(encrypted))\n    }\n\n    fn decrypt_string(\u0026self, ciphertext: \u0026str) -\u003e ArbitrageResult\u003cString\u003e {\n        use base64::{Engine as _, engine::general_purpose};\n        \n        let encrypted = general_purpose::STANDARD.decode(ciphertext).map_err(|e| {\n            ArbitrageError::parse_error(format!(\"Failed to decode base64: {}\", e))\n        })?;\n        \n        let key_bytes = self.encryption_key.as_bytes();\n        let decrypted: Vec\u003cu8\u003e = encrypted\n            .iter()\n            .enumerate()\n            .map(|(i, \u0026byte)| byte ^ key_bytes[i % key_bytes.len()])\n            .collect();\n        \n        String::from_utf8(decrypted).map_err(|e| {\n            ArbitrageError::parse_error(format!(\"Failed to convert decrypted bytes to string: {}\", e))\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::{ExchangeIdEnum, SubscriptionTier, ApiKeyProvider};\n\n    // Mock KV storage for testing\n    #[derive(Debug, Clone)]\n    struct MockKvStore {\n        data: std::sync::Arc\u003cstd::sync::Mutex\u003cHashMap\u003cString, String\u003e\u003e\u003e,\n    }\n\n    impl MockKvStore {\n        fn new() -\u003e Self {\n            Self {\n                data: std::sync::Arc::new(std::sync::Mutex::new(HashMap::new())),\n            }\n        }\n\n        async fn get(\u0026self, key: \u0026str) -\u003e Option\u003cString\u003e {\n            let data = self.data.lock().unwrap();\n            data.get(key).cloned()\n        }\n\n        async fn put(\u0026self, key: \u0026str, value: \u0026str) -\u003e Result\u003c(), String\u003e {\n            let mut data = self.data.lock().unwrap();\n            data.insert(key.to_string(), value.to_string());\n            Ok(())\n        }\n\n        async fn delete(\u0026self, key: \u0026str) -\u003e Result\u003c(), String\u003e {\n            let mut data = self.data.lock().unwrap();\n            data.remove(key);\n            Ok(())\n        }\n    }\n\n    fn create_test_service() -\u003e UserProfileService {\n        // Note: In real tests, we'd need proper KV store mocking\n        // For now, this demonstrates the service structure\n        panic!(\"Test service creation requires proper KV store mock implementation\")\n    }\n\n    #[test]\n    fn test_user_profile_creation() {\n        let telegram_user_id = 123456789;\n        let invitation_code = Some(\"ARB-TEST1234\".to_string());\n        \n        let profile = UserProfile::new(telegram_user_id, invitation_code.clone());\n        \n        assert_eq!(profile.telegram_user_id, telegram_user_id);\n        assert_eq!(profile.invitation_code, invitation_code);\n        assert_eq!(profile.subscription.tier, SubscriptionTier::Free);\n        assert!(profile.subscription.is_active);\n        assert!(profile.is_active);\n        assert_eq!(profile.api_keys.len(), 0);\n        assert!(!profile.has_minimum_exchanges());\n        assert!(!profile.can_trade()); // Can't trade without API keys\n    }\n\n    #[test]\n    fn test_user_profile_api_key_management() {\n        let mut profile = UserProfile::new(123456789, None);\n        \n        let api_key = UserApiKey::new_exchange_key(\n            profile.user_id.clone(),\n            ExchangeIdEnum::Binance,\n            \"encrypted_key\".to_string(),\n            \"encrypted_secret\".to_string(),\n            vec![\"read\".to_string(), \"trade\".to_string()],\n        );\n\n        // Add API key\n        profile.add_api_key(api_key);\n        assert_eq!(profile.api_keys.len(), 1);\n        \n        // Check that we can find the Binance key\n        let has_binance = profile.api_keys.iter().any(|key| {\n            if let ApiKeyProvider::Exchange(exchange) = \u0026key.provider {\n                exchange == \u0026ExchangeIdEnum::Binance\n            } else {\n                false\n            }\n        });\n        assert!(has_binance);\n        assert!(!profile.has_minimum_exchanges()); // Still need 2 exchanges\n\n        // Add second API key for different exchange\n        let api_key2 = UserApiKey::new_exchange_key(\n            profile.user_id.clone(),\n            ExchangeIdEnum::Bybit,\n            \"encrypted_key2\".to_string(),\n            \"encrypted_secret2\".to_string(),\n            vec![\"read\".to_string(), \"trade\".to_string()],\n        );\n\n        profile.add_api_key(api_key2);\n        assert_eq!(profile.api_keys.len(), 2);\n        assert!(profile.has_minimum_exchanges());\n        assert!(profile.can_trade());\n\n        // Test that we have both exchanges\n        let exchange_count = profile.api_keys.iter()\n            .filter(|key| key.is_exchange_key())\n            .count();\n        assert_eq!(exchange_count, 2);\n    }\n\n    #[test]\n    fn test_invitation_code_creation() {\n        let purpose = \"beta_testing\".to_string();\n        let invitation = InvitationCode::new(purpose.clone(), Some(10), Some(30));\n        \n        assert!(invitation.code.starts_with(\"ARB-\"));\n        assert_eq!(invitation.purpose, purpose);\n        assert_eq!(invitation.max_uses, Some(10));\n        assert_eq!(invitation.current_uses, 0);\n        assert!(invitation.is_active);\n        assert!(invitation.can_be_used());\n    }\n\n    #[test]\n    fn test_invitation_code_usage() {\n        let mut invitation = InvitationCode::new(\"test\".to_string(), Some(2), None);\n        \n        // First use\n        assert!(invitation.use_code());\n        assert_eq!(invitation.current_uses, 1);\n        assert!(invitation.can_be_used());\n\n        // Second use\n        assert!(invitation.use_code());\n        assert_eq!(invitation.current_uses, 2);\n        assert!(!invitation.can_be_used()); // Max uses reached\n\n        // Third use should fail\n        assert!(!invitation.use_code());\n        assert_eq!(invitation.current_uses, 2);\n    }\n\n    #[test]\n    fn test_user_session_creation() {\n        let user_id = \"test-user-123\".to_string();\n        let telegram_chat_id = 987654321;\n        \n        let session = UserSession::new(user_id.clone(), telegram_chat_id);\n        \n        assert_eq!(session.user_id, user_id);\n        assert_eq!(session.telegram_chat_id, telegram_chat_id);\n        assert!(!session.is_expired());\n        assert_eq!(session.current_state, crate::types::SessionState::Idle);\n    }\n\n    #[test]\n    fn test_encryption_decryption() {\n        // Create a minimal service just for testing encryption\n        let encryption_key = \"test_encryption_key_123\".to_string();\n        \n        // Test the encryption/decryption methods directly\n        let plaintext = \"sensitive_api_key_123\";\n        \n        // Create a temporary service for testing\n        let temp_service = UserProfileService {\n            kv_store: unsafe { std::mem::zeroed() }, // Not used in this test\n            encryption_key,\n        };\n        \n        let encrypted = temp_service.encrypt_string(plaintext).unwrap();\n        let decrypted = temp_service.decrypt_string(\u0026encrypted).unwrap();\n        \n        assert_eq!(plaintext, decrypted);\n        assert_ne!(plaintext, encrypted); // Should be different when encrypted\n        \n        // Forget the temp_service to avoid drop issues\n        std::mem::forget(temp_service);\n    }\n} ","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":1}},{"line":338,"address":[],"length":0,"stats":{"Line":1}},{"line":339,"address":[],"length":0,"stats":{"Line":1}},{"line":341,"address":[],"length":0,"stats":{"Line":1}},{"line":344,"address":[],"length":0,"stats":{"Line":23}},{"line":347,"address":[],"length":0,"stats":{"Line":1}},{"line":350,"address":[],"length":0,"stats":{"Line":1}},{"line":353,"address":[],"length":0,"stats":{"Line":2}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":21}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}}],"covered":9,"coverable":175},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","types.rs"],"content":"// src/types.rs\n\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::time::{SystemTime, UNIX_EPOCH};\nuse thiserror::Error;\n\n/// Exchange identifiers\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\n#[allow(clippy::upper_case_acronyms)]\npub enum ExchangeIdEnum {\n    Binance,\n    Bybit,\n    OKX,\n    Bitget,\n    // Add other exchanges as needed\n}\n\nimpl ExchangeIdEnum {\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            ExchangeIdEnum::Binance =\u003e \"binance\",\n            ExchangeIdEnum::Bybit =\u003e \"bybit\",\n            ExchangeIdEnum::OKX =\u003e \"okx\",\n            ExchangeIdEnum::Bitget =\u003e \"bitget\",\n        }\n    }\n}\n\nimpl std::fmt::Display for ExchangeIdEnum {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }\n}\n\n// AI Provider enum for different AI services\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum ApiKeyProvider {\n    OpenAI,\n    Anthropic,\n    Custom,\n    Exchange(ExchangeIdEnum), // For exchange API keys\n}\n\nimpl std::fmt::Display for ApiKeyProvider {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            ApiKeyProvider::OpenAI =\u003e write!(f, \"openai\"),\n            ApiKeyProvider::Anthropic =\u003e write!(f, \"anthropic\"),\n            ApiKeyProvider::Custom =\u003e write!(f, \"custom\"),\n            ApiKeyProvider::Exchange(exchange) =\u003e write!(f, \"exchange_{}\", exchange),\n        }\n    }\n}\n\n// String alias for exchange identifiers (for compatibility with CCXT-like interface)\npub type ExchangeId = String;\npub type TradingPairSymbol = String;\n\n/// Types of arbitrage opportunities\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum ArbitrageType {\n    FundingRate,\n    SpotFutures,\n    CrossExchange,\n}\n\n/// Core arbitrage opportunity structure\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ArbitrageOpportunity {\n    pub id: String,\n    pub pair: String,\n    pub long_exchange: Option\u003cExchangeIdEnum\u003e,\n    pub short_exchange: Option\u003cExchangeIdEnum\u003e,\n    pub long_rate: Option\u003cf64\u003e,\n    pub short_rate: Option\u003cf64\u003e,\n    pub rate_difference: f64,\n    pub net_rate_difference: Option\u003cf64\u003e,\n    pub potential_profit_value: Option\u003cf64\u003e,\n    pub timestamp: u64, // Unix timestamp in milliseconds\n    pub r#type: ArbitrageType,\n    pub details: Option\u003cString\u003e,\n}\n\nimpl ArbitrageOpportunity {\n    pub fn new(\n        pair: String,\n        long_exchange: Option\u003cExchangeIdEnum\u003e,\n        short_exchange: Option\u003cExchangeIdEnum\u003e,\n        long_rate: Option\u003cf64\u003e,\n        short_rate: Option\u003cf64\u003e,\n        rate_difference: f64,\n        r#type: ArbitrageType,\n    ) -\u003e Self {\n        Self {\n            id: String::new(),\n            pair,\n            long_exchange,\n            short_exchange,\n            long_rate,\n            short_rate,\n            rate_difference,\n            net_rate_difference: None,\n            potential_profit_value: None,\n            timestamp: SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .unwrap()\n                .as_millis() as u64,\n            r#type,\n            details: None,\n        }\n    }\n\n    pub fn with_net_difference(mut self, net_rate_difference: f64) -\u003e Self {\n        self.net_rate_difference = Some(net_rate_difference);\n        self\n    }\n\n    pub fn with_potential_profit(mut self, potential_profit_value: f64) -\u003e Self {\n        self.potential_profit_value = Some(potential_profit_value);\n        self\n    }\n\n    pub fn with_details(mut self, details: String) -\u003e Self {\n        self.details = Some(details);\n        self\n    }\n}\n\n/// Exchange rate data\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ExchangeRate {\n    pub exchange: ExchangeIdEnum,\n    pub pair: String,\n    pub rate: f64,\n    pub timestamp: u64,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum PositionSide {\n    Long,\n    Short,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum PositionStatus {\n    Open,\n    Closed,\n    Pending,\n}\n\n/// Position data for tracking open positions\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ArbitragePosition {\n    pub id: String,\n    pub exchange: ExchangeIdEnum,\n    pub pair: String,\n    pub side: PositionSide,\n    pub size: f64,\n    pub entry_price: f64,\n    pub current_price: Option\u003cf64\u003e,\n    pub pnl: Option\u003cf64\u003e,\n    pub status: PositionStatus,\n    pub created_at: u64,\n    pub updated_at: u64,\n}\n\n/// Configuration for the application\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AppConfig {\n    pub environment: String,\n    pub usdt_amount: f64,\n    pub bybit_leverage: u32,\n    pub binance_leverage: u32,\n    pub log_level: String,\n}\n\nimpl Default for AppConfig {\n    fn default() -\u003e Self {\n        Self {\n            environment: \"development\".to_string(),\n            usdt_amount: 10.0,\n            bybit_leverage: 20,\n            binance_leverage: 20,\n            log_level: \"info\".to_string(),\n        }\n    }\n}\n\n// Exchange trading types (CCXT-like interface)\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum OrderType {\n    Market,\n    Limit,\n    StopMarket,\n    StopLimit,\n    TrailingStop,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum OrderSide {\n    Buy,\n    Sell,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum OrderStatus {\n    Open,\n    Closed,\n    Canceled,\n    Expired,\n    Rejected,\n    Pending,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Market {\n    pub id: String,\n    pub symbol: String,\n    pub base: String,\n    pub quote: String,\n    pub active: bool,\n    pub precision: Precision,\n    pub limits: Limits,\n    pub fees: Option\u003cTradingFee\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Precision {\n    pub amount: Option\u003ci32\u003e,\n    pub price: Option\u003ci32\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Limits {\n    pub amount: MinMax,\n    pub price: MinMax,\n    pub cost: MinMax,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MinMax {\n    pub min: Option\u003cf64\u003e,\n    pub max: Option\u003cf64\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Ticker {\n    pub symbol: String,\n    pub bid: Option\u003cf64\u003e,\n    pub ask: Option\u003cf64\u003e,\n    pub last: Option\u003cf64\u003e,\n    pub high: Option\u003cf64\u003e,\n    pub low: Option\u003cf64\u003e,\n    pub volume: Option\u003cf64\u003e,\n    pub timestamp: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    pub datetime: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OrderBook {\n    pub symbol: String,\n    pub bids: Vec\u003c[f64; 2]\u003e, // [price, amount]\n    pub asks: Vec\u003c[f64; 2]\u003e, // [price, amount]\n    pub timestamp: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    pub datetime: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Balance {\n    pub free: f64,\n    pub used: f64,\n    pub total: f64,\n}\n\npub type Balances = HashMap\u003cString, Balance\u003e;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Order {\n    pub id: String,\n    pub client_order_id: Option\u003cString\u003e,\n    pub symbol: String,\n    pub r#type: OrderType,\n    pub side: OrderSide,\n    pub amount: f64,\n    pub price: Option\u003cf64\u003e,\n    pub cost: Option\u003cf64\u003e,\n    pub filled: f64,\n    pub remaining: f64,\n    pub status: OrderStatus,\n    pub timestamp: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    pub datetime: Option\u003cString\u003e,\n    pub fee: Option\u003cFee\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Position {\n    pub id: Option\u003cString\u003e,\n    pub symbol: String,\n    pub side: PositionSide,\n    pub size: f64,\n    pub notional: f64,\n    pub entry_price: f64,\n    pub mark_price: Option\u003cf64\u003e,\n    pub unrealized_pnl: f64,\n    pub realized_pnl: f64,\n    pub leverage: f64,\n    pub margin: f64,\n    pub timestamp: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    pub datetime: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Fee {\n    pub currency: String,\n    pub cost: f64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TradingFee {\n    pub maker: f64,\n    pub taker: f64,\n    pub percentage: bool,\n}\n\npub type TradingFeeInterface = TradingFee;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FundingRateInfo {\n    pub symbol: String,\n    pub funding_rate: f64,\n    pub timestamp: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    pub datetime: Option\u003cString\u003e,\n    pub next_funding_time: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    pub estimated_rate: Option\u003cf64\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ExchangeCredentials {\n    pub api_key: String,\n    pub secret: String,\n    pub default_leverage: i32,\n    pub exchange_type: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct StructuredTradingPair {\n    pub symbol: String,\n    pub base: String,\n    pub quote: String,\n    pub exchange_id: String,\n}\n\n// Environment and configuration types\npub struct LoggerInterface {\n    // Implementation will be in logger.rs\n}\n\npub struct Env {\n    // Worker environment interface containing the full environment\n    pub worker_env: worker::Env,\n}\n\nimpl Env {\n    pub fn new(worker_env: worker::Env) -\u003e Self {\n        Self { worker_env }\n    }\n    \n    pub fn get_kv_store(\u0026self, binding_name: \u0026str) -\u003e Option\u003cworker::kv::KvStore\u003e {\n        self.worker_env.kv(binding_name).ok()\n    }\n}\n\n// Error types\n#[derive(Debug, thiserror::Error)]\npub enum ExchangeError {\n    #[error(\"Network error: {0}\")]\n    Network(String),\n    #[error(\"API error: {0}\")]\n    Api(String),\n    #[error(\"Authentication error: {0}\")]\n    Auth(String),\n    #[error(\"Order not found: {0}\")]\n    OrderNotFound(String),\n    #[error(\"Invalid symbol: {0}\")]\n    InvalidSymbol(String),\n    #[error(\"Insufficient funds\")]\n    InsufficientFunds,\n    #[error(\"Rate limit exceeded\")]\n    RateLimit,\n    #[error(\"Exchange not supported: {0}\")]\n    ExchangeNotSupported(String),\n    #[error(\"Serialization error: {0}\")]\n    Serialization(#[from] serde_json::Error),\n    #[error(\"HTTP error: {0}\")]\n    Http(#[from] reqwest::Error),\n}\n\npub type ExchangeResult\u003cT\u003e = Result\u003cT, ExchangeError\u003e;\n\n// User Profile and Subscription System\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum SubscriptionTier {\n    Free,\n    Basic,\n    Premium,\n    Enterprise,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct SubscriptionInfo {\n    pub tier: SubscriptionTier,\n    pub is_active: bool,\n    pub expires_at: Option\u003cu64\u003e, // Unix timestamp in milliseconds\n    pub created_at: u64,\n    pub features: Vec\u003cString\u003e, // List of enabled features\n}\n\nimpl Default for SubscriptionInfo {\n    fn default() -\u003e Self {\n        Self {\n            tier: SubscriptionTier::Free,\n            is_active: true,\n            expires_at: None, // Free tier doesn't expire\n            created_at: chrono::Utc::now().timestamp_millis() as u64,\n            features: vec![\"basic_arbitrage\".to_string(), \"manual_trading\".to_string()],\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct UserConfiguration {\n    pub max_leverage: u32,\n    pub max_entry_size_usdt: f64,\n    pub min_entry_size_usdt: f64,\n    pub risk_tolerance_percentage: f64, // 0.0 to 1.0\n    pub opportunity_threshold: f64, // Minimum rate difference to consider\n    pub auto_trading_enabled: bool,\n    pub notification_preferences: NotificationPreferences,\n    pub trading_pairs: Vec\u003cString\u003e, // Monitored trading pairs\n    pub excluded_pairs: Vec\u003cString\u003e, // Excluded trading pairs\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NotificationPreferences {\n    pub push_opportunities: bool,\n    pub push_executions: bool,\n    pub push_risk_alerts: bool,\n    pub push_system_status: bool,\n    pub min_profit_threshold_usdt: f64, // Only notify if potential profit \u003e this\n    pub max_notifications_per_hour: u32,\n}\n\nimpl Default for UserConfiguration {\n    fn default() -\u003e Self {\n        Self {\n            max_leverage: 10,\n            max_entry_size_usdt: 1000.0,\n            min_entry_size_usdt: 50.0,\n            risk_tolerance_percentage: 0.02, // 2%\n            opportunity_threshold: 0.001, // 0.1%\n            auto_trading_enabled: false,\n            notification_preferences: NotificationPreferences::default(),\n            trading_pairs: vec![\"BTCUSDT\".to_string(), \"ETHUSDT\".to_string()],\n            excluded_pairs: vec![],\n        }\n    }\n}\n\nimpl Default for NotificationPreferences {\n    fn default() -\u003e Self {\n        Self {\n            push_opportunities: true,\n            push_executions: true,\n            push_risk_alerts: true,\n            push_system_status: false,\n            min_profit_threshold_usdt: 1.0,\n            max_notifications_per_hour: 10,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct UserApiKey {\n    pub id: String, // Unique identifier for this API key\n    pub user_id: String, // User who owns this key\n    pub provider: ApiKeyProvider, // Which service this key is for\n    pub encrypted_key: String, // Encrypted API key\n    pub encrypted_secret: Option\u003cString\u003e, // Optional secret (for exchanges)\n    pub metadata: serde_json::Value, // Additional configuration (models, base_urls, etc.)\n    pub is_active: bool,\n    pub created_at: u64,\n    pub last_used: Option\u003cu64\u003e,\n    pub permissions: Vec\u003cString\u003e, // e.g., [\"read\", \"trade\", \"futures\"] for exchanges, [\"chat\", \"analysis\"] for AI\n}\n\nimpl UserApiKey {\n    pub fn new_exchange_key(\n        user_id: String,\n        exchange: ExchangeIdEnum,\n        encrypted_api_key: String,\n        encrypted_secret: String,\n        permissions: Vec\u003cString\u003e,\n    ) -\u003e Self {\n        Self {\n            id: uuid::Uuid::new_v4().to_string(),\n            user_id,\n            provider: ApiKeyProvider::Exchange(exchange),\n            encrypted_key: encrypted_api_key,\n            encrypted_secret: Some(encrypted_secret),\n            metadata: serde_json::json!({}),\n            is_active: true,\n            created_at: chrono::Utc::now().timestamp_millis() as u64,\n            last_used: None,\n            permissions,\n        }\n    }\n\n    pub fn new_ai_key(\n        user_id: String,\n        provider: ApiKeyProvider,\n        encrypted_api_key: String,\n        metadata: serde_json::Value,\n    ) -\u003e Self {\n        Self {\n            id: uuid::Uuid::new_v4().to_string(),\n            user_id,\n            provider,\n            encrypted_key: encrypted_api_key,\n            encrypted_secret: None,\n            metadata,\n            is_active: true,\n            created_at: chrono::Utc::now().timestamp_millis() as u64,\n            last_used: None,\n            permissions: vec![\"analysis\".to_string(), \"chat\".to_string()],\n        }\n    }\n\n    pub fn is_exchange_key(\u0026self) -\u003e bool {\n        matches!(self.provider, ApiKeyProvider::Exchange(_))\n    }\n\n    pub fn is_ai_key(\u0026self) -\u003e bool {\n        matches!(self.provider, ApiKeyProvider::OpenAI | ApiKeyProvider::Anthropic | ApiKeyProvider::Custom)\n    }\n\n    pub fn update_last_used(\u0026mut self) {\n        self.last_used = Some(chrono::Utc::now().timestamp_millis() as u64);\n    }\n}\n\n// Keep the old structure for backward compatibility during migration\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct LegacyUserApiKey {\n    pub exchange: ExchangeIdEnum,\n    pub api_key_encrypted: String, // Encrypted with user-specific key\n    pub secret_encrypted: String, // Encrypted with user-specific key\n    pub is_active: bool,\n    pub created_at: u64,\n    pub last_validated: Option\u003cu64\u003e,\n    pub permissions: Vec\u003cString\u003e, // e.g., [\"read\", \"trade\", \"futures\"]\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct UserProfile {\n    pub user_id: String, // Primary identifier\n    pub telegram_user_id: i64,\n    pub telegram_username: Option\u003cString\u003e,\n    pub subscription: SubscriptionInfo,\n    pub configuration: UserConfiguration,\n    pub api_keys: Vec\u003cUserApiKey\u003e,\n    pub invitation_code: Option\u003cString\u003e, // Code used to join\n    pub created_at: u64,\n    pub updated_at: u64,\n    pub last_active: u64,\n    pub is_active: bool,\n    pub total_trades: u32,\n    pub total_pnl_usdt: f64,\n}\n\nimpl UserProfile {\n    pub fn new(telegram_user_id: i64, invitation_code: Option\u003cString\u003e) -\u003e Self {\n        let now = chrono::Utc::now().timestamp_millis() as u64;\n        let user_id = uuid::Uuid::new_v4().to_string();\n        \n        Self {\n            user_id,\n            telegram_user_id,\n            telegram_username: None,\n            subscription: SubscriptionInfo::default(),\n            configuration: UserConfiguration::default(),\n            api_keys: vec![],\n            invitation_code,\n            created_at: now,\n            updated_at: now,\n            last_active: now,\n            is_active: true,\n            total_trades: 0,\n            total_pnl_usdt: 0.0,\n        }\n    }\n\n    pub fn update_last_active(\u0026mut self) {\n        self.last_active = chrono::Utc::now().timestamp_millis() as u64;\n        self.updated_at = self.last_active;\n    }\n\n    pub fn add_api_key(\u0026mut self, api_key: UserApiKey) {\n        // Remove existing key for same provider if present\n        self.api_keys.retain(|key| key.provider != api_key.provider);\n        self.api_keys.push(api_key);\n        self.updated_at = chrono::Utc::now().timestamp_millis() as u64;\n    }\n\n    pub fn remove_api_key(\u0026mut self, exchange: \u0026ExchangeIdEnum) -\u003e bool {\n        let initial_len = self.api_keys.len();\n        self.api_keys.retain(|key| {\n            if let ApiKeyProvider::Exchange(key_exchange) = \u0026key.provider {\n                key_exchange != exchange\n            } else {\n                true // Keep non-exchange keys\n            }\n        });\n        if self.api_keys.len() \u003c initial_len {\n            self.updated_at = chrono::Utc::now().timestamp_millis() as u64;\n            true\n        } else {\n            false\n        }\n    }\n\n    pub fn get_active_exchanges(\u0026self) -\u003e Vec\u003cExchangeIdEnum\u003e {\n        self.api_keys\n            .iter()\n            .filter(|key| key.is_active)\n            .filter_map(|key| {\n                if let ApiKeyProvider::Exchange(exchange) = \u0026key.provider {\n                    Some(exchange.clone())\n                } else {\n                    None\n                }\n            })\n            .collect()\n    }\n\n    pub fn has_minimum_exchanges(\u0026self) -\u003e bool {\n        self.get_active_exchanges().len() \u003e= 2\n    }\n\n    pub fn can_trade(\u0026self) -\u003e bool {\n        self.is_active \u0026\u0026 self.subscription.is_active \u0026\u0026 self.has_minimum_exchanges()\n    }\n}\n\n// Invitation System\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct InvitationCode {\n    pub code: String,\n    pub created_by: Option\u003cString\u003e, // User ID who created this code\n    pub created_at: u64,\n    pub expires_at: Option\u003cu64\u003e,\n    pub max_uses: Option\u003cu32\u003e,\n    pub current_uses: u32,\n    pub is_active: bool,\n    pub purpose: String, // e.g., \"beta_testing\", \"referral\", \"admin\"\n}\n\nimpl InvitationCode {\n    pub fn new(purpose: String, max_uses: Option\u003cu32\u003e, expires_in_days: Option\u003cu32\u003e) -\u003e Self {\n        let now = chrono::Utc::now().timestamp_millis() as u64;\n        let code = format!(\"ARB-{}\", uuid::Uuid::new_v4().to_string().replace('-', \"\").to_uppercase()[..8].to_string());\n        \n        let expires_at = expires_in_days.map(|days| {\n            now + (days as u64 * 24 * 60 * 60 * 1000) // Convert days to milliseconds\n        });\n\n        Self {\n            code,\n            created_by: None,\n            created_at: now,\n            expires_at,\n            max_uses,\n            current_uses: 0,\n            is_active: true,\n            purpose,\n        }\n    }\n\n    pub fn can_be_used(\u0026self) -\u003e bool {\n        let now = chrono::Utc::now().timestamp_millis() as u64;\n        \n        self.is_active\n            \u0026\u0026 self.expires_at.map_or(true, |exp| now \u003c exp)\n            \u0026\u0026 self.max_uses.map_or(true, |max| self.current_uses \u003c max)\n    }\n\n    pub fn use_code(\u0026mut self) -\u003e bool {\n        if self.can_be_used() {\n            self.current_uses += 1;\n            true\n        } else {\n            false\n        }\n    }\n}\n\n// Trading Session and State Management\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct UserSession {\n    pub user_id: String,\n    pub telegram_chat_id: i64,\n    pub last_command: Option\u003cString\u003e,\n    pub current_state: SessionState,\n    pub temporary_data: std::collections::HashMap\u003cString, String\u003e,\n    pub created_at: u64,\n    pub expires_at: u64,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum SessionState {\n    Idle,\n    AddingApiKey,\n    ConfiguringLeverage,\n    ConfiguringEntrySize,\n    ConfiguringRisk,\n    ExecutingTrade,\n    ViewingOpportunities,\n}\n\nimpl UserSession {\n    pub fn new(user_id: String, telegram_chat_id: i64) -\u003e Self {\n        let now = chrono::Utc::now().timestamp_millis() as u64;\n        let expires_at = now + (24 * 60 * 60 * 1000); // 24 hours\n\n        Self {\n            user_id,\n            telegram_chat_id,\n            last_command: None,\n            current_state: SessionState::Idle,\n            temporary_data: std::collections::HashMap::new(),\n            created_at: now,\n            expires_at,\n        }\n    }\n\n    pub fn is_expired(\u0026self) -\u003e bool {\n        let now = chrono::Utc::now().timestamp_millis() as u64;\n        now \u003e self.expires_at\n    }\n\n    pub fn extend_session(\u0026mut self) {\n        let now = chrono::Utc::now().timestamp_millis() as u64;\n        self.expires_at = now + (24 * 60 * 60 * 1000); // Extend by 24 hours\n    }\n}\n\n/// Global Opportunity System Types for Task 2\n\n/// Global opportunity with distribution metadata\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GlobalOpportunity {\n    pub opportunity: ArbitrageOpportunity,\n    pub detection_timestamp: u64,\n    pub expiry_timestamp: u64,\n    pub priority_score: f64, // Higher means more urgent/profitable\n    pub distributed_to: Vec\u003cString\u003e, // User IDs who received this opportunity\n    pub max_participants: Option\u003cu32\u003e, // Maximum number of users who can take this opportunity\n    pub current_participants: u32,\n    pub distribution_strategy: DistributionStrategy,\n    pub source: OpportunitySource,\n}\n\n/// How opportunities should be distributed\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum DistributionStrategy {\n    FirstComeFirstServe, // Simple queue-based\n    RoundRobin, // Fair rotation among active users\n    PriorityBased, // Based on user subscription tier and activity\n    Broadcast, // Send to all eligible users\n}\n\n/// Source of the opportunity\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum OpportunitySource {\n    SystemGenerated, // Generated by default strategy\n    UserAI(String), // Generated by user's AI with user_id\n    External, // From external sources\n}\n\n/// Opportunity queue management\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OpportunityQueue {\n    pub id: String,\n    pub opportunities: Vec\u003cGlobalOpportunity\u003e,\n    pub created_at: u64,\n    pub updated_at: u64,\n    pub total_distributed: u32,\n    pub active_users: Vec\u003cString\u003e, // Currently active user IDs\n}\n\n/// Distribution tracking per user\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct UserOpportunityDistribution {\n    pub user_id: String,\n    pub last_opportunity_received: Option\u003cu64\u003e, // timestamp\n    pub total_opportunities_received: u32,\n    pub opportunities_today: u32,\n    pub last_daily_reset: u64, // timestamp for daily reset\n    pub priority_weight: f64, // User's priority in distribution\n    pub is_eligible: bool, // Whether user can receive opportunities\n}\n\n/// Fairness algorithm configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FairnessConfig {\n    pub rotation_interval_minutes: u32, // How often to rotate in round-robin\n    pub max_opportunities_per_user_per_hour: u32,\n    pub max_opportunities_per_user_per_day: u32,\n    pub tier_multipliers: std::collections::HashMap\u003cString, f64\u003e, // Subscription tier multipliers\n    pub activity_boost_factor: f64, // Boost for active users\n    pub cooldown_period_minutes: u32, // Minimum time between opportunities for same user\n}\n\nimpl Default for FairnessConfig {\n    fn default() -\u003e Self {\n        let mut tier_multipliers = std::collections::HashMap::new();\n        tier_multipliers.insert(\"Free\".to_string(), 1.0);\n        tier_multipliers.insert(\"Basic\".to_string(), 1.5);\n        tier_multipliers.insert(\"Premium\".to_string(), 2.0);\n        tier_multipliers.insert(\"Enterprise\".to_string(), 3.0);\n        \n        Self {\n            rotation_interval_minutes: 15,\n            max_opportunities_per_user_per_hour: 10,\n            max_opportunities_per_user_per_day: 50,\n            tier_multipliers,\n            activity_boost_factor: 1.2,\n            cooldown_period_minutes: 5,\n        }\n    }\n}\n\n/// Global opportunity detection configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GlobalOpportunityConfig {\n    pub detection_interval_seconds: u32,\n    pub min_threshold: f64,\n    pub max_threshold: f64,\n    pub max_queue_size: u32,\n    pub opportunity_ttl_minutes: u32, // Time to live for opportunities\n    pub distribution_strategy: DistributionStrategy,\n    pub fairness_config: FairnessConfig,\n    pub monitored_exchanges: Vec\u003cExchangeIdEnum\u003e,\n    pub monitored_pairs: Vec\u003cString\u003e,\n}\n\nimpl Default for GlobalOpportunityConfig {\n    fn default() -\u003e Self {\n        Self {\n            detection_interval_seconds: 30,\n            min_threshold: 0.0005, // 0.05% minimum rate difference\n            max_threshold: 0.02, // 2% maximum rate difference (avoid unrealistic opportunities)\n            max_queue_size: 100,\n            opportunity_ttl_minutes: 10,\n            distribution_strategy: DistributionStrategy::RoundRobin,\n            fairness_config: FairnessConfig::default(),\n            monitored_exchanges: vec![ExchangeIdEnum::Binance, ExchangeIdEnum::Bybit],\n            monitored_pairs: vec![\"BTCUSDT\".to_string(), \"ETHUSDT\".to_string()],\n        }\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":2}},{"line":436,"address":[],"length":0,"stats":{"Line":2}},{"line":437,"address":[],"length":0,"stats":{"Line":2}},{"line":468,"address":[],"length":0,"stats":{"Line":4}},{"line":476,"address":[],"length":0,"stats":{"Line":4}},{"line":477,"address":[],"length":0,"stats":{"Line":4}},{"line":478,"address":[],"length":0,"stats":{"Line":4}},{"line":484,"address":[],"length":0,"stats":{"Line":4}},{"line":512,"address":[],"length":0,"stats":{"Line":4}},{"line":520,"address":[],"length":0,"stats":{"Line":4}},{"line":522,"address":[],"length":0,"stats":{"Line":4}},{"line":524,"address":[],"length":0,"stats":{"Line":4}},{"line":525,"address":[],"length":0,"stats":{"Line":4}},{"line":527,"address":[],"length":0,"stats":{"Line":4}},{"line":533,"address":[],"length":0,"stats":{"Line":5}},{"line":540,"address":[],"length":0,"stats":{"Line":5}},{"line":547,"address":[],"length":0,"stats":{"Line":5}},{"line":549,"address":[],"length":0,"stats":{"Line":5}},{"line":553,"address":[],"length":0,"stats":{"Line":3}},{"line":554,"address":[],"length":0,"stats":{"Line":3}},{"line":557,"address":[],"length":0,"stats":{"Line":1}},{"line":558,"address":[],"length":0,"stats":{"Line":2}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":2}},{"line":599,"address":[],"length":0,"stats":{"Line":2}},{"line":600,"address":[],"length":0,"stats":{"Line":2}},{"line":606,"address":[],"length":0,"stats":{"Line":2}},{"line":607,"address":[],"length":0,"stats":{"Line":2}},{"line":608,"address":[],"length":0,"stats":{"Line":2}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":2}},{"line":626,"address":[],"length":0,"stats":{"Line":5}},{"line":627,"address":[],"length":0,"stats":{"Line":2}},{"line":628,"address":[],"length":0,"stats":{"Line":2}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":5}},{"line":649,"address":[],"length":0,"stats":{"Line":5}},{"line":651,"address":[],"length":0,"stats":{"Line":15}},{"line":652,"address":[],"length":0,"stats":{"Line":10}},{"line":653,"address":[],"length":0,"stats":{"Line":10}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":5}},{"line":663,"address":[],"length":0,"stats":{"Line":5}},{"line":666,"address":[],"length":0,"stats":{"Line":2}},{"line":667,"address":[],"length":0,"stats":{"Line":6}},{"line":686,"address":[],"length":0,"stats":{"Line":2}},{"line":687,"address":[],"length":0,"stats":{"Line":2}},{"line":688,"address":[],"length":0,"stats":{"Line":2}},{"line":690,"address":[],"length":0,"stats":{"Line":3}},{"line":691,"address":[],"length":0,"stats":{"Line":1}},{"line":706,"address":[],"length":0,"stats":{"Line":6}},{"line":707,"address":[],"length":0,"stats":{"Line":6}},{"line":709,"address":[],"length":0,"stats":{"Line":6}},{"line":710,"address":[],"length":0,"stats":{"Line":13}},{"line":711,"address":[],"length":0,"stats":{"Line":18}},{"line":714,"address":[],"length":0,"stats":{"Line":3}},{"line":715,"address":[],"length":0,"stats":{"Line":3}},{"line":716,"address":[],"length":0,"stats":{"Line":2}},{"line":717,"address":[],"length":0,"stats":{"Line":2}},{"line":719,"address":[],"length":0,"stats":{"Line":1}},{"line":750,"address":[],"length":0,"stats":{"Line":1}},{"line":751,"address":[],"length":0,"stats":{"Line":1}},{"line":752,"address":[],"length":0,"stats":{"Line":1}},{"line":759,"address":[],"length":0,"stats":{"Line":1}},{"line":765,"address":[],"length":0,"stats":{"Line":1}},{"line":766,"address":[],"length":0,"stats":{"Line":1}},{"line":767,"address":[],"length":0,"stats":{"Line":1}},{"line":770,"address":[],"length":0,"stats":{"Line":0}},{"line":771,"address":[],"length":0,"stats":{"Line":0}},{"line":772,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":6}},{"line":845,"address":[],"length":0,"stats":{"Line":6}},{"line":846,"address":[],"length":0,"stats":{"Line":6}},{"line":847,"address":[],"length":0,"stats":{"Line":6}},{"line":848,"address":[],"length":0,"stats":{"Line":6}},{"line":849,"address":[],"length":0,"stats":{"Line":6}},{"line":877,"address":[],"length":0,"stats":{"Line":0}},{"line":885,"address":[],"length":0,"stats":{"Line":0}},{"line":886,"address":[],"length":0,"stats":{"Line":0}},{"line":887,"address":[],"length":0,"stats":{"Line":0}}],"covered":69,"coverable":124},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","utils","calculations.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","utils","error.rs"],"content":"// src/utils/error.rs\n\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fmt;\n\npub type ArbitrageResult\u003cT\u003e = Result\u003cT, ArbitrageError\u003e;\n\n/// Custom error details for additional context\npub type ErrorDetails = HashMap\u003cString, serde_json::Value\u003e;\n\n/// Main error type for the arbitrage application\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ArbitrageError {\n    pub message: String,\n    pub details: Option\u003cErrorDetails\u003e,\n    pub status: Option\u003cu16\u003e,\n    pub error_code: Option\u003cString\u003e,\n    pub method: Option\u003cString\u003e,\n    pub kind: ErrorKind,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum ErrorKind {\n    NetworkError,\n    ApiError,\n    ValidationError,\n    NotFound,\n    Authentication,\n    Authorization,\n    RateLimit,\n    ExchangeError,\n    ParseError,\n    ConfigError,\n    DatabaseError,\n    TelegramError,\n    NotImplemented,\n    Serialization,\n    Internal,\n    Storage,\n}\n\nimpl fmt::Display for ArbitrageError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.message)\n    }\n}\n\nimpl std::error::Error for ArbitrageError {}\n\nimpl ArbitrageError {\n    pub fn new(kind: ErrorKind, message: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            message: message.into(),\n            details: None,\n            status: None,\n            error_code: None,\n            method: None,\n            kind,\n        }\n    }\n\n    pub fn with_details(mut self, details: ErrorDetails) -\u003e Self {\n        self.details = Some(details);\n        self\n    }\n\n    pub fn with_status(mut self, status: u16) -\u003e Self {\n        self.status = Some(status);\n        self\n    }\n\n    pub fn with_code(mut self, error_code: impl Into\u003cString\u003e) -\u003e Self {\n        self.error_code = Some(error_code.into());\n        self\n    }\n\n    pub fn with_method(mut self, method: impl Into\u003cString\u003e) -\u003e Self {\n        self.method = Some(method.into());\n        self\n    }\n\n    // Convenience constructors for common error types\n    pub fn network_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::NetworkError, message)\n            .with_status(503)\n            .with_code(\"NETWORK_ERROR\")\n    }\n\n    pub fn api_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::ApiError, message)\n            .with_status(500)\n            .with_code(\"API_ERROR\")\n    }\n\n    pub fn validation_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::ValidationError, message)\n            .with_status(400)\n            .with_code(\"VALIDATION_ERROR\")\n    }\n\n    pub fn not_found(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::NotFound, message)\n            .with_status(404)\n            .with_code(\"NOT_FOUND\")\n    }\n\n    pub fn authentication_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::Authentication, message)\n            .with_status(401)\n            .with_code(\"AUTH_ERROR\")\n    }\n\n    pub fn authorization_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::Authorization, message)\n            .with_status(403)\n            .with_code(\"AUTH_Z_ERROR\")\n    }\n\n    pub fn rate_limit_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::RateLimit, message)\n            .with_status(429)\n            .with_code(\"RATE_LIMIT\")\n    }\n\n    pub fn exchange_error(exchange: \u0026str, message: impl Into\u003cString\u003e) -\u003e Self {\n        let mut details = ErrorDetails::new();\n        details.insert(\n            \"exchange\".to_string(),\n            serde_json::Value::String(exchange.to_string()),\n        );\n\n        Self::new(ErrorKind::ExchangeError, message)\n            .with_details(details)\n            .with_status(502)\n            .with_code(\"EXCHANGE_ERROR\")\n    }\n\n    pub fn parse_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::ParseError, message)\n            .with_status(400)\n            .with_code(\"PARSE_ERROR\")\n    }\n\n    pub fn config_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::ConfigError, message)\n            .with_status(500)\n            .with_code(\"CONFIG_ERROR\")\n    }\n\n    pub fn database_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::DatabaseError, message)\n            .with_status(500)\n            .with_code(\"DATABASE_ERROR\")\n    }\n\n    pub fn telegram_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::TelegramError, message)\n            .with_status(502)\n            .with_code(\"TELEGRAM_ERROR\")\n    }\n\n    pub fn internal_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::Internal, message)\n            .with_status(500)\n            .with_code(\"INTERNAL_ERROR\")\n    }\n\n    pub fn not_implemented(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::NotImplemented, message)\n            .with_status(501)\n            .with_code(\"NOT_IMPLEMENTED\")\n    }\n\n    pub fn serialization_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::Serialization, message)\n            .with_status(400)\n            .with_code(\"SERIALIZATION_ERROR\")\n    }\n\n    pub fn storage_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::Storage, message)\n    }\n}\n\n// Implement From conversions for common error types\nimpl From\u003cserde_json::Error\u003e for ArbitrageError {\n    fn from(err: serde_json::Error) -\u003e Self {\n        ArbitrageError::parse_error(format!(\"JSON parsing error: {}\", err))\n    }\n}\n\nimpl From\u003cworker::Error\u003e for ArbitrageError {\n    fn from(err: worker::Error) -\u003e Self {\n        ArbitrageError::internal_error(format!(\"Worker error: {:?}\", err))\n    }\n}\n\nimpl From\u003cworker::kv::KvError\u003e for ArbitrageError {\n    fn from(err: worker::kv::KvError) -\u003e Self {\n        ArbitrageError::database_error(format!(\"KV store error: {:?}\", err))\n    }\n}\n\n// Helper macro for creating errors with context\n#[macro_export]\nmacro_rules! arbitrage_error {\n    ($kind:expr, $msg:expr) =\u003e {\n        ArbitrageError::new($kind, $msg)\n    };\n    ($kind:expr, $msg:expr, $($key:expr =\u003e $value:expr),+) =\u003e {{\n        let mut details = std::collections::HashMap::new();\n        $(\n            details.insert($key.to_string(), serde_json::json!($value));\n        )+\n        ArbitrageError::new($kind, $msg).with_details(details)\n    }};\n}\n","traces":[{"line":45,"address":[],"length":0,"stats":{"Line":7}},{"line":46,"address":[],"length":0,"stats":{"Line":7}},{"line":53,"address":[],"length":0,"stats":{"Line":8}},{"line":55,"address":[],"length":0,"stats":{"Line":8}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":8}},{"line":70,"address":[],"length":0,"stats":{"Line":8}},{"line":71,"address":[],"length":0,"stats":{"Line":8}},{"line":74,"address":[],"length":0,"stats":{"Line":8}},{"line":75,"address":[],"length":0,"stats":{"Line":8}},{"line":76,"address":[],"length":0,"stats":{"Line":8}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":92,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":147,"address":[],"length":0,"stats":{"Line":2}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}}],"covered":22,"coverable":59},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","utils","formatter.rs"],"content":"// src/utils/formatter.rs\n\nuse crate::types::{ArbitrageOpportunity, ArbitrageType, ExchangeIdEnum};\n#[cfg(not(test))]\nuse chrono::{DateTime, Utc};\n\n/// Escape MarkdownV2 characters for Telegram\n/// See: https://core.telegram.org/bots/api#markdownv2-style\npub fn escape_markdown_v2(text: \u0026str) -\u003e String {\n    // Characters to escape: _ * [ ] ( ) ~ ` \u003e # + - = | { } . !\n    let chars_to_escape = [\n        '_', '*', '[', ']', '(', ')', '~', '`', '\u003e', '#', '+', '-', '=', '|', '{', '}', '.', '!',\n    ];\n\n    text.chars()\n        .map(|c| {\n            if chars_to_escape.contains(\u0026c) {\n                format!(\"\\\\{}\", c)\n            } else {\n                c.to_string()\n            }\n        })\n        .collect()\n}\n\n/// Format an optional value with fallback to \"N/A\"\npub fn format_optional\u003cT: std::fmt::Display\u003e(value: \u0026Option\u003cT\u003e) -\u003e String {\n    match value {\n        Some(v) =\u003e escape_markdown_v2(\u0026v.to_string()),\n        None =\u003e escape_markdown_v2(\"N/A\"),\n    }\n}\n\n/// Format a percentage value\npub fn format_percentage(value: f64) -\u003e String {\n    format!(\"{:.4}\", value * 100.0)\n}\n\n/// Format an optional percentage value\npub fn format_optional_percentage(value: \u0026Option\u003cf64\u003e) -\u003e String {\n    match value {\n        Some(v) =\u003e escape_markdown_v2(\u0026format_percentage(*v)),\n        None =\u003e escape_markdown_v2(\"N/A\"),\n    }\n}\n\n/// Format timestamp to readable string\npub fn format_timestamp(timestamp: u64) -\u003e String {\n    #[cfg(test)]\n    {\n        // In test environment, just return a simple formatted string\n        format!(\"2022-01-01 00:00:00 UTC ({})\", timestamp)\n    }\n    #[cfg(not(test))]\n    {\n        let datetime =\n            DateTime::from_timestamp_millis(timestamp as i64).unwrap_or_else(Utc::now);\n        datetime.format(\"%Y-%m-%d %H:%M:%S UTC\").to_string()\n    }\n}\n\n/// Format exchange name for display\npub fn format_exchange(exchange: \u0026Option\u003cExchangeIdEnum\u003e) -\u003e String {\n    match exchange {\n        Some(exchange) =\u003e exchange.to_string(),\n        None =\u003e \"N/A\".to_string(),\n    }\n}\n\n/// Format monetary value\npub fn format_money(value: \u0026Option\u003cf64\u003e) -\u003e String {\n    match value {\n        Some(v) =\u003e escape_markdown_v2(\u0026format!(\"{:.2}\", v)),\n        None =\u003e escape_markdown_v2(\"N/A\"),\n    }\n}\n\n/// Format an ArbitrageOpportunity into a MarkdownV2 string for Telegram\npub fn format_opportunity_message(opportunity: \u0026ArbitrageOpportunity) -\u003e String {\n    // Extract and format values\n    let pair_escaped = escape_markdown_v2(\u0026opportunity.pair);\n    let long_exchange_escaped = format_exchange(\u0026opportunity.long_exchange);\n    let short_exchange_escaped = format_exchange(\u0026opportunity.short_exchange);\n    let long_rate_escaped = format_optional_percentage(\u0026opportunity.long_rate);\n    let short_rate_escaped = format_optional_percentage(\u0026opportunity.short_rate);\n    let diff_escaped = escape_markdown_v2(\u0026format_percentage(opportunity.rate_difference));\n    let net_diff_escaped = format_optional_percentage(\u0026opportunity.net_rate_difference);\n    let potential_profit_escaped = format_money(\u0026opportunity.potential_profit_value);\n    let date_escaped = escape_markdown_v2(\u0026format_timestamp(opportunity.timestamp));\n    let details_escaped = opportunity\n        .details\n        .as_ref()\n        .map(|d| escape_markdown_v2(d))\n        .unwrap_or_default();\n\n    // Build the message using MarkdownV2 syntax\n    let mut message = format!(\n        \" *Arbitrage Opportunity Detected* \\n\\n *Pair:* `{}`\",\n        pair_escaped\n    );\n\n    // Format based on opportunity type\n    match opportunity.r#type {\n        ArbitrageType::FundingRate\n            if opportunity.long_exchange.is_some() \u0026\u0026 opportunity.short_exchange.is_some() =\u003e\n        {\n            message.push_str(\u0026format!(\n                \"\\n *Action:* LONG `{}` / SHORT `{}`\\n\\n*Rates \\\\(Funding\\\\):*\\n   \\\\- Long \\\\({}\\\\): `{}%`\\n   \\\\- Short \\\\({}\\\\): `{}%`\\n *Gross Difference:* `{}%`\",\n                long_exchange_escaped,\n                short_exchange_escaped,\n                long_exchange_escaped,\n                long_rate_escaped,\n                short_exchange_escaped,\n                short_rate_escaped,\n                diff_escaped\n            ));\n        }\n        _ =\u003e {\n            // Generic message for other types or if specific fields are missing\n            let type_str = match opportunity.r#type {\n                ArbitrageType::FundingRate =\u003e \"Funding Rate\",\n                ArbitrageType::SpotFutures =\u003e \"Spot Futures\",\n                ArbitrageType::CrossExchange =\u003e \"Cross Exchange\",\n            };\n            message.push_str(\u0026format!(\n                \"\\n *Type:* {}\\n *Gross Metric:* `{}%`\",\n                escape_markdown_v2(type_str),\n                diff_escaped\n            ));\n\n            if opportunity.long_exchange.is_some() {\n                message.push_str(\u0026format!(\"\\n *Exchange 1:* `{}`\", long_exchange_escaped));\n            }\n            if opportunity.short_exchange.is_some() {\n                message.push_str(\u0026format!(\"\\n *Exchange 2:* `{}`\", short_exchange_escaped));\n            }\n        }\n    }\n\n    // Add net difference if available\n    if opportunity.net_rate_difference.is_some() \u0026\u0026 net_diff_escaped != escape_markdown_v2(\"N/A\") {\n        message.push_str(\u0026format!(\"\\n *Net Difference:* `{}%`\", net_diff_escaped));\n    }\n\n    // Add potential profit if available\n    if opportunity.potential_profit_value.is_some()\n        \u0026\u0026 potential_profit_escaped != escape_markdown_v2(\"N/A\")\n    {\n        message.push_str(\u0026format!(\n            \"\\n *Potential Profit:* \\\\~${}\",\n            potential_profit_escaped\n        ));\n    }\n\n    // Add details if available\n    if !details_escaped.is_empty() {\n        message.push_str(\u0026format!(\"\\n *Details:* {}\", details_escaped));\n    }\n\n    // Add timestamp\n    message.push_str(\u0026format!(\"\\n *Timestamp:* {}\", date_escaped));\n\n    message\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::{ArbitrageOpportunity, ArbitrageType, ExchangeIdEnum};\n\n    #[test]\n    fn test_escape_markdown_v2() {\n        assert_eq!(escape_markdown_v2(\"test_string\"), \"test\\\\_string\");\n        assert_eq!(escape_markdown_v2(\"test*bold*\"), \"test\\\\*bold\\\\*\");\n        assert_eq!(escape_markdown_v2(\"test-dash\"), \"test\\\\-dash\");\n    }\n\n    #[test]\n    fn test_format_percentage() {\n        assert_eq!(format_percentage(0.1234), \"12.3400\");\n        assert_eq!(format_percentage(0.0001), \"0.0100\");\n    }\n\n    #[test]\n    #[ignore] // Skip this test for now due to WASM binding issues in test environment\n    fn test_format_opportunity_message() {\n        let mut opportunity = ArbitrageOpportunity::new(\n            \"BTC/USDT\".to_string(),\n            Some(ExchangeIdEnum::Binance),\n            Some(ExchangeIdEnum::Bybit),\n            Some(0.0001),\n            Some(-0.0005),\n            0.0006,\n            ArbitrageType::FundingRate,\n        );\n\n        // Set a fixed timestamp to avoid WASM binding issues in tests\n        opportunity.timestamp = 1640995200000; // 2022-01-01 00:00:00 UTC\n\n        let message = format_opportunity_message(\u0026opportunity);\n        assert!(message.contains(\"BTC/USDT\"));\n        assert!(message.contains(\"binance\"));\n        assert!(message.contains(\"bybit\"));\n        assert!(message.contains(\"Funding\"));\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":6}},{"line":11,"address":[],"length":0,"stats":{"Line":6}},{"line":12,"address":[],"length":0,"stats":{"Line":6}},{"line":15,"address":[],"length":0,"stats":{"Line":6}},{"line":16,"address":[],"length":0,"stats":{"Line":93}},{"line":17,"address":[],"length":0,"stats":{"Line":87}},{"line":18,"address":[],"length":0,"stats":{"Line":26}},{"line":20,"address":[],"length":0,"stats":{"Line":61}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}}],"covered":10,"coverable":76},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","utils","helpers.rs"],"content":"use serde_json::Value;\n\n/// Safely parses a value to a floating-point number.\n/// If parsing fails or results in NaN, returns a default value.\npub fn safe_parse_float(value: \u0026Value, default_value: f64) -\u003e f64 {\n    match value {\n        Value::Null =\u003e default_value,\n        Value::Number(n) =\u003e n.as_f64().unwrap_or(default_value),\n        Value::String(s) =\u003e {\n            if s.trim().is_empty() {\n                default_value\n            } else {\n                s.parse::\u003cf64\u003e().unwrap_or(default_value)\n            }\n        }\n        Value::Bool(b) =\u003e {\n            if *b {\n                1.0\n            } else {\n                0.0\n            }\n        }\n        _ =\u003e default_value,\n    }\n}\n\n/// Safely parses a string to a floating-point number.\npub fn safe_parse_float_str(value: \u0026str, default_value: f64) -\u003e f64 {\n    if value.trim().is_empty() {\n        return default_value;\n    }\n\n    value.parse::\u003cf64\u003e().unwrap_or(default_value)\n}\n\n/// Safely parses an optional string to a floating-point number.\npub fn safe_parse_float_opt(value: Option\u003c\u0026str\u003e, default_value: f64) -\u003e f64 {\n    match value {\n        Some(s) =\u003e safe_parse_float_str(s, default_value),\n        None =\u003e default_value,\n    }\n}\n\n/// Performs a deep clone of a JSON-serializable value.\n/// This is equivalent to JSON.parse(JSON.stringify()) in JavaScript.\npub fn deep_clone\u003cT\u003e(value: \u0026T) -\u003e Result\u003cT, serde_json::Error\u003e\nwhere\n    T: serde::Serialize + for\u003c'de\u003e serde::Deserialize\u003c'de\u003e,\n{\n    let json_str = serde_json::to_string(value)?;\n    serde_json::from_str(\u0026json_str)\n}\n\n/// Clamps a value between a minimum and maximum\npub fn clamp\u003cT: PartialOrd\u003e(value: T, min: T, max: T) -\u003e T {\n    if value \u003c min {\n        min\n    } else if value \u003e max {\n        max\n    } else {\n        value\n    }\n}\n\n/// Rounds a float to a specified number of decimal places\npub fn round_to_decimal_places(value: f64, decimal_places: u32) -\u003e f64 {\n    let multiplier = 10_f64.powi(decimal_places as i32);\n    (value * multiplier).round() / multiplier\n}\n\n/// Converts a percentage string (e.g., \"1.5%\") to a decimal\npub fn percentage_to_decimal(percentage_str: \u0026str) -\u003e Result\u003cf64, String\u003e {\n    let cleaned = percentage_str.trim().trim_end_matches('%');\n    cleaned\n        .parse::\u003cf64\u003e()\n        .map(|p| p / 100.0)\n        .map_err(|_| format!(\"Invalid percentage format: {}\", percentage_str))\n}\n\n/// Converts a decimal to a percentage string\npub fn decimal_to_percentage(decimal: f64, decimal_places: u32) -\u003e String {\n    format!(\n        \"{:.prec$}%\",\n        decimal * 100.0,\n        prec = decimal_places as usize\n    )\n}\n\n/// Checks if a float is approximately equal to another within a tolerance\npub fn approximately_equal(a: f64, b: f64, tolerance: f64) -\u003e bool {\n    (a - b).abs() \u003c tolerance\n}\n\n/// Calculates the absolute percentage difference between two values\n/// Returns None when one value is zero and the other is not (undefined percentage)\npub fn percentage_difference(value1: f64, value2: f64) -\u003e Option\u003cf64\u003e {\n    if value1 == 0.0 \u0026\u0026 value2 == 0.0 {\n        Some(0.0)\n    } else if value1 == 0.0 || value2 == 0.0 {\n        None // Undefined percentage difference when one value is zero\n    } else {\n        Some(((value1 - value2).abs() / ((value1 + value2) / 2.0)) * 100.0)\n    }\n}\n\n/// Validates that a value is within a specific range\npub fn validate_range\u003cT: PartialOrd + std::fmt::Display\u003e(\n    value: T,\n    min: T,\n    max: T,\n    field_name: \u0026str,\n) -\u003e Result\u003cT, String\u003e {\n    if value \u003c min || value \u003e max {\n        Err(format!(\n            \"{} must be between {} and {}, got {}\",\n            field_name, min, max, value\n        ))\n    } else {\n        Ok(value)\n    }\n}\n\n/// Calculates the moving average of a slice of values\npub fn moving_average(values: \u0026[f64], window_size: usize) -\u003e Vec\u003cf64\u003e {\n    if window_size == 0 || values.is_empty() {\n        return Vec::new();\n    }\n\n    let mut result = Vec::new();\n    for i in 0..values.len() {\n        let start = (i + 1).saturating_sub(window_size);\n        let end = i + 1;\n        let window = \u0026values[start..end];\n        let avg = window.iter().sum::\u003cf64\u003e() / window.len() as f64;\n        result.push(avg);\n    }\n    result\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn test_safe_parse_float() {\n        assert_eq!(safe_parse_float(\u0026json!(42.5), 0.0), 42.5);\n        assert_eq!(safe_parse_float(\u0026json!(\"123.45\"), 0.0), 123.45);\n        assert_eq!(safe_parse_float(\u0026json!(null), 10.0), 10.0);\n        assert_eq!(safe_parse_float(\u0026json!(\"\"), 5.0), 5.0);\n        assert_eq!(safe_parse_float(\u0026json!(\"invalid\"), 7.0), 7.0);\n        assert_eq!(safe_parse_float(\u0026json!(true), 0.0), 1.0);\n        assert_eq!(safe_parse_float(\u0026json!(false), 0.0), 0.0);\n    }\n\n    #[test]\n    fn test_safe_parse_float_str() {\n        assert_eq!(safe_parse_float_str(\"123.45\", 0.0), 123.45);\n        assert_eq!(safe_parse_float_str(\"\", 10.0), 10.0);\n        assert_eq!(safe_parse_float_str(\"  \", 5.0), 5.0);\n        assert_eq!(safe_parse_float_str(\"invalid\", 7.0), 7.0);\n    }\n\n    #[test]\n    fn test_clamp() {\n        assert_eq!(clamp(5, 1, 10), 5);\n        assert_eq!(clamp(0, 1, 10), 1);\n        assert_eq!(clamp(15, 1, 10), 10);\n    }\n\n    #[test]\n    fn test_round_to_decimal_places() {\n        let pi_2_decimal = round_to_decimal_places(std::f64::consts::PI, 2);\n        let pi_4_decimal = round_to_decimal_places(std::f64::consts::PI, 4);\n        \n        // Test that the function works correctly by checking the rounded values\n        // Compute expected values to avoid hardcoded PI approximations\n        let expected_2_decimal = (std::f64::consts::PI * 100.0).round() / 100.0;\n        let expected_4_decimal = (std::f64::consts::PI * 10000.0).round() / 10000.0;\n        \n        assert_eq!(pi_2_decimal, expected_2_decimal);\n        assert_eq!(pi_4_decimal, expected_4_decimal);\n        \n        // Also test with a simple known value\n        assert_eq!(round_to_decimal_places(2.56789, 2), 2.57);\n        assert_eq!(round_to_decimal_places(2.56789, 3), 2.568);\n    }\n\n    #[test]\n    fn test_percentage_to_decimal() {\n        assert_eq!(percentage_to_decimal(\"50%\").unwrap(), 0.5);\n        assert_eq!(percentage_to_decimal(\"1.5%\").unwrap(), 0.015);\n        assert_eq!(percentage_to_decimal(\"100\").unwrap(), 1.0);\n        assert!(percentage_to_decimal(\"invalid%\").is_err());\n    }\n\n    #[test]\n    fn test_decimal_to_percentage() {\n        assert_eq!(decimal_to_percentage(0.5, 1), \"50.0%\");\n        assert_eq!(decimal_to_percentage(0.015, 3), \"1.500%\");\n    }\n\n    #[test]\n    fn test_approximately_equal() {\n        assert!(approximately_equal(1.0, 1.001, 0.01));\n        assert!(!approximately_equal(1.0, 1.1, 0.01));\n    }\n\n    #[test]\n    fn test_percentage_difference() {\n        let expected = 200.0 * 10.0 / 190.0; // ~10.526315789473685\n        let actual = percentage_difference(100.0, 90.0).unwrap();\n        assert!(approximately_equal(actual, expected, 1e-10));\n        assert_eq!(percentage_difference(0.0, 0.0), Some(0.0));\n        assert_eq!(percentage_difference(100.0, 0.0), None);\n        assert_eq!(percentage_difference(0.0, 100.0), None);\n    }\n\n    #[test]\n    fn test_validate_range() {\n        assert_eq!(validate_range(5, 1, 10, \"test\").unwrap(), 5);\n        assert!(validate_range(0, 1, 10, \"test\").is_err());\n        assert!(validate_range(15, 1, 10, \"test\").is_err());\n    }\n\n    #[test]\n    fn test_moving_average() {\n        let values = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n        let result = moving_average(\u0026values, 3);\n        assert_eq!(result.len(), 5);\n        assert_eq!(result[0], 1.0); // [1] avg = 1\n        assert_eq!(result[1], 1.5); // [1,2] avg = 1.5\n        assert_eq!(result[2], 2.0); // [1,2,3] avg = 2\n        assert_eq!(result[3], 3.0); // [2,3,4] avg = 3\n        assert_eq!(result[4], 4.0); // [3,4,5] avg = 4\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":7}},{"line":6,"address":[],"length":0,"stats":{"Line":7}},{"line":7,"address":[],"length":0,"stats":{"Line":1}},{"line":8,"address":[],"length":0,"stats":{"Line":1}},{"line":9,"address":[],"length":0,"stats":{"Line":3}},{"line":10,"address":[],"length":0,"stats":{"Line":3}},{"line":11,"address":[],"length":0,"stats":{"Line":1}},{"line":13,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":2}},{"line":18,"address":[],"length":0,"stats":{"Line":1}},{"line":20,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":4}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":3}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":4}},{"line":67,"address":[],"length":0,"stats":{"Line":4}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":72,"address":[],"length":0,"stats":{"Line":4}},{"line":73,"address":[],"length":0,"stats":{"Line":4}},{"line":74,"address":[],"length":0,"stats":{"Line":4}},{"line":76,"address":[],"length":0,"stats":{"Line":11}},{"line":77,"address":[],"length":0,"stats":{"Line":9}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":82,"address":[],"length":0,"stats":{"Line":2}},{"line":84,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":90,"address":[],"length":0,"stats":{"Line":3}},{"line":91,"address":[],"length":0,"stats":{"Line":3}},{"line":96,"address":[],"length":0,"stats":{"Line":4}},{"line":97,"address":[],"length":0,"stats":{"Line":6}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":99,"address":[],"length":0,"stats":{"Line":5}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":3}},{"line":113,"address":[],"length":0,"stats":{"Line":5}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":1}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[],"length":0,"stats":{"Line":5}}],"covered":52,"coverable":61},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","utils","logger.rs"],"content":"// src/utils/logger.rs\n\nuse serde_json::{json, Value};\nuse std::collections::HashMap;\nuse std::sync::OnceLock;\nuse worker::console_log;\n\n/// Log levels supported by the logger\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]\npub enum LogLevel {\n    Error = 0,\n    Warn = 1,\n    Info = 2,\n    Debug = 3,\n}\n\nimpl LogLevel {\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            LogLevel::Error =\u003e \"ERROR\",\n            LogLevel::Warn =\u003e \"WARN\",\n            LogLevel::Info =\u003e \"INFO\",\n            LogLevel::Debug =\u003e \"DEBUG\",\n        }\n    }\n\n    pub fn from_str(s: \u0026str) -\u003e LogLevel {\n        match s.to_lowercase().as_str() {\n            \"error\" =\u003e LogLevel::Error,\n            \"warn\" | \"warning\" =\u003e LogLevel::Warn,\n            \"info\" =\u003e LogLevel::Info,\n            \"debug\" =\u003e LogLevel::Debug,\n            _ =\u003e LogLevel::Info, // default\n        }\n    }\n}\n\n/// Simple logger for Cloudflare Workers\npub struct Logger {\n    level: LogLevel,\n    context: HashMap\u003cString, Value\u003e,\n}\n\nimpl Logger {\n    pub fn new(level: LogLevel) -\u003e Self {\n        Self {\n            level,\n            context: HashMap::new(),\n        }\n    }\n\n    pub fn from_env() -\u003e Self {\n        // Try to get log level from environment, default to Info\n        let level_str = std::env::var(\"LOG_LEVEL\").unwrap_or_else(|_| \"info\".to_string());\n        Self::new(LogLevel::from_str(\u0026level_str))\n    }\n\n    pub fn set_level(\u0026mut self, level: LogLevel) {\n        self.level = level;\n    }\n\n    pub fn get_level(\u0026self) -\u003e \u0026LogLevel {\n        \u0026self.level\n    }\n\n    pub fn add_context(\u0026mut self, key: \u0026str, value: Value) {\n        self.context.insert(key.to_string(), value);\n    }\n\n    pub fn child(\u0026self, context: HashMap\u003cString, Value\u003e) -\u003e Self {\n        let mut new_context = self.context.clone();\n        new_context.extend(context);\n\n        Self {\n            level: self.level.clone(),\n            context: new_context,\n        }\n    }\n\n    fn should_log(\u0026self, level: \u0026LogLevel) -\u003e bool {\n        level \u003c= \u0026self.level\n    }\n\n    fn format_message(\u0026self, level: \u0026LogLevel, message: \u0026str, meta: Option\u003c\u0026Value\u003e) -\u003e String {\n        let timestamp = chrono::Utc::now().format(\"%Y-%m-%d %H:%M:%S%.3f UTC\");\n\n        let mut log_obj = serde_json::json!({\n            \"timestamp\": timestamp.to_string(),\n            \"level\": level.as_str(),\n            \"message\": message,\n        });\n\n        // Add context\n        if !self.context.is_empty() {\n            log_obj[\"context\"] = serde_json::Value::Object(\n                self.context\n                    .iter()\n                    .map(|(k, v)| (k.clone(), v.clone()))\n                    .collect(),\n            );\n        }\n\n        // Add metadata if provided\n        if let Some(meta) = meta {\n            log_obj[\"meta\"] = meta.clone();\n        }\n\n        serde_json::to_string(\u0026log_obj)\n            .unwrap_or_else(|_| format!(\"[{}] {}: {}\", timestamp, level.as_str(), message))\n    }\n\n    pub fn error(\u0026self, message: \u0026str) {\n        self.error_with_meta(message, None);\n    }\n\n    pub fn error_with_meta(\u0026self, message: \u0026str, meta: Option\u003c\u0026Value\u003e) {\n        if self.should_log(\u0026LogLevel::Error) {\n            let formatted = self.format_message(\u0026LogLevel::Error, message, meta);\n            console_log!(\"{}\", formatted);\n        }\n    }\n\n    pub fn warn(\u0026self, message: \u0026str) {\n        self.warn_with_meta(message, None);\n    }\n\n    pub fn warn_with_meta(\u0026self, message: \u0026str, meta: Option\u003c\u0026Value\u003e) {\n        if self.should_log(\u0026LogLevel::Warn) {\n            let formatted = self.format_message(\u0026LogLevel::Warn, message, meta);\n            console_log!(\"{}\", formatted);\n        }\n    }\n\n    pub fn info(\u0026self, message: \u0026str) {\n        self.info_with_meta(message, None);\n    }\n\n    pub fn info_with_meta(\u0026self, message: \u0026str, meta: Option\u003c\u0026Value\u003e) {\n        if self.should_log(\u0026LogLevel::Info) {\n            let formatted = self.format_message(\u0026LogLevel::Info, message, meta);\n            console_log!(\"{}\", formatted);\n        }\n    }\n\n    pub fn debug(\u0026self, message: \u0026str) {\n        self.debug_with_meta(message, None);\n    }\n\n    pub fn debug_with_meta(\u0026self, message: \u0026str, meta: Option\u003c\u0026Value\u003e) {\n        if self.should_log(\u0026LogLevel::Debug) {\n            let formatted = self.format_message(\u0026LogLevel::Debug, message, meta);\n            console_log!(\"{}\", formatted);\n        }\n    }\n\n    pub fn add_error(\u0026self, error: \u0026dyn std::error::Error, context: Option\u003c\u0026Value\u003e) {\n        let error_meta = serde_json::json!({\n            \"error\": error.to_string(),\n            \"error_type\": std::any::type_name_of_val(error),\n        });\n\n        let combined_meta = match context {\n            Some(ctx) =\u003e {\n                let mut combined = ctx.clone();\n                if let Value::Object(ref mut map) = combined {\n                    if let Value::Object(error_map) = error_meta {\n                        map.extend(error_map);\n                    }\n                }\n                combined\n            }\n            None =\u003e error_meta,\n        };\n\n        self.error_with_meta(\"An error occurred\", Some(\u0026combined_meta));\n    }\n}\n\n/// Global logger instance - thread-safe singleton\nstatic GLOBAL_LOGGER: OnceLock\u003cLogger\u003e = OnceLock::new();\n\n/// Initialize the global logger\npub fn init_logger(level: LogLevel) {\n    GLOBAL_LOGGER.set(Logger::new(level)).ok();\n}\n\n/// Get a reference to the global logger\npub fn logger() -\u003e \u0026'static Logger {\n    GLOBAL_LOGGER.get_or_init(|| Logger::from_env())\n}\n\n/// Convenience macros for logging\n#[macro_export]\nmacro_rules! log_error {\n    ($msg:expr) =\u003e {\n        $crate::utils::logger::logger().error($msg)\n    };\n    ($msg:expr, $meta:expr) =\u003e {\n        $crate::utils::logger::logger().error_with_meta($msg, Some(\u0026$meta))\n    };\n}\n\n#[macro_export]\nmacro_rules! log_warn {\n    ($msg:expr) =\u003e {\n        $crate::utils::logger::logger().warn($msg)\n    };\n    ($msg:expr, $meta:expr) =\u003e {\n        $crate::utils::logger::logger().warn_with_meta($msg, Some(\u0026$meta))\n    };\n}\n\n#[macro_export]\nmacro_rules! log_info {\n    ($msg:expr) =\u003e {\n        $crate::utils::logger::logger().info($msg)\n    };\n    ($msg:expr, $meta:expr) =\u003e {\n        $crate::utils::logger::logger().info_with_meta($msg, Some(\u0026$meta))\n    };\n}\n\n#[macro_export]\nmacro_rules! log_debug {\n    ($msg:expr) =\u003e {\n        $crate::utils::logger::logger().debug($msg)\n    };\n    ($msg:expr, $meta:expr) =\u003e {\n        $crate::utils::logger::logger().debug_with_meta($msg, Some(\u0026$meta))\n    };\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_log_level_ordering() {\n        assert!(LogLevel::Error \u003c LogLevel::Warn);\n        assert!(LogLevel::Warn \u003c LogLevel::Info);\n        assert!(LogLevel::Info \u003c LogLevel::Debug);\n    }\n\n    #[test]\n    fn test_log_level_from_str() {\n        assert_eq!(LogLevel::from_str(\"error\"), LogLevel::Error);\n        assert_eq!(LogLevel::from_str(\"WARN\"), LogLevel::Warn);\n        assert_eq!(LogLevel::from_str(\"info\"), LogLevel::Info);\n        assert_eq!(LogLevel::from_str(\"debug\"), LogLevel::Debug);\n        assert_eq!(LogLevel::from_str(\"invalid\"), LogLevel::Info);\n    }\n\n    #[test]\n    fn test_logger_should_log() {\n        let logger = Logger::new(LogLevel::Warn);\n        assert!(logger.should_log(\u0026LogLevel::Error));\n        assert!(logger.should_log(\u0026LogLevel::Warn));\n        assert!(!logger.should_log(\u0026LogLevel::Info));\n        assert!(!logger.should_log(\u0026LogLevel::Debug));\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":5}},{"line":28,"address":[],"length":0,"stats":{"Line":5}},{"line":29,"address":[],"length":0,"stats":{"Line":6}},{"line":30,"address":[],"length":0,"stats":{"Line":8}},{"line":31,"address":[],"length":0,"stats":{"Line":4}},{"line":32,"address":[],"length":0,"stats":{"Line":3}},{"line":33,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}}],"covered":11,"coverable":87},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","utils","mod.rs"],"content":"// src/utils/mod.rs\n\npub mod calculations;\npub mod error;\npub mod formatter;\npub mod helpers;\npub mod logger;\n\n// Re-export commonly used items\npub use error::{ArbitrageError, ArbitrageResult};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","tests","integration_tests.rs"],"content":"use serde_json::json;\nuse std::collections::HashMap;\nuse chrono::Utc;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_basic_functionality() {\n        // Basic test to verify the module compiles and runs\n        assert_eq!(2 + 2, 4);\n    }\n\n    #[test]\n    fn test_json_serialization() {\n        // Test JSON handling that will be used in endpoints\n        let test_data = json!({\n            \"trading_pair\": \"BTCUSDT\",\n            \"exchange_a\": \"binance\",\n            \"exchange_b\": \"bybit\",\n            \"quantity\": 0.01,\n            \"funding_rate_diff\": 0.05\n        });\n\n        assert_eq!(test_data[\"trading_pair\"], \"BTCUSDT\");\n        assert_eq!(test_data[\"exchange_a\"], \"binance\");\n        assert_eq!(test_data[\"quantity\"], 0.01);\n    }\n\n    #[test]\n    fn test_query_parameter_parsing() {\n        // Test URL query parameter handling\n        let query_string = \"exchange=binance\u0026symbol=BTCUSDT\u0026limit=100\";\n        let query_pairs: HashMap\u003cString, String\u003e = query_string\n            .split('\u0026')\n            .filter_map(|pair| {\n                let mut split = pair.split('=');\n                let key = split.next()?;\n                let value = split.next()?;\n                Some((key.to_string(), value.to_string()))\n            })\n            .collect();\n\n        assert_eq!(query_pairs.get(\"exchange\"), Some(\u0026\"binance\".to_string()));\n        assert_eq!(query_pairs.get(\"symbol\"), Some(\u0026\"BTCUSDT\".to_string()));\n        assert_eq!(query_pairs.get(\"limit\"), Some(\u0026\"100\".to_string()));\n    }\n\n    #[test]\n    fn test_http_method_routing() {\n        // Test the logic for HTTP method and path matching\n        let routes = vec![\n            (\"GET\", \"/health\"),\n            (\"GET\", \"/exchange/markets\"),\n            (\"GET\", \"/exchange/ticker\"),\n            (\"GET\", \"/exchange/funding\"),\n            (\"POST\", \"/find-opportunities\"),\n            (\"POST\", \"/webhook\"),\n            (\"POST\", \"/positions\"),\n            (\"GET\", \"/positions\"),\n            (\"PUT\", \"/positions/123\"),\n            (\"DELETE\", \"/positions/123\"),\n        ];\n\n        for (method, path) in routes {\n            match (method, path) {\n                (\"GET\", \"/health\") =\u003e {\n                    // Health endpoint should be GET - this is correct\n                }\n                (\"POST\", \"/find-opportunities\") =\u003e {\n                    // Find opportunities should be POST - this is correct\n                }\n                (\"POST\", \"/webhook\") =\u003e {\n                    // Webhook should be POST - this is correct\n                }\n                (\"POST\", \"/positions\") =\u003e {\n                    // Create position should be POST - this is correct\n                }\n                (\"GET\", \"/positions\") =\u003e {\n                    // Get positions should be GET - this is correct\n                }\n                (_, path) if path.starts_with(\"/positions/\") =\u003e {\n                    assert!([\"GET\", \"PUT\", \"DELETE\"].contains(\u0026method), \n                           \"Position operations should be GET, PUT, or DELETE\");\n                }\n                (_, path) if path.starts_with(\"/exchange/\") =\u003e {\n                    assert_eq!(method, \"GET\", \"Exchange endpoints should be GET\");\n                }\n                _ =\u003e {}\n            }\n        }\n    }\n\n    #[test]\n    fn test_error_response_format() {\n        // Test error response formatting\n        let error_msg = \"Failed to process request\";\n        let status_code = 500;\n        \n        let error_response = json!({\n            \"error\": error_msg,\n            \"status\": status_code,\n            \"timestamp\": chrono::Utc::now().to_rfc3339()\n        });\n\n        assert_eq!(error_response[\"error\"], error_msg);\n        assert_eq!(error_response[\"status\"], status_code);\n        assert!(error_response[\"timestamp\"].is_string());\n    }\n\n    #[test]\n    fn test_opportunity_data_structure() {\n        // Test the structure of opportunity data\n        let opportunity = json!({\n            \"trading_pair\": \"BTCUSDT\",\n            \"exchange_a\": \"binance\",\n            \"exchange_b\": \"bybit\",\n            \"funding_rate_a\": 0.01,\n            \"funding_rate_b\": -0.01,\n            \"funding_rate_diff\": 0.02,\n            \"potential_profit\": 120.50,\n            \"timestamp\": chrono::Utc::now().to_rfc3339()\n        });\n\n        // Verify all required fields are present\n        assert!(opportunity[\"trading_pair\"].is_string());\n        assert!(opportunity[\"exchange_a\"].is_string());\n        assert!(opportunity[\"exchange_b\"].is_string());\n        assert!(opportunity[\"funding_rate_a\"].is_number());\n        assert!(opportunity[\"funding_rate_b\"].is_number());\n        assert!(opportunity[\"funding_rate_diff\"].is_number());\n        assert!(opportunity[\"potential_profit\"].is_number());\n        assert!(opportunity[\"timestamp\"].is_string());\n    }\n\n    #[test]\n    fn test_position_data_structure() {\n        // Test the structure of position data\n        let position = json!({\n            \"id\": \"pos_123456\",\n            \"trading_pair\": \"BTCUSDT\",\n            \"exchange_a\": \"binance\",\n            \"exchange_b\": \"bybit\",\n            \"quantity\": 0.01,\n            \"entry_funding_rate_diff\": 0.02,\n            \"current_funding_rate_diff\": 0.015,\n            \"status\": \"open\",\n            \"profit_loss\": 0.0,\n            \"created_at\": chrono::Utc::now().to_rfc3339(),\n            \"updated_at\": chrono::Utc::now().to_rfc3339()\n        });\n\n        // Verify all required fields are present\n        assert!(position[\"id\"].is_string());\n        assert!(position[\"trading_pair\"].is_string());\n        assert!(position[\"exchange_a\"].is_string());\n        assert!(position[\"exchange_b\"].is_string());\n        assert!(position[\"quantity\"].is_number());\n        assert!(position[\"status\"].is_string());\n        assert!(position[\"created_at\"].is_string());\n    }\n\n    #[test]\n    fn test_telegram_webhook_data() {\n        // Test Telegram webhook message structure\n        let webhook_data = json!({\n            \"update_id\": 123456789,\n            \"message\": {\n                \"message_id\": 1,\n                \"from\": {\n                    \"id\": 987654321,\n                    \"first_name\": \"Test\",\n                    \"username\": \"testuser\"\n                },\n                \"chat\": {\n                    \"id\": 987654321,\n                    \"type\": \"private\"\n                },\n                \"date\": 1640995200,\n                \"text\": \"/start\"\n            }\n        });\n\n        assert!(webhook_data[\"update_id\"].is_number());\n        assert!(webhook_data[\"message\"][\"text\"].is_string());\n        assert!(webhook_data[\"message\"][\"chat\"][\"id\"].is_number());\n    }\n\n    #[test]\n    fn test_exchange_configuration() {\n        // Test exchange configuration parsing\n        let exchanges_config = \"binance,bybit,okx,bitget\";\n        let exchanges: Vec\u003c\u0026str\u003e = exchanges_config.split(',').collect();\n        \n        assert!(exchanges.contains(\u0026\"binance\"));\n        assert!(exchanges.contains(\u0026\"bybit\"));\n        assert!(exchanges.contains(\u0026\"okx\"));\n        assert!(exchanges.contains(\u0026\"bitget\"));\n        assert_eq!(exchanges.len(), 4);\n    }\n\n    #[test]\n    fn test_funding_rate_calculations() {\n        // Test funding rate difference calculations\n        let rate_a = 0.01; // 1%\n        let rate_b = -0.01; // -1%\n        let diff = rate_a - rate_b;\n        let percentage_diff = diff * 100.0;\n        \n        assert_eq!(diff, 0.02);\n        assert_eq!(percentage_diff, 2.0);\n        \n        // Test minimum threshold\n        let min_threshold = 0.015; // 1.5%\n        assert!(diff \u003e min_threshold, \"Difference should exceed minimum threshold\");\n    }\n\n    #[test]\n    fn test_profit_calculations() {\n        // Test potential profit calculations\n        let funding_rate_diff = 0.02; // 2%\n        let position_size = 1000.0; // $1000\n        let holding_period_hours = 8.0; // 8 hours\n        let annualized_hours = 365.0 * 24.0; // Hours in a year\n        \n        let potential_profit = (funding_rate_diff * position_size * holding_period_hours) / annualized_hours;\n        \n        assert!(potential_profit \u003e 0.0);\n        assert!(potential_profit \u003c position_size); // Profit should be reasonable\n    }\n\n    #[test]\n    fn test_environment_variable_parsing() {\n        // Test environment variable parsing logic\n        let mock_env_vars = HashMap::from([\n            (\"EXCHANGES\".to_string(), \"binance,bybit\".to_string()),\n            (\"MIN_FUNDING_RATE_DIFF\".to_string(), \"0.01\".to_string()),\n            (\"TELEGRAM_BOT_TOKEN\".to_string(), \"123456:ABC-DEF\".to_string()),\n            (\"CHAT_ID\".to_string(), \"987654321\".to_string()),\n        ]);\n\n        // Test exchanges parsing\n        let exchanges = mock_env_vars.get(\"EXCHANGES\").unwrap();\n        let exchange_list: Vec\u003c\u0026str\u003e = exchanges.split(',').collect();\n        assert_eq!(exchange_list.len(), 2);\n\n        // Test numeric parsing\n        let min_diff: f64 = mock_env_vars.get(\"MIN_FUNDING_RATE_DIFF\")\n            .unwrap()\n            .parse()\n            .unwrap();\n        assert_eq!(min_diff, 0.01);\n\n        // Test chat ID parsing\n        let chat_id: i64 = mock_env_vars.get(\"CHAT_ID\")\n            .unwrap()\n            .parse()\n            .unwrap();\n        assert_eq!(chat_id, 987654321);\n    }\n\n    #[test]\n    fn test_scheduled_event_timing() {\n        // Test cron expression validation for scheduled events\n        let cron_expressions = vec![\n            \"* * * * *\",     // Every minute\n            \"*/5 * * * *\",   // Every 5 minutes\n            \"0 * * * *\",     // Every hour\n            \"0 0 * * *\",     // Every day\n        ];\n\n        for cron in cron_expressions {\n            assert!(!cron.is_empty(), \"Cron expression should not be empty\");\n            assert!(cron.contains('*'), \"Cron expression should contain asterisks\");\n            let parts: Vec\u003c\u0026str\u003e = cron.split_whitespace().collect();\n            assert_eq!(parts.len(), 5, \"Cron expression should have 5 parts\");\n        }\n    }\n\n    #[test]\n    fn test_api_response_structure() {\n        // Test standardized API response structure\n        let success_response = json!({\n            \"success\": true,\n            \"data\": {\n                \"message\": \"Operation completed successfully\"\n            },\n            \"timestamp\": chrono::Utc::now().to_rfc3339()\n        });\n\n        let error_response = json!({\n            \"success\": false,\n            \"error\": {\n                \"message\": \"Operation failed\",\n                \"code\": \"INTERNAL_ERROR\"\n            },\n            \"timestamp\": chrono::Utc::now().to_rfc3339()\n        });\n\n        assert_eq!(success_response[\"success\"], true);\n        assert_eq!(error_response[\"success\"], false);\n        assert!(success_response[\"timestamp\"].is_string());\n        assert!(error_response[\"timestamp\"].is_string());\n    }\n} ","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","lib.rs"],"content":"use worker::*;\n\n// Module declarations\nmod services;\nmod types;\nmod utils;\n\nuse serde_json::json;\nuse services::exchange::{ExchangeInterface, ExchangeService};\nuse services::opportunity::{OpportunityService, OpportunityServiceConfig};\nuse services::positions::{CreatePositionData, PositionsService, UpdatePositionData};\nuse services::telegram::TelegramService;\nuse std::sync::Arc;\nuse types::{ExchangeIdEnum, StructuredTradingPair};\nuse utils::{ArbitrageError, ArbitrageResult};\nuse std::collections::HashMap;\nuse uuid::Uuid;\n\n#[event(fetch)]\npub async fn main(req: Request, env: Env, _ctx: Context) -\u003e Result\u003cResponse\u003e {\n    console_error_panic_hook::set_once();\n\n    let url = req.url()?;\n    let path = url.path();\n\n    match (req.method(), path) {\n        // Health check\n        (Method::Get, \"/health\") =\u003e {\n            Response::ok(\"ArbEdge Rust Worker is running!\")\n        }\n\n        // KV test endpoint\n        (Method::Get, \"/kv-test\") =\u003e {\n            let value = url.query().unwrap_or(\"default\");\n            let kv = env.kv(\"ArbEdgeKV\")?;\n            kv.put(\"test-key\", value)?.execute().await?;\n            let retrieved = kv.get(\"test-key\").text().await?;\n            Response::ok(retrieved.unwrap_or_default())\n        }\n\n        // Exchange API endpoints\n        (Method::Get, \"/exchange/markets\") =\u003e {\n            handle_get_markets(req, env).await\n        }\n\n        (Method::Get, \"/exchange/ticker\") =\u003e {\n            handle_get_ticker(req, env).await\n        }\n\n        (Method::Get, \"/exchange/funding\") =\u003e {\n            handle_funding_rate(req, env).await\n        }\n\n        // Opportunity finding endpoint\n        (Method::Post, \"/find-opportunities\") =\u003e {\n            handle_find_opportunities(req, env).await\n        }\n\n        // Telegram webhook endpoint\n        (Method::Post, \"/webhook\") =\u003e {\n            handle_telegram_webhook(req, env).await\n        }\n\n        // Position management endpoints\n        (Method::Post, \"/positions\") =\u003e {\n            handle_create_position(req, env).await\n        }\n\n        (Method::Get, \"/positions\") =\u003e {\n            handle_get_all_positions(req, env).await\n        }\n\n        (Method::Get, path) if path.starts_with(\"/positions/\") =\u003e {\n            let id = path.strip_prefix(\"/positions/\").unwrap();\n            // Validate UUID format\n            if Uuid::parse_str(id).is_err() {\n                return Response::error(\"Invalid position ID format. Must be a valid UUID.\", 400);\n            }\n            handle_get_position(req, env, id).await\n        }\n\n        (Method::Put, path) if path.starts_with(\"/positions/\") =\u003e {\n            let id = path.strip_prefix(\"/positions/\").unwrap();\n            // Validate UUID format\n            if Uuid::parse_str(id).is_err() {\n                return Response::error(\"Invalid position ID format. Must be a valid UUID.\", 400);\n            }\n            handle_update_position(req, env, id).await\n        }\n\n        (Method::Delete, path) if path.starts_with(\"/positions/\") =\u003e {\n            let id = path.strip_prefix(\"/positions/\").unwrap();\n            // Validate UUID format\n            if Uuid::parse_str(id).is_err() {\n                return Response::error(\"Invalid position ID format. Must be a valid UUID.\", 400);\n            }\n            handle_close_position(req, env, id).await\n        }\n\n        // Default response\n        _ =\u003e Response::ok(\"Hello, ArbEdge in Rust! Available endpoints: /health, /kv-test, /exchange/*, /find-opportunities, /webhook, /positions\"),\n    }\n}\n\n#[event(scheduled)]\npub async fn scheduled(event: ScheduledEvent, env: Env, _ctx: ScheduleContext) {\n    console_error_panic_hook::set_once();\n\n    match event.cron().as_str() {\n        // Monitor opportunities every minute\n        \"* * * * *\" =\u003e {\n            if let Err(e) = monitor_opportunities_scheduled(env).await {\n                console_log!(\"Error in scheduled opportunity monitoring: {}\", e);\n            }\n        }\n        _ =\u003e {\n            console_log!(\"Unknown scheduled event: {}\", event.cron());\n        }\n    }\n}\n\n// Helper functions to reduce code duplication\n\n/// Parse exchanges from environment string, returning error if less than two\nfn parse_exchanges_from_env(exchanges_str: \u0026str) -\u003e std::result::Result\u003cVec\u003cExchangeIdEnum\u003e, ArbitrageError\u003e {\n    let exchanges: Vec\u003cExchangeIdEnum\u003e = exchanges_str\n        .split(',')\n        .filter_map(|s| match s.trim() {\n            \"binance\" =\u003e Some(ExchangeIdEnum::Binance),\n            \"bybit\" =\u003e Some(ExchangeIdEnum::Bybit),\n            \"okx\" =\u003e Some(ExchangeIdEnum::OKX),\n            \"bitget\" =\u003e Some(ExchangeIdEnum::Bitget),\n            _ =\u003e None,\n        })\n        .collect();\n\n    if exchanges.len() \u003c 2 {\n        Err(ArbitrageError::config_error(\"At least two exchanges must be configured\"))\n    } else {\n        Ok(exchanges)\n    }\n}\n\n/// Create OpportunityService by reading environment variables and initializing services\nasync fn create_opportunity_service(custom_env: \u0026types::Env) -\u003e ArbitrageResult\u003cOpportunityService\u003e {\n    // Parse configuration from environment\n    let exchanges_str = custom_env.worker_env.var(\"EXCHANGES\")?.to_string();\n    let exchanges = parse_exchanges_from_env(\u0026exchanges_str)?;\n\n    let monitored_pairs_str = custom_env.worker_env.var(\"MONITORED_PAIRS_CONFIG\")?.to_string();\n    let monitored_pairs: Vec\u003cStructuredTradingPair\u003e =\n        serde_json::from_str(\u0026monitored_pairs_str).map_err(|e| {\n            ArbitrageError::parse_error(format!(\"Failed to parse monitored pairs: {}\", e))\n        })?;\n\n    let threshold: f64 = custom_env.worker_env\n        .var(\"ARBITRAGE_THRESHOLD\")\n        .map(|v| v.to_string())\n        .unwrap_or_else(|_| \"0.001\".to_string())\n        .parse()\n        .unwrap_or(0.001);\n\n    // Create services\n    let exchange_service = Arc::new(ExchangeService::new(custom_env)?);\n\n    let telegram_service = if let (Ok(bot_token), Ok(chat_id)) =\n        (custom_env.worker_env.var(\"TELEGRAM_BOT_TOKEN\"), custom_env.worker_env.var(\"TELEGRAM_CHAT_ID\"))\n    {\n        Some(Arc::new(TelegramService::new(\n            services::telegram::TelegramConfig {\n                bot_token: bot_token.to_string(),\n                chat_id: chat_id.to_string(),\n            },\n        )))\n    } else {\n        None\n    };\n\n    let opportunity_config = OpportunityServiceConfig {\n        exchanges,\n        monitored_pairs,\n        threshold,\n    };\n\n    Ok(OpportunityService::new(opportunity_config, exchange_service, telegram_service))\n}\n\n// Handler implementations\n\nasync fn handle_get_markets(req: Request, env: Env) -\u003e Result\u003cResponse\u003e {\n    let custom_env = types::Env::new(env);\n    let exchange_service = match ExchangeService::new(\u0026custom_env) {\n        Ok(service) =\u003e service,\n        Err(e) =\u003e return Response::error(format!(\"Failed to create exchange service: {}\", e), 500),\n    };\n\n    let url = req.url()?;\n    let exchange_id = url\n        .query_pairs()\n        .find(|(key, _)| key == \"exchange\")\n        .map(|(_, value)| value.to_string())\n        .unwrap_or_else(|| \"binance\".to_string());\n\n    match exchange_service.get_markets(\u0026exchange_id).await {\n        Ok(markets) =\u003e {\n            let market_count = markets.len();\n            let sample_markets: Vec\u003c_\u003e = markets.into_iter().take(5).collect();\n            let response = json!({\n                \"exchange\": exchange_id,\n                \"total_markets\": market_count,\n                \"sample_markets\": sample_markets\n            });\n            Response::from_json(\u0026response)\n        }\n        Err(e) =\u003e Response::error(format!(\"Failed to get markets: {}\", e), 500),\n    }\n}\n\nasync fn handle_get_ticker(req: Request, env: Env) -\u003e Result\u003cResponse\u003e {\n    let custom_env = types::Env::new(env);\n    let exchange_service = match ExchangeService::new(\u0026custom_env) {\n        Ok(service) =\u003e service,\n        Err(e) =\u003e return Response::error(format!(\"Failed to create exchange service: {}\", e), 500),\n    };\n\n    let url = req.url()?;\n    let query_pairs: std::collections::HashMap\u003cString, String\u003e = url\n        .query_pairs()\n        .map(|(k, v)| (k.to_string(), v.to_string()))\n        .collect();\n\n    let exchange_id = query_pairs\n        .get(\"exchange\")\n        .cloned()\n        .unwrap_or_else(|| \"binance\".to_string());\n    let symbol = query_pairs\n        .get(\"symbol\")\n        .cloned()\n        .unwrap_or_else(|| \"BTCUSDT\".to_string());\n\n    match exchange_service.get_ticker(\u0026exchange_id, \u0026symbol).await {\n        Ok(ticker) =\u003e Response::from_json(\u0026ticker),\n        Err(e) =\u003e Response::error(format!(\"Failed to get ticker: {}\", e), 500),\n    }\n}\n\nasync fn handle_funding_rate(req: Request, env: Env) -\u003e Result\u003cResponse\u003e {\n    let url = req.url()?;\n    let query_params: HashMap\u003cString, String\u003e = url.query_pairs().into_owned().collect();\n    \n    let exchange_id = query_params.get(\"exchange\").unwrap_or(\u0026\"binance\".to_string()).clone();\n    let symbol = query_params.get(\"symbol\").unwrap_or(\u0026\"BTCUSDT\".to_string()).clone();\n    \n    let custom_env = types::Env::new(env);\n    let exchange_service = match ExchangeService::new(\u0026custom_env) {\n        Ok(service) =\u003e service,\n        Err(e) =\u003e return Response::error(format!(\"Failed to create exchange service: {}\", e), 500),\n    };\n    \n    match exchange_service\n        .fetch_funding_rates(\u0026exchange_id, Some(\u0026symbol))\n        .await\n    {\n        Ok(rates) =\u003e Response::from_json(\u0026rates),\n        Err(e) =\u003e Response::error(format!(\"Failed to fetch funding rate: {}\", e), 500),\n    }\n}\n\nasync fn handle_find_opportunities(mut req: Request, env: Env) -\u003e Result\u003cResponse\u003e {\n    // Create custom env first \n    let custom_env = types::Env::new(env);\n    \n    // Parse request body for trading pairs (optional)\n    let request_data: serde_json::Value = match req.json().await {\n        Ok(data) =\u003e data,\n        Err(_) =\u003e {\n            // Default trading pairs if no body provided\n            json!({\n                \"trading_pairs\": [\"BTCUSDT\", \"ETHUSDT\", \"ADAUSDT\", \"DOTUSDT\", \"SOLUSDT\"],\n                \"min_threshold\": 0.01\n            })\n        }\n    };\n\n    let _trading_pairs: Vec\u003cString\u003e = request_data[\"trading_pairs\"]\n        .as_array()\n        .unwrap_or(\u0026vec![])\n        .iter()\n        .filter_map(|v| v.as_str().map(|s| s.to_string()))\n        .collect();\n\n    let _min_threshold = request_data[\"min_threshold\"]\n        .as_f64()\n        .unwrap_or(0.01);\n\n    // Create opportunity service using helper\n    let opportunity_service = match create_opportunity_service(\u0026custom_env).await {\n        Ok(service) =\u003e service,\n        Err(e) =\u003e return Response::error(format!(\"Failed to create opportunity service: {}\", e), 500),\n    };\n\n    // Find opportunities\n    match opportunity_service.monitor_opportunities().await {\n        Ok(opportunities) =\u003e {\n            // Process opportunities (send notifications)\n            if let Err(e) = opportunity_service\n                .process_opportunities(\u0026opportunities)\n                .await\n            {\n                console_log!(\"Failed to process opportunities: {}\", e);\n            }\n\n            let response = json!({\n                \"status\": \"success\",\n                \"opportunities_found\": opportunities.len(),\n                \"opportunities\": opportunities\n            });\n            Response::from_json(\u0026response)\n        }\n        Err(e) =\u003e Response::error(format!(\"Failed to find opportunities: {}\", e), 500),\n    }\n}\n\nasync fn handle_telegram_webhook(mut req: Request, env: Env) -\u003e Result\u003cResponse\u003e {\n    let update: serde_json::Value = req.json().await?;\n\n    let telegram_service = if let (Ok(bot_token), Ok(chat_id)) =\n        (env.var(\"TELEGRAM_BOT_TOKEN\"), env.var(\"TELEGRAM_CHAT_ID\"))\n    {\n        TelegramService::new(services::telegram::TelegramConfig {\n            bot_token: bot_token.to_string(),\n            chat_id: chat_id.to_string(),\n        })\n    } else {\n        return Response::error(\"Telegram configuration not found\", 500);\n    };\n\n    match telegram_service.handle_webhook(update).await {\n        Ok(Some(response_text)) =\u003e Response::ok(response_text),\n        Ok(None) =\u003e Response::ok(\"OK\"),\n        Err(e) =\u003e Response::error(format!(\"Webhook processing error: {}\", e), 500),\n    }\n}\n\nasync fn handle_create_position(mut req: Request, env: Env) -\u003e Result\u003cResponse\u003e {\n    let kv = env.kv(\"ArbEdgeKV\")?;\n    let positions_service = PositionsService::new(kv);\n\n    let position_data: CreatePositionData = req.json().await?;\n\n    match positions_service.create_position(position_data).await {\n        Ok(position) =\u003e Response::from_json(\u0026position),\n        Err(e) =\u003e Response::error(format!(\"Failed to create position: {}\", e), 500),\n    }\n}\n\nasync fn handle_get_all_positions(_req: Request, env: Env) -\u003e Result\u003cResponse\u003e {\n    let kv = env.kv(\"ArbEdgeKV\")?;\n    let positions_service = PositionsService::new(kv);\n\n    match positions_service.get_all_positions().await {\n        Ok(positions) =\u003e Response::from_json(\u0026positions),\n        Err(e) =\u003e Response::error(format!(\"Failed to get positions: {}\", e), 500),\n    }\n}\n\nasync fn handle_get_position(_req: Request, env: Env, id: \u0026str) -\u003e Result\u003cResponse\u003e {\n    let kv = env.kv(\"ArbEdgeKV\")?;\n    let positions_service = PositionsService::new(kv);\n\n    match positions_service.get_position(id).await {\n        Ok(Some(position)) =\u003e Response::from_json(\u0026position),\n        Ok(None) =\u003e Response::error(\"Position not found\", 404),\n        Err(e) =\u003e Response::error(format!(\"Failed to get position: {}\", e), 500),\n    }\n}\n\nasync fn handle_update_position(mut req: Request, env: Env, id: \u0026str) -\u003e Result\u003cResponse\u003e {\n    let kv = env.kv(\"ArbEdgeKV\")?;\n    let positions_service = PositionsService::new(kv);\n\n    let update_data: UpdatePositionData = req.json().await?;\n\n    match positions_service.update_position(id, update_data).await {\n        Ok(Some(position)) =\u003e Response::from_json(\u0026position),\n        Ok(None) =\u003e Response::error(\"Position not found\", 404),\n        Err(e) =\u003e Response::error(format!(\"Failed to update position: {}\", e), 500),\n    }\n}\n\nasync fn handle_close_position(_req: Request, env: Env, id: \u0026str) -\u003e Result\u003cResponse\u003e {\n    let kv = env.kv(\"ArbEdgeKV\")?;\n    let positions_service = PositionsService::new(kv);\n\n    match positions_service.close_position(id).await {\n        Ok(true) =\u003e Response::ok(\"Position closed\"),\n        Ok(false) =\u003e Response::error(\"Position not found\", 404),\n        Err(e) =\u003e Response::error(format!(\"Failed to close position: {}\", e), 500),\n    }\n}\n\nasync fn monitor_opportunities_scheduled(env: Env) -\u003e ArbitrageResult\u003c()\u003e {\n    let custom_env = types::Env::new(env);\n    \n    // Create opportunity service using helper\n    let opportunity_service = create_opportunity_service(\u0026custom_env).await?;\n\n    // Find and process opportunities\n    let opportunities = opportunity_service.monitor_opportunities().await?;\n\n    if !opportunities.is_empty() {\n        console_log!(\"Found {} opportunities\", opportunities.len());\n        opportunity_service\n            .process_opportunities(\u0026opportunities)\n            .await?;\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n    use types::ExchangeIdEnum;\n\n    // Tests for parse_exchanges_from_env function\n    #[test]\n    fn test_parse_exchanges_from_env_valid_input() {\n        let exchanges_str = \"binance,bybit,okx\";\n        let result = parse_exchanges_from_env(exchanges_str).unwrap();\n        \n        assert_eq!(result.len(), 3);\n        assert!(result.contains(\u0026ExchangeIdEnum::Binance));\n        assert!(result.contains(\u0026ExchangeIdEnum::Bybit));\n        assert!(result.contains(\u0026ExchangeIdEnum::OKX));\n    }\n\n    #[test]\n    fn test_parse_exchanges_from_env_with_whitespace() {\n        let exchanges_str = \" binance , bybit , okx \";\n        let result = parse_exchanges_from_env(exchanges_str).unwrap();\n        \n        assert_eq!(result.len(), 3);\n        assert!(result.contains(\u0026ExchangeIdEnum::Binance));\n        assert!(result.contains(\u0026ExchangeIdEnum::Bybit));\n        assert!(result.contains(\u0026ExchangeIdEnum::OKX));\n    }\n\n    #[test]\n    fn test_parse_exchanges_from_env_invalid_exchange() {\n        let exchanges_str = \"binance,invalid_exchange,okx\";\n        let result = parse_exchanges_from_env(exchanges_str).unwrap();\n        \n        // Should only contain valid exchanges\n        assert_eq!(result.len(), 2);\n        assert!(result.contains(\u0026ExchangeIdEnum::Binance));\n        assert!(result.contains(\u0026ExchangeIdEnum::OKX));\n    }\n\n    #[test]\n    fn test_parse_exchanges_from_env_insufficient_exchanges() {\n        let exchanges_str = \"binance\";\n        let result = parse_exchanges_from_env(exchanges_str);\n        \n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"At least two exchanges must be configured\"));\n    }\n\n    #[test]\n    fn test_parse_exchanges_from_env_empty_string() {\n        let exchanges_str = \"\";\n        let result = parse_exchanges_from_env(exchanges_str);\n        \n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_parse_exchanges_from_env_all_supported() {\n        let exchanges_str = \"binance,bybit,okx,bitget\";\n        let result = parse_exchanges_from_env(exchanges_str).unwrap();\n        \n        assert_eq!(result.len(), 4);\n        assert!(result.contains(\u0026ExchangeIdEnum::Binance));\n        assert!(result.contains(\u0026ExchangeIdEnum::Bybit));\n        assert!(result.contains(\u0026ExchangeIdEnum::OKX));\n        assert!(result.contains(\u0026ExchangeIdEnum::Bitget));\n    }\n\n    // Tests for route matching logic\n    mod route_tests {\n        use super::*;\n\n        #[test]\n        fn test_health_endpoint_routing() {\n            let method = Method::Get;\n            let path = \"/health\";\n            \n            match (method, path) {\n                (Method::Get, \"/health\") =\u003e {\n                    // This should match the health endpoint\n                    assert!(true, \"Health endpoint route should match\");\n                }\n                _ =\u003e panic!(\"Health endpoint route should match\"),\n            }\n        }\n\n        #[test]\n        fn test_kv_test_endpoint_routing() {\n            let method = Method::Get;\n            let path = \"/kv-test\";\n            \n            match (method, path) {\n                (Method::Get, \"/kv-test\") =\u003e {\n                    assert!(true, \"KV test endpoint route should match\");\n                }\n                _ =\u003e panic!(\"KV test endpoint route should match\"),\n            }\n        }\n\n        #[test]\n        fn test_exchange_endpoints_routing() {\n            let exchange_routes = vec![\n                (Method::Get, \"/exchange/markets\"),\n                (Method::Get, \"/exchange/ticker\"),\n                (Method::Get, \"/exchange/funding\"),\n            ];\n\n            for (method, path) in exchange_routes {\n                match (method, path) {\n                    (Method::Get, \"/exchange/markets\") |\n                    (Method::Get, \"/exchange/ticker\") |\n                    (Method::Get, \"/exchange/funding\") =\u003e {\n                        assert!(true, \"Exchange endpoint should match\");\n                    }\n                    _ =\u003e panic!(\"Exchange endpoint should match for {}\", path),\n                }\n            }\n        }\n\n        #[test]\n        fn test_opportunity_endpoint_routing() {\n            let method = Method::Post;\n            let path = \"/find-opportunities\";\n            \n            match (method, path) {\n                (Method::Post, \"/find-opportunities\") =\u003e {\n                    assert!(true, \"Find opportunities endpoint should match\");\n                }\n                _ =\u003e panic!(\"Find opportunities endpoint should match\"),\n            }\n        }\n\n        #[test]\n        fn test_telegram_webhook_routing() {\n            let method = Method::Post;\n            let path = \"/webhook\";\n            \n            match (method, path) {\n                (Method::Post, \"/webhook\") =\u003e {\n                    assert!(true, \"Telegram webhook endpoint should match\");\n                }\n                _ =\u003e panic!(\"Telegram webhook endpoint should match\"),\n            }\n        }\n\n        #[test]\n        fn test_positions_routing() {\n            let position_routes = vec![\n                (Method::Post, \"/positions\"),\n                (Method::Get, \"/positions\"),\n                (Method::Get, \"/positions/123e4567-e89b-12d3-a456-426614174000\"),\n                (Method::Put, \"/positions/123e4567-e89b-12d3-a456-426614174000\"),\n                (Method::Delete, \"/positions/123e4567-e89b-12d3-a456-426614174000\"),\n            ];\n\n            for (method, path) in position_routes {\n                match (\u0026method, path) {\n                    (Method::Post, \"/positions\") |\n                    (Method::Get, \"/positions\") =\u003e {\n                        assert!(true, \"Positions endpoint should match\");\n                    }\n                    (Method::Get, path) if path.starts_with(\"/positions/\") =\u003e {\n                        let id = path.strip_prefix(\"/positions/\").unwrap();\n                        if Uuid::parse_str(id).is_ok() {\n                            assert!(true, \"GET position by ID should match with valid UUID\");\n                        }\n                    }\n                    (Method::Put, path) if path.starts_with(\"/positions/\") =\u003e {\n                        let id = path.strip_prefix(\"/positions/\").unwrap();\n                        if Uuid::parse_str(id).is_ok() {\n                            assert!(true, \"PUT position by ID should match with valid UUID\");\n                        }\n                    }\n                    (Method::Delete, path) if path.starts_with(\"/positions/\") =\u003e {\n                        let id = path.strip_prefix(\"/positions/\").unwrap();\n                        if Uuid::parse_str(id).is_ok() {\n                            assert!(true, \"DELETE position by ID should match with valid UUID\");\n                        }\n                    }\n                    _ =\u003e {\n                        let method_str = format!(\"{:?}\", method);\n                        panic!(\"Position endpoint should match for {} {}\", method_str, path);\n                    }\n                }\n            }\n        }\n\n        #[test]\n        fn test_uuid_validation_in_position_routes() {\n            let valid_uuid = \"123e4567-e89b-12d3-a456-426614174000\";\n            let invalid_uuid = \"invalid-uuid-format\";\n\n            // Valid UUID should pass validation\n            assert!(Uuid::parse_str(valid_uuid).is_ok());\n\n            // Invalid UUID should fail validation\n            assert!(Uuid::parse_str(invalid_uuid).is_err());\n        }\n\n        #[test]\n        fn test_default_route_fallback() {\n            let unmatched_routes = vec![\n                (Method::Get, \"/unknown\"),\n                (Method::Post, \"/invalid\"),\n                (Method::Put, \"/nonexistent\"),\n            ];\n\n            for (method, path) in unmatched_routes {\n                match (method, path) {\n                    (Method::Get, \"/health\") |\n                    (Method::Get, \"/kv-test\") |\n                    (Method::Get, \"/exchange/markets\") |\n                    (Method::Get, \"/exchange/ticker\") |\n                    (Method::Get, \"/exchange/funding\") |\n                    (Method::Post, \"/find-opportunities\") |\n                    (Method::Post, \"/webhook\") |\n                    (Method::Post, \"/positions\") |\n                    (Method::Get, \"/positions\") =\u003e {\n                        panic!(\"Route should not match known endpoints\");\n                    }\n                    (Method::Get, path) if path.starts_with(\"/positions/\") =\u003e {\n                        panic!(\"Route should not match position endpoints\");\n                    }\n                    (Method::Put, path) if path.starts_with(\"/positions/\") =\u003e {\n                        panic!(\"Route should not match position endpoints\");\n                    }\n                    (Method::Delete, path) if path.starts_with(\"/positions/\") =\u003e {\n                        panic!(\"Route should not match position endpoints\");\n                    }\n                    _ =\u003e {\n                        assert!(true, \"Unknown routes should fall through to default\");\n                    }\n                }\n            }\n        }\n    }\n\n    // Tests for scheduled event handling\n    mod scheduled_tests {\n        #[test]\n        fn test_scheduled_cron_pattern_matching() {\n            let cron_patterns = vec![\n                \"* * * * *\",      // Every minute (should match)\n                \"0 * * * *\",      // Every hour (should not match)\n                \"0 0 * * *\",      // Every day (should not match)\n                \"invalid\",        // Invalid pattern (should not match)\n            ];\n\n            for cron in cron_patterns {\n                match cron {\n                    \"* * * * *\" =\u003e {\n                        assert!(true, \"Every minute cron should be recognized\");\n                    }\n                    _ =\u003e {\n                        assert!(true, \"Other cron patterns should not trigger opportunity monitoring\");\n                    }\n                }\n            }\n        }\n    }\n\n    // Tests for query parameter parsing\n    mod query_parsing_tests {\n        #[test]\n        fn test_exchange_query_parameter_parsing() {\n            // Test default exchange\n            let default_exchange = \"binance\".to_string();\n            assert_eq!(default_exchange, \"binance\");\n\n            // Test explicit exchange parameter\n            let exchange_param = \"bybit\";\n            assert_eq!(exchange_param, \"bybit\");\n        }\n\n        #[test]\n        fn test_symbol_query_parameter_parsing() {\n            // Test default symbol\n            let default_symbol = \"BTCUSDT\".to_string();\n            assert_eq!(default_symbol, \"BTCUSDT\");\n\n            // Test explicit symbol parameter\n            let symbol_param = \"ETHUSDT\";\n            assert_eq!(symbol_param, \"ETHUSDT\");\n        }\n\n        #[test]\n        fn test_query_pairs_collection() {\n            // Simulate query parameter collection\n            let query_params = vec![\n                (\"exchange\".to_string(), \"binance\".to_string()),\n                (\"symbol\".to_string(), \"BTCUSDT\".to_string()),\n                (\"limit\".to_string(), \"100\".to_string()),\n            ];\n\n            let query_map: std::collections::HashMap\u003cString, String\u003e = query_params.into_iter().collect();\n\n            assert_eq!(query_map.get(\"exchange\"), Some(\u0026\"binance\".to_string()));\n            assert_eq!(query_map.get(\"symbol\"), Some(\u0026\"BTCUSDT\".to_string()));\n            assert_eq!(query_map.get(\"limit\"), Some(\u0026\"100\".to_string()));\n        }\n    }\n\n    // Tests for JSON request/response handling\n    mod json_handling_tests {\n        use super::*;\n\n        #[test]\n        fn test_find_opportunities_request_parsing() {\n            // Test default request data when no body provided\n            let default_data = json!({\n                \"trading_pairs\": [\"BTCUSDT\", \"ETHUSDT\", \"ADAUSDT\", \"DOTUSDT\", \"SOLUSDT\"],\n                \"min_threshold\": 0.01\n            });\n\n            assert_eq!(default_data[\"trading_pairs\"].as_array().unwrap().len(), 5);\n            assert_eq!(default_data[\"min_threshold\"].as_f64().unwrap(), 0.01);\n        }\n\n        #[test]\n        fn test_trading_pairs_parsing() {\n            let request_data = json!({\n                \"trading_pairs\": [\"BTCUSDT\", \"ETHUSDT\", \"BNBUSDT\"],\n                \"min_threshold\": 0.02\n            });\n\n            let trading_pairs: Vec\u003cString\u003e = request_data[\"trading_pairs\"]\n                .as_array()\n                .unwrap_or(\u0026vec![])\n                .iter()\n                .filter_map(|v| v.as_str().map(|s| s.to_string()))\n                .collect();\n\n            assert_eq!(trading_pairs.len(), 3);\n            assert!(trading_pairs.contains(\u0026\"BTCUSDT\".to_string()));\n            assert!(trading_pairs.contains(\u0026\"ETHUSDT\".to_string()));\n            assert!(trading_pairs.contains(\u0026\"BNBUSDT\".to_string()));\n        }\n\n        #[test]\n        fn test_min_threshold_parsing() {\n            let request_data = json!({\n                \"trading_pairs\": [\"BTCUSDT\"],\n                \"min_threshold\": 0.05\n            });\n\n            let min_threshold = request_data[\"min_threshold\"]\n                .as_f64()\n                .unwrap_or(0.01);\n\n            assert_eq!(min_threshold, 0.05);\n        }\n\n        #[test]\n        fn test_response_format() {\n            // Test opportunities response format\n            let opportunities_response = json!({\n                \"status\": \"success\",\n                \"opportunities_found\": 2,\n                \"opportunities\": [\n                    {\n                        \"trading_pair\": \"BTCUSDT\",\n                        \"exchange_a\": \"binance\",\n                        \"exchange_b\": \"bybit\",\n                        \"funding_rate_diff\": 0.02\n                    }\n                ]\n            });\n\n            assert_eq!(opportunities_response[\"status\"], \"success\");\n            assert_eq!(opportunities_response[\"opportunities_found\"], 2);\n            assert!(opportunities_response[\"opportunities\"].is_array());\n        }\n\n        #[test]\n        fn test_error_response_format() {\n            let error_message = \"Failed to create exchange service\";\n            let error_response = format!(\"Failed to create exchange service: {}\", error_message);\n            \n            assert!(error_response.contains(\"Failed to create exchange service\"));\n        }\n    }\n\n    // Tests for environment variable handling\n    mod env_tests {\n        #[test]\n        fn test_telegram_config_validation() {\n            // Test when both bot token and chat ID are available\n            let bot_token = \"123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11\";\n            let chat_id = \"-123456789\";\n\n            assert!(!bot_token.is_empty());\n            assert!(!chat_id.is_empty());\n            assert!(bot_token.contains(\":\"));\n            assert!(chat_id.starts_with(\"-\") || chat_id.parse::\u003ci64\u003e().is_ok());\n        }\n\n        #[test]\n        fn test_arbitrage_threshold_parsing() {\n            // Test default threshold\n            let default_threshold = \"0.001\".parse::\u003cf64\u003e().unwrap();\n            assert_eq!(default_threshold, 0.001);\n\n            // Test custom threshold\n            let custom_threshold = \"0.005\".parse::\u003cf64\u003e().unwrap();\n            assert_eq!(custom_threshold, 0.005);\n\n            // Test invalid threshold fallback\n            let invalid_threshold = \"invalid\".parse::\u003cf64\u003e().unwrap_or(0.001);\n            assert_eq!(invalid_threshold, 0.001);\n        }\n\n        #[test]\n        fn test_monitored_pairs_config_parsing() {\n            let pairs_config = r#\"[\n                {\"base\": \"BTC\", \"quote\": \"USDT\", \"type\": \"spot\"},\n                {\"base\": \"ETH\", \"quote\": \"USDT\", \"type\": \"spot\"}\n            ]\"#;\n\n            let parsed: std::result::Result\u003cserde_json::Value, serde_json::Error\u003e = serde_json::from_str(pairs_config);\n            assert!(parsed.is_ok());\n\n            let pairs = parsed.unwrap();\n            assert!(pairs.is_array());\n            assert_eq!(pairs.as_array().unwrap().len(), 2);\n        }\n    }\n\n    // Tests for utility functions used in handlers\n    mod handler_utilities_tests {\n        use super::*;\n\n        #[test]\n        fn test_url_path_extraction() {\n            let path = \"/positions/123e4567-e89b-12d3-a456-426614174000\";\n            let id = path.strip_prefix(\"/positions/\").unwrap();\n            \n            assert_eq!(id, \"123e4567-e89b-12d3-a456-426614174000\");\n            assert!(Uuid::parse_str(id).is_ok());\n        }\n\n        #[test]\n        fn test_invalid_uuid_handling() {\n            let invalid_ids = vec![\n                \"invalid-uuid\",\n                \"123\",\n                \"\",\n                \"not-a-uuid-at-all\",\n                \"123e4567-e89b-12d3-a456\", // Too short\n            ];\n\n            for invalid_id in invalid_ids {\n                assert!(Uuid::parse_str(invalid_id).is_err());\n            }\n        }\n\n        #[test]\n        fn test_valid_uuid_formats() {\n            let valid_ids = vec![\n                \"123e4567-e89b-12d3-a456-426614174000\",\n                \"550e8400-e29b-41d4-a716-446655440000\",\n                \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\",\n            ];\n\n            for valid_id in valid_ids {\n                assert!(Uuid::parse_str(valid_id).is_ok());\n            }\n        }\n\n        #[test]\n        fn test_content_type_handling() {\n            // Test that we expect JSON content type for POST/PUT requests\n            let content_type = \"application/json\";\n            assert_eq!(content_type, \"application/json\");\n        }\n\n        #[test]\n        fn test_http_status_codes() {\n            // Test common status codes used in handlers\n            let success_code = 200;\n            let bad_request_code = 400;\n            let not_found_code = 404;\n            let server_error_code = 500;\n\n            assert_eq!(success_code, 200);\n            assert_eq!(bad_request_code, 400);\n            assert_eq!(not_found_code, 404);\n            assert_eq!(server_error_code, 500);\n        }\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":6}},{"line":126,"address":[],"length":0,"stats":{"Line":6}},{"line":128,"address":[],"length":0,"stats":{"Line":21}},{"line":129,"address":[],"length":0,"stats":{"Line":20}},{"line":130,"address":[],"length":0,"stats":{"Line":13}},{"line":131,"address":[],"length":0,"stats":{"Line":11}},{"line":132,"address":[],"length":0,"stats":{"Line":4}},{"line":133,"address":[],"length":0,"stats":{"Line":2}},{"line":137,"address":[],"length":0,"stats":{"Line":6}},{"line":138,"address":[],"length":0,"stats":{"Line":2}},{"line":140,"address":[],"length":0,"stats":{"Line":4}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}}],"covered":11,"coverable":213},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","services","ai_integration.rs"],"content":"use crate::types::{UserProfile, UserApiKey, ApiKeyProvider};\nuse crate::utils::{ArbitrageError, ArbitrageResult};\nuse reqwest::Client;\nuse serde::{Deserialize, Serialize};\nuse serde_json::{json, Value};\nuse std::collections::HashMap;\nuse worker::console_log;\nuse worker::kv::KvStore;\nuse uuid;\n\n/// Configuration for AI integration service\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AiIntegrationConfig {\n    pub enabled: bool,\n    pub default_timeout_seconds: u64,\n    pub max_retries: u32,\n    pub supported_providers: Vec\u003cApiKeyProvider\u003e,\n    pub max_ai_keys_per_user: u32,\n}\n\nimpl Default for AiIntegrationConfig {\n    fn default() -\u003e Self {\n        Self {\n            enabled: true,\n            default_timeout_seconds: 30,\n            max_retries: 3,\n            max_ai_keys_per_user: 10,\n            supported_providers: vec![\n                ApiKeyProvider::OpenAI,\n                ApiKeyProvider::Anthropic,\n                ApiKeyProvider::Custom,\n            ],\n        }\n    }\n}\n\n/// AI provider interface for different AI services\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum AiProvider {\n    OpenAI {\n        api_key: String,\n        base_url: Option\u003cString\u003e,\n        model: Option\u003cString\u003e,\n    },\n    Anthropic {\n        api_key: String,\n        base_url: Option\u003cString\u003e,\n        model: Option\u003cString\u003e,\n    },\n    Custom {\n        api_key: String,\n        base_url: String,\n        headers: HashMap\u003cString, String\u003e,\n        model: Option\u003cString\u003e,\n    },\n}\n\n/// Request structure for AI analysis\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AiAnalysisRequest {\n    pub prompt: String,\n    pub market_data: Value,\n    pub user_context: Option\u003cValue\u003e,\n    pub max_tokens: Option\u003cu32\u003e,\n    pub temperature: Option\u003cf32\u003e,\n}\n\n/// Response structure from AI analysis\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AiAnalysisResponse {\n    pub analysis: String,\n    pub confidence: Option\u003cf32\u003e,\n    pub recommendations: Vec\u003cString\u003e,\n    pub metadata: HashMap\u003cString, Value\u003e,\n}\n\n/// AI Integration Service for managing user AI configurations\npub struct AiIntegrationService {\n    config: AiIntegrationConfig,\n    http_client: Client,\n    kv_store: KvStore,\n    encryption_key: String,\n}\n\nimpl AiIntegrationService {\n    /// Create new AI integration service\n    pub fn new(config: AiIntegrationConfig, kv_store: KvStore, encryption_key: String) -\u003e Self {\n        Self {\n            config,\n            http_client: Client::new(),\n            kv_store,\n            encryption_key,\n        }\n    }\n\n    /// Store AI credentials for a user\n    pub async fn store_ai_credentials(\n        \u0026self,\n        user_id: \u0026str,\n        provider: ApiKeyProvider,\n        api_key: \u0026str,\n        metadata: Option\u003cValue\u003e,\n    ) -\u003e ArbitrageResult\u003cString\u003e {\n        // Check if user has reached the maximum number of AI keys\n        let existing_keys = self.get_user_ai_keys(user_id).await?;\n        let ai_key_count = existing_keys.iter().filter(|key| key.is_ai_key()).count();\n        \n        if ai_key_count \u003e= self.config.max_ai_keys_per_user as usize {\n            return Err(ArbitrageError::validation_error(\n                \u0026format!(\"Maximum AI keys limit ({}) reached\", self.config.max_ai_keys_per_user)\n            ));\n        }\n\n        // Validate provider is supported\n        if !self.is_provider_supported(\u0026provider) {\n            return Err(ArbitrageError::validation_error(\"AI provider not supported\"));\n        }\n\n        // Encrypt the API key\n        let encrypted_key = self.encrypt_string(api_key)?;\n\n        // Create the UserApiKey\n        let api_key_id = uuid::Uuid::new_v4().to_string();\n        let user_api_key = UserApiKey::new_ai_key(\n            user_id.to_string(),\n            provider,\n            encrypted_key,\n            metadata.unwrap_or(json!({})),\n        );\n\n        // Store the key\n        let key = format!(\"ai_key:{}:{}\", user_id, api_key_id);\n        let serialized = serde_json::to_string(\u0026user_api_key)\n            .map_err(|e| ArbitrageError::parse_error(format!(\"Failed to serialize AI key: {}\", e)))?;\n        \n        self.kv_store.put(\u0026key, \u0026serialized)\n            .map_err(|e| ArbitrageError::storage_error(format!(\"Failed to prepare AI key storage: {}\", e)))?\n            .execute()\n            .await\n            .map_err(|e| ArbitrageError::storage_error(format!(\"Failed to store AI key: {}\", e)))?;\n\n        // Update user's AI key index\n        self.update_user_ai_key_index(user_id, \u0026api_key_id, true).await?;\n\n        Ok(api_key_id)\n    }\n\n    /// Remove AI credentials for a user\n    pub async fn remove_ai_credentials(\n        \u0026self,\n        user_id: \u0026str,\n        api_key_id: \u0026str,\n    ) -\u003e ArbitrageResult\u003cbool\u003e {\n        // Remove from storage\n        let key = format!(\"ai_key:{}:{}\", user_id, api_key_id);\n        self.kv_store.delete(\u0026key)\n            .await\n            .map_err(|e| ArbitrageError::storage_error(format!(\"Failed to delete AI key: {}\", e)))?;\n\n        // Update user's AI key index\n        self.update_user_ai_key_index(user_id, api_key_id, false).await?;\n\n        Ok(true)\n    }\n\n    /// Get all AI credentials for a user\n    pub async fn get_user_ai_keys(\u0026self, user_id: \u0026str) -\u003e ArbitrageResult\u003cVec\u003cUserApiKey\u003e\u003e {\n        let index_key = format!(\"ai_key_index:{}\", user_id);\n        let index_data = self.kv_store.get(\u0026index_key)\n            .text()\n            .await\n            .map_err(|e| ArbitrageError::storage_error(format!(\"Failed to get AI key index: {}\", e)))?;\n\n        let key_ids: Vec\u003cString\u003e = if let Some(data) = index_data {\n            serde_json::from_str(\u0026data)\n                .unwrap_or_default()\n        } else {\n            Vec::new()\n        };\n\n        let mut ai_keys = Vec::new();\n        for key_id in key_ids {\n            let key = format!(\"ai_key:{}:{}\", user_id, key_id);\n            if let Ok(Some(data)) = self.kv_store.get(\u0026key).text().await {\n                if let Ok(api_key) = serde_json::from_str::\u003cUserApiKey\u003e(\u0026data) {\n                    ai_keys.push(api_key);\n                }\n            }\n        }\n\n        Ok(ai_keys)\n    }\n\n    /// Validate and test AI credentials\n    pub async fn validate_and_test_credentials(\n        \u0026self,\n        user_id: \u0026str,\n        api_key_id: \u0026str,\n    ) -\u003e ArbitrageResult\u003cbool\u003e {\n        // Get the AI key\n        let ai_keys = self.get_user_ai_keys(user_id).await?;\n        let ai_key = ai_keys.iter()\n            .find(|key| key.id == api_key_id)\n            .ok_or_else(|| ArbitrageError::not_found(\"AI key not found\"))?;\n\n        // Decrypt the key and create provider\n        let decrypted_key = self.decrypt_string(\u0026ai_key.encrypted_key)?;\n        let provider = self.create_ai_provider_from_key(ai_key, \u0026decrypted_key)?;\n\n        // Test connectivity\n        match self.test_ai_connectivity(\u0026provider).await {\n            Ok(_) =\u003e {\n                // Update last_used timestamp\n                self.update_ai_key_last_used(user_id, api_key_id).await?;\n                Ok(true)\n            }\n            Err(e) =\u003e {\n                // Return validation error with details\n                Err(ArbitrageError::validation_error(\u0026format!(\"AI credentials validation failed: {}\", e)))\n            }\n        }\n    }\n\n    /// Get AI provider instance for user\n    pub async fn get_user_ai_provider(\n        \u0026self,\n        user_id: \u0026str,\n        provider_type: \u0026ApiKeyProvider,\n    ) -\u003e ArbitrageResult\u003cAiProvider\u003e {\n        let ai_keys = self.get_user_ai_keys(user_id).await?;\n        let ai_key = ai_keys.iter()\n            .find(|key| key.provider == *provider_type \u0026\u0026 key.is_active)\n            .ok_or_else(|| ArbitrageError::not_found(\"Active AI key not found for provider\"))?;\n\n        let decrypted_key = self.decrypt_string(\u0026ai_key.encrypted_key)?;\n        self.create_ai_provider_from_key(ai_key, \u0026decrypted_key)\n    }\n\n    /// Validate AI provider credentials\n    pub async fn validate_ai_credentials(\u0026self, provider: \u0026AiProvider) -\u003e ArbitrageResult\u003cbool\u003e {\n        match provider {\n            AiProvider::OpenAI { api_key, base_url, .. } =\u003e {\n                self.validate_openai_credentials(api_key, base_url.as_deref()).await\n            }\n            AiProvider::Anthropic { api_key, base_url, .. } =\u003e {\n                self.validate_anthropic_credentials(api_key, base_url.as_deref()).await\n            }\n            AiProvider::Custom { api_key, base_url, headers, .. } =\u003e {\n                self.validate_custom_credentials(api_key, base_url, headers).await\n            }\n        }\n    }\n\n    /// Test connectivity to AI provider\n    pub async fn test_ai_connectivity(\u0026self, provider: \u0026AiProvider) -\u003e ArbitrageResult\u003cString\u003e {\n        let test_request = AiAnalysisRequest {\n            prompt: \"Test connectivity. Please respond with 'OK' if you receive this message.\".to_string(),\n            market_data: json!({}),\n            user_context: None,\n            max_tokens: Some(10),\n            temperature: Some(0.1),\n        };\n\n        let response = self.call_ai_provider(provider, \u0026test_request).await?;\n        Ok(response.analysis)\n    }\n\n    /// Call AI provider with analysis request\n    pub async fn call_ai_provider(\n        \u0026self,\n        provider: \u0026AiProvider,\n        request: \u0026AiAnalysisRequest,\n    ) -\u003e ArbitrageResult\u003cAiAnalysisResponse\u003e {\n        if !self.config.enabled {\n            return Err(ArbitrageError::config_error(\"AI integration is disabled\"));\n        }\n\n        match provider {\n            AiProvider::OpenAI { api_key, base_url, model } =\u003e {\n                self.call_openai(api_key, base_url.as_deref(), model.as_deref(), request).await\n            }\n            AiProvider::Anthropic { api_key, base_url, model } =\u003e {\n                self.call_anthropic(api_key, base_url.as_deref(), model.as_deref(), request).await\n            }\n            AiProvider::Custom { api_key, base_url, headers, model } =\u003e {\n                self.call_custom_provider(api_key, base_url, headers, model.as_deref(), request).await\n            }\n        }\n    }\n\n    /// Create AI provider from user API key\n    pub fn create_ai_provider(\u0026self, api_key: \u0026UserApiKey) -\u003e ArbitrageResult\u003cAiProvider\u003e {\n        match api_key.provider {\n            ApiKeyProvider::OpenAI =\u003e Ok(AiProvider::OpenAI {\n                api_key: api_key.encrypted_key.clone(),\n                base_url: api_key.metadata.get(\"base_url\").and_then(|v| v.as_str()).map(String::from),\n                model: api_key.metadata.get(\"model\").and_then(|v| v.as_str()).map(String::from),\n            }),\n            ApiKeyProvider::Anthropic =\u003e Ok(AiProvider::Anthropic {\n                api_key: api_key.encrypted_key.clone(),\n                base_url: api_key.metadata.get(\"base_url\").and_then(|v| v.as_str()).map(String::from),\n                model: api_key.metadata.get(\"model\").and_then(|v| v.as_str()).map(String::from),\n            }),\n            ApiKeyProvider::Custom =\u003e {\n                let base_url = api_key.metadata.get(\"base_url\")\n                    .and_then(|v| v.as_str())\n                    .ok_or_else(|| ArbitrageError::validation_error(\"Custom provider requires base_url\"))?;\n                \n                let headers = api_key.metadata.get(\"headers\")\n                    .and_then(|v| v.as_object())\n                    .map(|obj| {\n                        obj.iter()\n                            .filter_map(|(k, v)| v.as_str().map(|s| (k.clone(), s.to_string())))\n                            .collect()\n                    })\n                    .unwrap_or_default();\n\n                Ok(AiProvider::Custom {\n                    api_key: api_key.encrypted_key.clone(),\n                    base_url: base_url.to_string(),\n                    headers,\n                    model: api_key.metadata.get(\"model\").and_then(|v| v.as_str()).map(String::from),\n                })\n            }\n            ApiKeyProvider::Exchange(_) =\u003e {\n                Err(ArbitrageError::validation_error(\"Cannot create AI provider from exchange API key\"))\n            }\n        }\n    }\n\n    /// Get supported AI providers\n    pub fn get_supported_providers(\u0026self) -\u003e \u0026[ApiKeyProvider] {\n        \u0026self.config.supported_providers\n    }\n\n    /// Check if provider is supported\n    pub fn is_provider_supported(\u0026self, provider: \u0026ApiKeyProvider) -\u003e bool {\n        self.config.supported_providers.contains(provider)\n    }\n\n    // Private methods for specific AI providers\n\n    async fn validate_openai_credentials(\u0026self, api_key: \u0026str, base_url: Option\u003c\u0026str\u003e) -\u003e ArbitrageResult\u003cbool\u003e {\n        let url = format!(\"{}/v1/models\", base_url.unwrap_or(\"https://api.openai.com\"));\n        \n        let response = self.http_client\n            .get(\u0026url)\n            .header(\"Authorization\", format!(\"Bearer {}\", api_key))\n            .timeout(std::time::Duration::from_secs(self.config.default_timeout_seconds))\n            .send()\n            .await\n            .map_err(|e| ArbitrageError::network_error(\u0026format!(\"OpenAI validation failed: {}\", e)))?;\n\n        Ok(response.status().is_success())\n    }\n\n    async fn validate_anthropic_credentials(\u0026self, api_key: \u0026str, base_url: Option\u003c\u0026str\u003e) -\u003e ArbitrageResult\u003cbool\u003e {\n        let url = format!(\"{}/v1/messages\", base_url.unwrap_or(\"https://api.anthropic.com\"));\n        \n        // Send a minimal test request\n        let test_payload = json!({\n            \"model\": \"claude-3-haiku-20240307\",\n            \"max_tokens\": 1,\n            \"messages\": [{\"role\": \"user\", \"content\": \"test\"}]\n        });\n\n        let response = self.http_client\n            .post(\u0026url)\n            .header(\"x-api-key\", api_key)\n            .header(\"anthropic-version\", \"2023-06-01\")\n            .header(\"content-type\", \"application/json\")\n            .json(\u0026test_payload)\n            .timeout(std::time::Duration::from_secs(self.config.default_timeout_seconds))\n            .send()\n            .await\n            .map_err(|e| ArbitrageError::network_error(\u0026format!(\"Anthropic validation failed: {}\", e)))?;\n\n        // Accept both success and rate limit as valid (credentials are correct)\n        Ok(response.status().is_success() || response.status() == 429)\n    }\n\n    async fn validate_custom_credentials(\n        \u0026self,\n        api_key: \u0026str,\n        base_url: \u0026str,\n        headers: \u0026HashMap\u003cString, String\u003e,\n    ) -\u003e ArbitrageResult\u003cbool\u003e {\n        let mut request = self.http_client\n            .get(base_url)\n            .header(\"Authorization\", format!(\"Bearer {}\", api_key))\n            .timeout(std::time::Duration::from_secs(self.config.default_timeout_seconds));\n\n        for (key, value) in headers {\n            request = request.header(key, value);\n        }\n\n        let response = request\n            .send()\n            .await\n            .map_err(|e| ArbitrageError::network_error(\u0026format!(\"Custom provider validation failed: {}\", e)))?;\n\n        Ok(response.status().is_success())\n    }\n\n    async fn call_openai(\n        \u0026self,\n        api_key: \u0026str,\n        base_url: Option\u003c\u0026str\u003e,\n        model: Option\u003c\u0026str\u003e,\n        request: \u0026AiAnalysisRequest,\n    ) -\u003e ArbitrageResult\u003cAiAnalysisResponse\u003e {\n        let url = format!(\"{}/v1/chat/completions\", base_url.unwrap_or(\"https://api.openai.com\"));\n        let model_name = model.unwrap_or(\"gpt-3.5-turbo\");\n\n        let payload = json!({\n            \"model\": model_name,\n            \"messages\": [\n                {\n                    \"role\": \"system\",\n                    \"content\": \"You are an expert cryptocurrency trading analyst. Analyze the provided market data and provide insights for arbitrage opportunities.\"\n                },\n                {\n                    \"role\": \"user\",\n                    \"content\": format!(\"Prompt: {}\\nMarket Data: {}\", request.prompt, request.market_data)\n                }\n            ],\n            \"max_tokens\": request.max_tokens.unwrap_or(500),\n            \"temperature\": request.temperature.unwrap_or(0.7)\n        });\n\n        let response = self.http_client\n            .post(\u0026url)\n            .header(\"Authorization\", format!(\"Bearer {}\", api_key))\n            .header(\"Content-Type\", \"application/json\")\n            .json(\u0026payload)\n            .timeout(std::time::Duration::from_secs(self.config.default_timeout_seconds))\n            .send()\n            .await\n            .map_err(|e| ArbitrageError::network_error(\u0026format!(\"OpenAI API call failed: {}\", e)))?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_else(|_| \"Unknown error\".to_string());\n            return Err(ArbitrageError::api_error(\u0026format!(\"OpenAI API error: {}\", error_text)));\n        }\n\n        let response_data: Value = response.json().await\n            .map_err(|e| ArbitrageError::parse_error(\u0026format!(\"Failed to parse OpenAI response: {}\", e)))?;\n\n        let analysis = response_data[\"choices\"][0][\"message\"][\"content\"]\n            .as_str()\n            .unwrap_or(\"No response\")\n            .to_string();\n\n        Ok(AiAnalysisResponse {\n            analysis,\n            confidence: None,\n            recommendations: vec![],\n            metadata: HashMap::new(),\n        })\n    }\n\n    async fn call_anthropic(\n        \u0026self,\n        api_key: \u0026str,\n        base_url: Option\u003c\u0026str\u003e,\n        model: Option\u003c\u0026str\u003e,\n        request: \u0026AiAnalysisRequest,\n    ) -\u003e ArbitrageResult\u003cAiAnalysisResponse\u003e {\n        let url = format!(\"{}/v1/messages\", base_url.unwrap_or(\"https://api.anthropic.com\"));\n        let model_name = model.unwrap_or(\"claude-3-haiku-20240307\");\n\n        let payload = json!({\n            \"model\": model_name,\n            \"max_tokens\": request.max_tokens.unwrap_or(500),\n            \"messages\": [\n                {\n                    \"role\": \"user\",\n                    \"content\": format!(\"As a cryptocurrency trading analyst, analyze this market data for arbitrage opportunities:\\n\\nPrompt: {}\\nMarket Data: {}\", request.prompt, request.market_data)\n                }\n            ]\n        });\n\n        let response = self.http_client\n            .post(\u0026url)\n            .header(\"x-api-key\", api_key)\n            .header(\"anthropic-version\", \"2023-06-01\")\n            .header(\"content-type\", \"application/json\")\n            .json(\u0026payload)\n            .timeout(std::time::Duration::from_secs(self.config.default_timeout_seconds))\n            .send()\n            .await\n            .map_err(|e| ArbitrageError::network_error(\u0026format!(\"Anthropic API call failed: {}\", e)))?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_else(|_| \"Unknown error\".to_string());\n            return Err(ArbitrageError::api_error(\u0026format!(\"Anthropic API error: {}\", error_text)));\n        }\n\n        let response_data: Value = response.json().await\n            .map_err(|e| ArbitrageError::parse_error(\u0026format!(\"Failed to parse Anthropic response: {}\", e)))?;\n\n        let analysis = response_data[\"content\"][0][\"text\"]\n            .as_str()\n            .unwrap_or(\"No response\")\n            .to_string();\n\n        Ok(AiAnalysisResponse {\n            analysis,\n            confidence: None,\n            recommendations: vec![],\n            metadata: HashMap::new(),\n        })\n    }\n\n    async fn call_custom_provider(\n        \u0026self,\n        api_key: \u0026str,\n        base_url: \u0026str,\n        headers: \u0026HashMap\u003cString, String\u003e,\n        model: Option\u003c\u0026str\u003e,\n        request: \u0026AiAnalysisRequest,\n    ) -\u003e ArbitrageResult\u003cAiAnalysisResponse\u003e {\n        let payload = json!({\n            \"prompt\": request.prompt,\n            \"market_data\": request.market_data,\n            \"max_tokens\": request.max_tokens.unwrap_or(500),\n            \"temperature\": request.temperature.unwrap_or(0.7),\n            \"model\": model\n        });\n\n        let mut http_request = self.http_client\n            .post(base_url)\n            .header(\"Authorization\", format!(\"Bearer {}\", api_key))\n            .header(\"Content-Type\", \"application/json\")\n            .json(\u0026payload)\n            .timeout(std::time::Duration::from_secs(self.config.default_timeout_seconds));\n\n        for (key, value) in headers {\n            http_request = http_request.header(key, value);\n        }\n\n        let response = http_request\n            .send()\n            .await\n            .map_err(|e| ArbitrageError::network_error(\u0026format!(\"Custom provider API call failed: {}\", e)))?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_else(|_| \"Unknown error\".to_string());\n            return Err(ArbitrageError::api_error(\u0026format!(\"Custom provider API error: {}\", error_text)));\n        }\n\n        let response_data: Value = response.json().await\n            .map_err(|e| ArbitrageError::parse_error(\u0026format!(\"Failed to parse custom provider response: {}\", e)))?;\n\n        // Try to extract analysis from common response formats\n        let analysis = response_data[\"response\"]\n            .as_str()\n            .or_else(|| response_data[\"text\"].as_str())\n            .or_else(|| response_data[\"analysis\"].as_str())\n            .or_else(|| response_data[\"content\"].as_str())\n            .unwrap_or(\"No response\")\n            .to_string();\n\n        Ok(AiAnalysisResponse {\n            analysis,\n            confidence: response_data[\"confidence\"].as_f64().map(|v| v as f32),\n            recommendations: response_data[\"recommendations\"]\n                .as_array()\n                .map(|arr| {\n                    arr.iter()\n                        .filter_map(|v| v.as_str().map(String::from))\n                        .collect()\n                })\n                .unwrap_or_default(),\n            metadata: HashMap::new(),\n        })\n    }\n\n    // Helper methods\n\n    async fn update_user_ai_key_index(\n        \u0026self,\n        user_id: \u0026str,\n        api_key_id: \u0026str,\n        add: bool,\n    ) -\u003e ArbitrageResult\u003c()\u003e {\n        let index_key = format!(\"ai_key_index:{}\", user_id);\n        let index_data = self.kv_store.get(\u0026index_key)\n            .text()\n            .await\n            .map_err(|e| ArbitrageError::storage_error(format!(\"Failed to get AI key index: {}\", e)))?;\n\n        let mut key_ids: Vec\u003cString\u003e = if let Some(data) = index_data {\n            serde_json::from_str(\u0026data)\n                .unwrap_or_default()\n        } else {\n            Vec::new()\n        };\n\n        if add {\n            if !key_ids.contains(\u0026api_key_id.to_string()) {\n                key_ids.push(api_key_id.to_string());\n            }\n        } else {\n            key_ids.retain(|id| id != api_key_id);\n        }\n\n        let serialized = serde_json::to_string(\u0026key_ids)\n            .map_err(|e| ArbitrageError::parse_error(format!(\"Failed to serialize key index: {}\", e)))?;\n\n        self.kv_store.put(\u0026index_key, \u0026serialized)\n            .map_err(|e| ArbitrageError::storage_error(format!(\"Failed to prepare AI key index storage: {}\", e)))?\n            .execute()\n            .await\n            .map_err(|e| ArbitrageError::storage_error(format!(\"Failed to update AI key index: {}\", e)))?;\n\n        Ok(())\n    }\n\n    async fn update_ai_key_last_used(\n        \u0026self,\n        user_id: \u0026str,\n        api_key_id: \u0026str,\n    ) -\u003e ArbitrageResult\u003c()\u003e {\n        let key = format!(\"ai_key:{}:{}\", user_id, api_key_id);\n        if let Ok(Some(data)) = self.kv_store.get(\u0026key).text().await {\n            if let Ok(mut api_key) = serde_json::from_str::\u003cUserApiKey\u003e(\u0026data) {\n                api_key.update_last_used();\n                \n                let serialized = serde_json::to_string(\u0026api_key)\n                    .map_err(|e| ArbitrageError::parse_error(format!(\"Failed to serialize AI key: {}\", e)))?;\n                \n                self.kv_store.put(\u0026key, \u0026serialized)\n                    .map_err(|e| ArbitrageError::storage_error(format!(\"Failed to prepare AI key storage: {}\", e)))?\n                    .execute()\n                    .await\n                    .map_err(|e| ArbitrageError::storage_error(format!(\"Failed to update AI key: {}\", e)))?;\n            }\n        }\n        Ok(())\n    }\n\n    fn create_ai_provider_from_key(\n        \u0026self,\n        api_key: \u0026UserApiKey,\n        decrypted_key: \u0026str,\n    ) -\u003e ArbitrageResult\u003cAiProvider\u003e {\n        match api_key.provider {\n            ApiKeyProvider::OpenAI =\u003e Ok(AiProvider::OpenAI {\n                api_key: decrypted_key.to_string(),\n                base_url: api_key.metadata.get(\"base_url\").and_then(|v| v.as_str()).map(String::from),\n                model: api_key.metadata.get(\"model\").and_then(|v| v.as_str()).map(String::from),\n            }),\n            ApiKeyProvider::Anthropic =\u003e Ok(AiProvider::Anthropic {\n                api_key: decrypted_key.to_string(),\n                base_url: api_key.metadata.get(\"base_url\").and_then(|v| v.as_str()).map(String::from),\n                model: api_key.metadata.get(\"model\").and_then(|v| v.as_str()).map(String::from),\n            }),\n            ApiKeyProvider::Custom =\u003e {\n                let base_url = api_key.metadata.get(\"base_url\")\n                    .and_then(|v| v.as_str())\n                    .ok_or_else(|| ArbitrageError::validation_error(\"Custom provider requires base_url\"))?;\n                \n                let headers = api_key.metadata.get(\"headers\")\n                    .and_then(|v| v.as_object())\n                    .map(|obj| {\n                        obj.iter()\n                            .filter_map(|(k, v)| v.as_str().map(|s| (k.clone(), s.to_string())))\n                            .collect()\n                    })\n                    .unwrap_or_default();\n\n                Ok(AiProvider::Custom {\n                    api_key: decrypted_key.to_string(),\n                    base_url: base_url.to_string(),\n                    headers,\n                    model: api_key.metadata.get(\"model\").and_then(|v| v.as_str()).map(String::from),\n                })\n            }\n            ApiKeyProvider::Exchange(_) =\u003e {\n                Err(ArbitrageError::validation_error(\"Cannot create AI provider from exchange API key\"))\n            }\n        }\n    }\n\n    fn encrypt_string(\u0026self, plaintext: \u0026str) -\u003e ArbitrageResult\u003cString\u003e {\n        use base64::{Engine as _, engine::general_purpose};\n        \n        let key_bytes = self.encryption_key.as_bytes();\n        let encrypted: Vec\u003cu8\u003e = plaintext\n            .as_bytes()\n            .iter()\n            .enumerate()\n            .map(|(i, \u0026byte)| byte ^ key_bytes[i % key_bytes.len()])\n            .collect();\n        \n        Ok(general_purpose::STANDARD.encode(encrypted))\n    }\n\n    fn decrypt_string(\u0026self, ciphertext: \u0026str) -\u003e ArbitrageResult\u003cString\u003e {\n        use base64::{Engine as _, engine::general_purpose};\n        \n        let encrypted = general_purpose::STANDARD.decode(ciphertext).map_err(|e| {\n            ArbitrageError::parse_error(format!(\"Failed to decode base64: {}\", e))\n        })?;\n        \n        let key_bytes = self.encryption_key.as_bytes();\n        let decrypted: Vec\u003cu8\u003e = encrypted\n            .iter()\n            .enumerate()\n            .map(|(i, \u0026byte)| byte ^ key_bytes[i % key_bytes.len()])\n            .collect();\n        \n        String::from_utf8(decrypted).map_err(|e| {\n            ArbitrageError::parse_error(format!(\"Failed to convert decrypted bytes to string: {}\", e))\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    // Mock KV store for testing\n    #[derive(Debug, Clone)]\n    struct MockKvStore {\n        data: std::sync::Arc\u003cstd::sync::Mutex\u003cHashMap\u003cString, String\u003e\u003e\u003e,\n    }\n\n    impl MockKvStore {\n        fn new() -\u003e Self {\n            Self {\n                data: std::sync::Arc::new(std::sync::Mutex::new(HashMap::new())),\n            }\n        }\n\n        async fn get(\u0026self, key: \u0026str) -\u003e Option\u003cString\u003e {\n            let data = self.data.lock().unwrap();\n            data.get(key).cloned()\n        }\n\n        async fn put(\u0026self, key: \u0026str, value: \u0026str) -\u003e Result\u003c(), String\u003e {\n            let mut data = self.data.lock().unwrap();\n            data.insert(key.to_string(), value.to_string());\n            Ok(())\n        }\n\n        async fn delete(\u0026self, key: \u0026str) -\u003e Result\u003c(), String\u003e {\n            let mut data = self.data.lock().unwrap();\n            data.remove(key);\n            Ok(())\n        }\n    }\n\n    fn create_test_config() -\u003e AiIntegrationConfig {\n        AiIntegrationConfig::default()\n    }\n\n    fn create_test_service() -\u003e AiIntegrationService {\n        let config = create_test_config();\n        // Create minimal service for testing (KV store not used in these tests)\n        AiIntegrationService {\n            config,\n            http_client: reqwest::Client::new(),\n            kv_store: unsafe { std::mem::zeroed() }, // Not used in encryption tests\n            encryption_key: \"test-encryption-key-123\".to_string(),\n        }\n    }\n\n    #[test]\n    fn test_ai_integration_config_creation() {\n        let config = create_test_config();\n        assert!(config.enabled);\n        assert_eq!(config.default_timeout_seconds, 30);\n        assert_eq!(config.max_retries, 3);\n        assert_eq!(config.max_ai_keys_per_user, 10);\n        assert_eq!(config.supported_providers.len(), 3);\n    }\n\n    #[test]\n    fn test_ai_integration_service_creation() {\n        // Test that the service can be created with proper configuration\n        let config = create_test_config();\n        assert!(config.enabled);\n        // Note: actual service creation test would require KV mock\n    }\n\n    #[test]\n    fn test_openai_provider_creation() {\n        let provider = AiProvider::OpenAI {\n            api_key: \"test-key\".to_string(),\n            base_url: Some(\"https://api.openai.com\".to_string()),\n            model: Some(\"gpt-4\".to_string()),\n        };\n\n        match provider {\n            AiProvider::OpenAI { api_key, base_url, model } =\u003e {\n                assert_eq!(api_key, \"test-key\");\n                assert_eq!(base_url, Some(\"https://api.openai.com\".to_string()));\n                assert_eq!(model, Some(\"gpt-4\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected OpenAI provider\"),\n        }\n    }\n\n    #[test]\n    fn test_anthropic_provider_creation() {\n        let provider = AiProvider::Anthropic {\n            api_key: \"test-anthropic-key\".to_string(),\n            base_url: None,\n            model: Some(\"claude-3-sonnet\".to_string()),\n        };\n\n        match provider {\n            AiProvider::Anthropic { api_key, base_url, model } =\u003e {\n                assert_eq!(api_key, \"test-anthropic-key\");\n                assert_eq!(base_url, None);\n                assert_eq!(model, Some(\"claude-3-sonnet\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected Anthropic provider\"),\n        }\n    }\n\n    #[test]\n    fn test_custom_provider_creation() {\n        let mut headers = HashMap::new();\n        headers.insert(\"X-API-Key\".to_string(), \"custom-key\".to_string());\n\n        let provider = AiProvider::Custom {\n            api_key: \"custom-api-key\".to_string(),\n            base_url: \"https://custom-ai.example.com\".to_string(),\n            headers: headers.clone(),\n            model: Some(\"custom-model\".to_string()),\n        };\n\n        match provider {\n            AiProvider::Custom { api_key, base_url, headers: provider_headers, model } =\u003e {\n                assert_eq!(api_key, \"custom-api-key\");\n                assert_eq!(base_url, \"https://custom-ai.example.com\");\n                assert_eq!(provider_headers, headers);\n                assert_eq!(model, Some(\"custom-model\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected Custom provider\"),\n        }\n    }\n\n    #[test]\n    fn test_custom_provider_missing_base_url() {\n        let metadata = json!({\n            \"model\": \"test-model\"\n            // Missing base_url\n        });\n\n        let api_key = UserApiKey::new_ai_key(\n            \"user123\".to_string(),\n            ApiKeyProvider::Custom,\n            \"encrypted_key\".to_string(),\n            metadata,\n        );\n\n        // This should be tested in the service context\n        // We expect validation error for missing base_url\n        assert_eq!(api_key.provider, ApiKeyProvider::Custom);\n    }\n\n    #[test]\n    fn test_ai_analysis_request_creation() {\n        let request = AiAnalysisRequest {\n            prompt: \"Analyze this market data\".to_string(),\n            market_data: json!({\"price\": 100.0, \"volume\": 1000}),\n            user_context: Some(json!({\"risk_tolerance\": \"medium\"})),\n            max_tokens: Some(500),\n            temperature: Some(0.7),\n        };\n\n        assert_eq!(request.prompt, \"Analyze this market data\");\n        assert_eq!(request.max_tokens, Some(500));\n        assert_eq!(request.temperature, Some(0.7));\n    }\n\n    #[test]\n    fn test_ai_analysis_response_creation() {\n        let mut metadata = HashMap::new();\n        metadata.insert(\"model\".to_string(), json!(\"gpt-4\"));\n        metadata.insert(\"tokens_used\".to_string(), json!(250));\n\n        let response = AiAnalysisResponse {\n            analysis: \"Market shows bullish trends\".to_string(),\n            confidence: Some(0.8),\n            recommendations: vec![\"Buy\".to_string(), \"Hold\".to_string()],\n            metadata,\n        };\n\n        assert_eq!(response.analysis, \"Market shows bullish trends\");\n        assert_eq!(response.confidence, Some(0.8));\n        assert_eq!(response.recommendations.len(), 2);\n    }\n\n    #[test]\n    fn test_disabled_ai_integration() {\n        let mut config = create_test_config();\n        config.enabled = false;\n        \n        // Test configuration\n        assert!(!config.enabled);\n        assert_eq!(config.max_ai_keys_per_user, 10);\n    }\n\n    #[test]\n    fn test_exchange_key_rejection() {\n        // Test that exchange API keys are properly rejected for AI use\n        let api_key = UserApiKey::new_exchange_key(\n            \"user123\".to_string(),\n            crate::types::ExchangeIdEnum::Binance,\n            \"encrypted_key\".to_string(),\n            \"encrypted_secret\".to_string(),\n            vec![\"trade\".to_string()],\n        );\n\n        // Verify it's an exchange key, not AI key\n        assert!(api_key.is_exchange_key());\n        assert!(!api_key.is_ai_key());\n    }\n\n    #[test]\n    fn test_encryption_decryption() {\n        let service = create_test_service();\n        let plaintext = \"test-api-key-12345\";\n        \n        let encrypted = service.encrypt_string(plaintext).unwrap();\n        assert_ne!(encrypted, plaintext);\n        \n        let decrypted = service.decrypt_string(\u0026encrypted).unwrap();\n        assert_eq!(decrypted, plaintext);\n        \n        // Forget the service to avoid drop issues\n        std::mem::forget(service);\n    }\n\n    #[test]\n    fn test_supported_providers() {\n        let service = create_test_service();\n        \n        let providers = service.get_supported_providers();\n        assert!(providers.contains(\u0026ApiKeyProvider::OpenAI));\n        assert!(providers.contains(\u0026ApiKeyProvider::Anthropic));\n        assert!(providers.contains(\u0026ApiKeyProvider::Custom));\n        \n        assert!(service.is_provider_supported(\u0026ApiKeyProvider::OpenAI));\n        assert!(service.is_provider_supported(\u0026ApiKeyProvider::Anthropic));\n        assert!(service.is_provider_supported(\u0026ApiKeyProvider::Custom));\n        assert!(!service.is_provider_supported(\u0026ApiKeyProvider::Exchange(crate::types::ExchangeIdEnum::Binance)));\n        \n        // Forget the service to avoid drop issues\n        std::mem::forget(service);\n    }\n\n    #[test]\n    fn test_ai_analysis_request_validation() {\n        let request = AiAnalysisRequest {\n            prompt: \"Analyze this market data\".to_string(),\n            market_data: json!({\"symbol\": \"BTCUSDT\", \"price\": 50000.0}),\n            user_context: Some(json!({\"risk_tolerance\": \"medium\"})),\n            max_tokens: Some(1000),\n            temperature: Some(0.7),\n        };\n\n        assert_eq!(request.prompt, \"Analyze this market data\");\n        assert!(request.user_context.is_some());\n        assert_eq!(request.max_tokens, Some(1000));\n        assert_eq!(request.temperature, Some(0.7));\n    }\n\n    #[test]\n    fn test_ai_analysis_response_creation_comprehensive() {\n        let mut metadata = HashMap::new();\n        metadata.insert(\"model\".to_string(), json!(\"gpt-4\"));\n        metadata.insert(\"usage\".to_string(), json!({\"tokens\": 150}));\n\n        let response = AiAnalysisResponse {\n            analysis: \"Market shows bullish trend\".to_string(),\n            confidence: Some(0.85),\n            recommendations: vec![\"Buy\".to_string(), \"Hold\".to_string()],\n            metadata,\n        };\n\n        assert_eq!(response.analysis, \"Market shows bullish trend\");\n        assert_eq!(response.confidence, Some(0.85));\n        assert_eq!(response.recommendations.len(), 2);\n        assert!(response.metadata.contains_key(\"model\"));\n    }\n\n    #[test]\n    fn test_create_ai_provider_from_user_api_key() {\n        let service = create_test_service();\n        \n        // Test OpenAI provider creation\n        let openai_key = UserApiKey::new_ai_key(\n            \"user123\".to_string(),\n            ApiKeyProvider::OpenAI,\n            \"encrypted-key\".to_string(),\n            json!({\"model\": \"gpt-4\", \"base_url\": \"https://api.openai.com\"}),\n        );\n\n        let provider = service.create_ai_provider(\u0026openai_key).unwrap();\n        match provider {\n            AiProvider::OpenAI { model, base_url, .. } =\u003e {\n                assert_eq!(model, Some(\"gpt-4\".to_string()));\n                assert_eq!(base_url, Some(\"https://api.openai.com\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected OpenAI provider\"),\n        }\n\n        // Test Anthropic provider creation\n        let anthropic_key = UserApiKey::new_ai_key(\n            \"user123\".to_string(),\n            ApiKeyProvider::Anthropic,\n            \"encrypted-key\".to_string(),\n            json!({\"model\": \"claude-3\"}),\n        );\n\n        let provider = service.create_ai_provider(\u0026anthropic_key).unwrap();\n        match provider {\n            AiProvider::Anthropic { model, .. } =\u003e {\n                assert_eq!(model, Some(\"claude-3\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected Anthropic provider\"),\n        }\n\n        // Test Custom provider creation\n        let custom_key = UserApiKey::new_ai_key(\n            \"user123\".to_string(),\n            ApiKeyProvider::Custom,\n            \"encrypted-key\".to_string(),\n            json!({\n                \"base_url\": \"https://custom-ai.com/api\",\n                \"model\": \"custom-model\",\n                \"headers\": {\"Authorization\": \"Bearer token\"}\n            }),\n        );\n\n        let provider = service.create_ai_provider(\u0026custom_key).unwrap();\n        match provider {\n            AiProvider::Custom { base_url, model, headers, .. } =\u003e {\n                assert_eq!(base_url, \"https://custom-ai.com/api\");\n                assert_eq!(model, Some(\"custom-model\".to_string()));\n                assert!(headers.contains_key(\"Authorization\"));\n            }\n            _ =\u003e panic!(\"Expected Custom provider\"),\n        }\n        \n        // Forget the service to avoid drop issues\n        std::mem::forget(service);\n    }\n\n    #[test]\n    fn test_create_ai_provider_custom_missing_base_url() {\n        let service = create_test_service();\n        \n        let custom_key = UserApiKey::new_ai_key(\n            \"user123\".to_string(),\n            ApiKeyProvider::Custom,\n            \"encrypted-key\".to_string(),\n            json!({\"model\": \"custom-model\"}), // Missing base_url\n        );\n\n        let result = service.create_ai_provider(\u0026custom_key);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"Custom provider requires base_url\"));\n        \n        // Forget the service to avoid drop issues\n        std::mem::forget(service);\n    }\n\n    #[test]\n    fn test_create_ai_provider_from_exchange_key() {\n        let service = create_test_service();\n        \n        let exchange_key = UserApiKey::new_exchange_key(\n            \"user123\".to_string(),\n            crate::types::ExchangeIdEnum::Binance,\n            \"encrypted-key\".to_string(),\n            \"encrypted-secret\".to_string(),\n            vec![\"spot\".to_string()],\n        );\n\n        let result = service.create_ai_provider(\u0026exchange_key);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"Cannot create AI provider from exchange API key\"));\n        \n        // Forget the service to avoid drop issues\n        std::mem::forget(service);\n    }\n} ","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":4}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":319},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","services","exchange.rs"],"content":"// src/services/exchange.rs\n\nuse chrono::Utc;\nuse reqwest::{Client, Method};\nuse serde_json::{json, Value};\n\nuse crate::types::*;\nuse crate::utils::{ArbitrageError, ArbitrageResult};\n\n// Exchange authentication helper\nuse hmac::{Hmac, Mac};\nuse sha2::Sha256;\nuse hex;\n\n#[allow(dead_code)]\npub trait ExchangeInterface {\n    async fn save_api_key(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n    ) -\u003e ArbitrageResult\u003c()\u003e;\n\n    async fn get_api_key(\u0026self, exchange_id: \u0026str) -\u003e ArbitrageResult\u003cOption\u003cExchangeCredentials\u003e\u003e;\n    async fn delete_api_key(\u0026self, exchange_id: \u0026str) -\u003e ArbitrageResult\u003c()\u003e;\n\n    async fn get_markets(\u0026self, exchange_id: \u0026str) -\u003e ArbitrageResult\u003cVec\u003cMarket\u003e\u003e;\n    async fn get_ticker(\u0026self, exchange_id: \u0026str, symbol: \u0026str) -\u003e ArbitrageResult\u003cTicker\u003e;\n    async fn get_orderbook(\n        \u0026self,\n        exchange_id: \u0026str,\n        symbol: \u0026str,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e ArbitrageResult\u003cOrderBook\u003e;\n\n    async fn fetch_funding_rates(\n        \u0026self,\n        exchange_id: \u0026str,\n        symbol: Option\u003c\u0026str\u003e,\n    ) -\u003e ArbitrageResult\u003cVec\u003cValue\u003e\u003e;\n\n    async fn get_balance(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n    ) -\u003e ArbitrageResult\u003cValue\u003e;\n\n    async fn create_order(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n        symbol: \u0026str,\n        side: \u0026str,\n        amount: f64,\n        price: Option\u003cf64\u003e,\n    ) -\u003e ArbitrageResult\u003cValue\u003e;\n\n    async fn cancel_order(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n        order_id: \u0026str,\n        symbol: \u0026str,\n    ) -\u003e ArbitrageResult\u003cValue\u003e;\n\n    async fn get_open_orders(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n        symbol: Option\u003c\u0026str\u003e,\n    ) -\u003e ArbitrageResult\u003cVec\u003cValue\u003e\u003e;\n\n    async fn get_open_positions(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n        symbol: Option\u003c\u0026str\u003e,\n    ) -\u003e ArbitrageResult\u003cVec\u003cValue\u003e\u003e;\n\n    async fn set_leverage(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n        symbol: \u0026str,\n        leverage: u32,\n    ) -\u003e ArbitrageResult\u003cValue\u003e;\n\n    async fn get_trading_fees(\n        \u0026self,\n        exchange_id: \u0026str,\n        _credentials: \u0026ExchangeCredentials,\n        symbol: \u0026str,\n    ) -\u003e ArbitrageResult\u003cValue\u003e;\n}\n\npub struct ExchangeService {\n    client: Client,\n    kv: worker::kv::KvStore,\n}\n\nimpl ExchangeService {\n    #[allow(clippy::result_large_err)]\n    pub fn new(env: \u0026Env) -\u003e ArbitrageResult\u003cSelf\u003e {\n        let kv = env.get_kv_store(\"ARBITRAGE_KV\").ok_or_else(|| {\n            ArbitrageError::internal_error(\n                \"Failed to get KV store: ARBITRAGE_KV binding not found\".to_string()\n            )\n        })?;\n\n        let client = Client::new();\n\n        Ok(Self {\n            client,\n            kv,\n        })\n    }\n\n    #[allow(clippy::result_large_err)]\n    fn parse_binance_ticker(\u0026self, data: \u0026Value, symbol: \u0026str) -\u003e ArbitrageResult\u003cTicker\u003e {\n        Ok(Ticker {\n            symbol: symbol.to_string(),\n            bid: data[\"bidPrice\"].as_str().and_then(|s| s.parse().ok()),\n            ask: data[\"askPrice\"].as_str().and_then(|s| s.parse().ok()),\n            last: data[\"price\"].as_str().and_then(|s| s.parse().ok()),\n            high: data[\"highPrice\"].as_str().and_then(|s| s.parse().ok()),\n            low: data[\"lowPrice\"].as_str().and_then(|s| s.parse().ok()),\n            volume: data[\"volume\"].as_str().and_then(|s| s.parse().ok()),\n            timestamp: Some(Utc::now()),\n            datetime: Some(Utc::now().to_rfc3339()),\n        })\n    }\n\n    #[allow(clippy::result_large_err)]\n    fn parse_bybit_ticker(\u0026self, data: \u0026Value, symbol: \u0026str) -\u003e ArbitrageResult\u003cTicker\u003e {\n        Ok(Ticker {\n            symbol: symbol.to_string(),\n            bid: data[\"bid1Price\"].as_str().and_then(|s| s.parse().ok()),\n            ask: data[\"ask1Price\"].as_str().and_then(|s| s.parse().ok()),\n            last: data[\"lastPrice\"].as_str().and_then(|s| s.parse().ok()),\n            high: data[\"highPrice24h\"].as_str().and_then(|s| s.parse().ok()),\n            low: data[\"lowPrice24h\"].as_str().and_then(|s| s.parse().ok()),\n            volume: data[\"volume24h\"].as_str().and_then(|s| s.parse().ok()),\n            timestamp: Some(Utc::now()),\n            datetime: Some(Utc::now().to_rfc3339()),\n        })\n    }\n\n    // Exchange-specific implementations\n    async fn binance_request(\n        \u0026self,\n        endpoint: \u0026str,\n        method: Method,\n        params: Option\u003cValue\u003e,\n        auth: Option\u003c\u0026ExchangeCredentials\u003e,\n    ) -\u003e ArbitrageResult\u003cValue\u003e {\n        let base_url = \"https://api.binance.com\";\n        let url = format!(\"{}{}\", base_url, endpoint);\n\n        let mut request = self.client.request(method, \u0026url);\n\n        // Collect all query parameters\n        let mut query_params = Vec::new();\n        \n        // Add query parameters from the params argument\n        if let Some(params) = params {\n            if let Some(obj) = params.as_object() {\n                for (key, value) in obj {\n                    if let Some(str_val) = value.as_str() {\n                        query_params.push((key.clone(), str_val.to_string()));\n                    } else {\n                        query_params.push((key.clone(), value.to_string()));\n                    }\n                }\n            }\n        }\n\n        // Add authentication if provided\n        if let Some(creds) = auth {\n            let timestamp = Utc::now().timestamp_millis();\n            \n            // Add timestamp to query parameters\n            query_params.push((\"timestamp\".to_string(), timestamp.to_string()));\n            \n            // Sort query parameters for consistent signature generation\n            query_params.sort();\n            let query_string = query_params\n                .iter()\n                .map(|(k, v)| format!(\"{}={}\", k, v))\n                .collect::\u003cVec\u003c_\u003e\u003e()\n                .join(\"\u0026\");\n\n            // Create signature\n            let mut mac = Hmac::\u003cSha256\u003e::new_from_slice(creds.secret.as_bytes()).map_err(|e| {\n                ArbitrageError::authentication_error(format!(\"Invalid secret key: {}\", e))\n            })?;\n            mac.update(query_string.as_bytes());\n            let signature = hex::encode(mac.finalize().into_bytes());\n\n            // Add signature to query params\n            query_params.push((\"signature\".to_string(), signature));\n            \n            // Set query parameters\n            request = request.query(\u0026query_params);\n            request = request.header(\"X-MBX-APIKEY\", \u0026creds.api_key);\n        } else {\n            // If no auth, just add the regular parameters\n            if !query_params.is_empty() {\n                request = request.query(\u0026query_params);\n            }\n        }\n\n        let response = request\n            .send()\n            .await\n            .map_err(|e| ArbitrageError::network_error(format!(\"HTTP request failed: {}\", e)))?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_default();\n            return Err(ArbitrageError::api_error(format!(\n                \"Binance API error: {}\",\n                error_text\n            )));\n        }\n\n        let json: Value = response\n            .json()\n            .await\n            .map_err(|e| ArbitrageError::parse_error(format!(\"Failed to parse JSON: {}\", e)))?;\n        Ok(json)\n    }\n\n    async fn bybit_request(\n        \u0026self,\n        endpoint: \u0026str,\n        method: Method,\n        params: Option\u003cValue\u003e,\n        auth: Option\u003c\u0026ExchangeCredentials\u003e,\n    ) -\u003e ArbitrageResult\u003cValue\u003e {\n        let base_url = \"https://api.bybit.com\";\n        let url = format!(\"{}{}\", base_url, endpoint);\n\n        let mut request = self.client.request(method, \u0026url);\n\n        // Add authentication if provided\n        if let Some(creds) = auth {\n            let timestamp = Utc::now().timestamp_millis();\n            let recv_window = \"5000\";\n\n            let param_str = if let Some(params) = \u0026params {\n                serde_json::to_string(params).unwrap_or_default()\n            } else {\n                \"{}\".to_string()\n            };\n\n            let sign_str = format!(\"{}{}{}{}\", timestamp, \u0026creds.api_key, recv_window, param_str);\n\n            let mut mac = Hmac::\u003cSha256\u003e::new_from_slice(creds.secret.as_bytes()).map_err(|e| {\n                ArbitrageError::authentication_error(format!(\"Invalid secret key: {}\", e))\n            })?;\n            mac.update(sign_str.as_bytes());\n            let signature = hex::encode(mac.finalize().into_bytes());\n\n            request = request\n                .header(\"X-BAPI-API-KEY\", \u0026creds.api_key)\n                .header(\"X-BAPI-SIGN\", signature)\n                .header(\"X-BAPI-TIMESTAMP\", timestamp.to_string())\n                .header(\"X-BAPI-RECV-WINDOW\", recv_window)\n                .header(\"Content-Type\", \"application/json\");\n\n            if let Some(params) = params {\n                request = request.json(\u0026params);\n            }\n        }\n\n        let response = request\n            .send()\n            .await\n            .map_err(|e| ArbitrageError::network_error(format!(\"HTTP request failed: {}\", e)))?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_default();\n            return Err(ArbitrageError::api_error(format!(\n                \"Bybit API error: {}\",\n                error_text\n            )));\n        }\n\n        let json: Value = response\n            .json()\n            .await\n            .map_err(|e| ArbitrageError::parse_error(format!(\"Failed to parse JSON: {}\", e)))?;\n        Ok(json)\n    }\n}\n\nimpl ExchangeInterface for ExchangeService {\n    async fn save_api_key(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n    ) -\u003e ArbitrageResult\u003c()\u003e {\n        let key = format!(\"exchange_credentials_{}\", exchange_id);\n        let value = serde_json::to_string(credentials).map_err(|e| {\n            ArbitrageError::serialization_error(format!(\"Failed to serialize credentials: {}\", e))\n        })?;\n\n        self.kv.put(\u0026key, value)\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to save credentials: {}\", e))\n            })?\n            .execute()\n            .await\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to execute save: {}\", e))\n            })?;\n\n        Ok(())\n    }\n\n    async fn get_api_key(\u0026self, exchange_id: \u0026str) -\u003e ArbitrageResult\u003cOption\u003cExchangeCredentials\u003e\u003e {\n        let key = format!(\"exchange_credentials_{}\", exchange_id);\n        \n        match self.kv.get(\u0026key).text().await {\n            Ok(Some(value)) =\u003e {\n                let credentials: ExchangeCredentials = serde_json::from_str(\u0026value).map_err(|e| {\n                    ArbitrageError::parse_error(format!(\"Failed to deserialize credentials: {}\", e))\n                })?;\n                Ok(Some(credentials))\n            }\n            Ok(None) =\u003e Ok(None),\n            Err(e) =\u003e Err(ArbitrageError::database_error(format!(\"Failed to get credentials: {}\", e))),\n        }\n    }\n\n    async fn delete_api_key(\u0026self, exchange_id: \u0026str) -\u003e ArbitrageResult\u003c()\u003e {\n        let key = format!(\"exchange_credentials_{}\", exchange_id);\n        self.kv.delete(\u0026key)\n            .await\n            .map_err(|e| ArbitrageError::database_error(format!(\"Failed to delete credentials: {}\", e)))?;\n        Ok(())\n    }\n\n    async fn get_markets(\u0026self, exchange_id: \u0026str) -\u003e ArbitrageResult\u003cVec\u003cMarket\u003e\u003e {\n        let markets = match exchange_id {\n            \"binance\" =\u003e {\n                let response = self.binance_request(\"/api/v3/exchangeInfo\", Method::GET, None, None).await?;\n                let empty_vec = vec![];\n                let symbols = response[\"symbols\"].as_array().unwrap_or(\u0026empty_vec);\n                \n                symbols.iter().map(|symbol| {\n                    Market {\n                        id: symbol[\"symbol\"].as_str().unwrap_or(\"\").to_string(),\n                        symbol: symbol[\"symbol\"].as_str().unwrap_or(\"\").to_string(),\n                        base: symbol[\"baseAsset\"].as_str().unwrap_or(\"\").to_string(),\n                        quote: symbol[\"quoteAsset\"].as_str().unwrap_or(\"\").to_string(),\n                        active: symbol[\"status\"].as_str() == Some(\"TRADING\"),\n                        precision: Precision {\n                            amount: symbol[\"baseAssetPrecision\"].as_i64().map(|x| x as i32),\n                            price: symbol[\"quotePrecision\"].as_i64().map(|x| x as i32),\n                        },\n                        limits: Limits {\n                            amount: MinMax { min: Some(0.0), max: None },\n                            price: MinMax { min: Some(0.0), max: None },\n                            cost: MinMax { min: Some(0.0), max: None },\n                        },\n                        fees: None,\n                    }\n                }).collect()\n            }\n            \"bybit\" =\u003e {\n                let response = self.bybit_request(\"/v5/market/instruments-info\", Method::GET, Some(json!({\"category\": \"spot\"})), None).await?;\n                let empty_vec = vec![];\n                let symbols = response[\"result\"][\"list\"].as_array().unwrap_or(\u0026empty_vec);\n                \n                symbols.iter().map(|symbol| {\n                    Market {\n                        id: symbol[\"symbol\"].as_str().unwrap_or(\"\").to_string(),\n                        symbol: symbol[\"symbol\"].as_str().unwrap_or(\"\").to_string(),\n                        base: symbol[\"baseCoin\"].as_str().unwrap_or(\"\").to_string(),\n                        quote: symbol[\"quoteCoin\"].as_str().unwrap_or(\"\").to_string(),\n                        active: symbol[\"status\"].as_str() == Some(\"Trading\"),\n                        precision: Precision {\n                            amount: None,\n                            price: None,\n                        },\n                        limits: Limits {\n                            amount: MinMax { min: Some(0.0), max: None },\n                            price: MinMax { min: Some(0.0), max: None },\n                            cost: MinMax { min: Some(0.0), max: None },\n                        },\n                        fees: None,\n                    }\n                }).collect()\n            }\n            _ =\u003e return Err(ArbitrageError::validation_error(format!(\"Unsupported exchange: {}\", exchange_id))),\n        };\n\n        Ok(markets)\n    }\n\n    async fn get_ticker(\u0026self, exchange_id: \u0026str, symbol: \u0026str) -\u003e ArbitrageResult\u003cTicker\u003e {\n        match exchange_id {\n            \"binance\" =\u003e {\n                let response = self.binance_request(\n                    \"/api/v3/ticker/24hr\",\n                    Method::GET,\n                    Some(json!({\"symbol\": symbol})),\n                    None,\n                ).await?;\n                self.parse_binance_ticker(\u0026response, symbol)\n            }\n            \"bybit\" =\u003e {\n                let response = self.bybit_request(\n                    \"/v5/market/tickers\",\n                    Method::GET,\n                    Some(json!({\"category\": \"spot\", \"symbol\": symbol})),\n                    None,\n                ).await?;\n                \n                if let Some(list) = response[\"result\"][\"list\"].as_array() {\n                    if let Some(ticker_data) = list.first() {\n                        return self.parse_bybit_ticker(ticker_data, symbol);\n                    }\n                }\n                Err(ArbitrageError::not_found(format!(\"Ticker not found for symbol: {}\", symbol)))\n            }\n            _ =\u003e Err(ArbitrageError::validation_error(format!(\"Unsupported exchange: {}\", exchange_id))),\n        }\n    }\n\n    async fn get_orderbook(\n        \u0026self,\n        exchange_id: \u0026str,\n        symbol: \u0026str,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e ArbitrageResult\u003cOrderBook\u003e {\n        let limit = limit.unwrap_or(100);\n        \n        match exchange_id {\n            \"binance\" =\u003e {\n                let response = self.binance_request(\n                    \"/api/v3/depth\",\n                    Method::GET,\n                    Some(json!({\"symbol\": symbol, \"limit\": limit})),\n                    None,\n                ).await?;\n                \n                let empty_vec = vec![];\n                let bids: Vec\u003c[f64; 2]\u003e = response[\"bids\"].as_array()\n                    .unwrap_or(\u0026empty_vec)\n                    .iter()\n                    .filter_map(|bid| {\n                        if let Some(arr) = bid.as_array() {\n                            if arr.len() \u003e= 2 {\n                                let price = arr[0].as_str()?.parse().ok()?;\n                                let amount = arr[1].as_str()?.parse().ok()?;\n                                Some([price, amount])\n                            } else { None }\n                        } else { None }\n                    })\n                    .collect();\n                \n                let empty_vec2 = vec![];\n                let asks: Vec\u003c[f64; 2]\u003e = response[\"asks\"].as_array()\n                    .unwrap_or(\u0026empty_vec2)\n                    .iter()\n                    .filter_map(|ask| {\n                        if let Some(arr) = ask.as_array() {\n                            if arr.len() \u003e= 2 {\n                                let price = arr[0].as_str()?.parse().ok()?;\n                                let amount = arr[1].as_str()?.parse().ok()?;\n                                Some([price, amount])\n                            } else { None }\n                        } else { None }\n                    })\n                    .collect();\n                \n                Ok(OrderBook {\n                    symbol: symbol.to_string(),\n                    bids,\n                    asks,\n                    timestamp: Some(Utc::now()),\n                    datetime: Some(Utc::now().to_rfc3339()),\n                })\n            }\n            _ =\u003e Err(ArbitrageError::validation_error(format!(\"Unsupported exchange: {}\", exchange_id))),\n        }\n    }\n\n    async fn fetch_funding_rates(\n        \u0026self,\n        exchange_id: \u0026str,\n        symbol: Option\u003c\u0026str\u003e,\n    ) -\u003e ArbitrageResult\u003cVec\u003cValue\u003e\u003e {\n        match exchange_id {\n            \"binance\" =\u003e {\n                let mut params = json!({});\n                if let Some(s) = symbol {\n                    params[\"symbol\"] = json!(s);\n                }\n                \n                let response = self.binance_request(\n                    \"/fapi/v1/premiumIndex\",\n                    Method::GET,\n                    Some(params),\n                    None,\n                ).await?;\n                \n                if response.is_array() {\n                    Ok(response.as_array().unwrap().clone())\n                } else {\n                    Ok(vec![response])\n                }\n            }\n            _ =\u003e Err(ArbitrageError::validation_error(format!(\"Unsupported exchange: {}\", exchange_id))),\n        }\n    }\n\n    async fn get_balance(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n    ) -\u003e ArbitrageResult\u003cValue\u003e {\n        Err(ArbitrageError::not_implemented(format!(\n            \"get_balance not implemented for exchange: {}\", \n            exchange_id\n        )))\n    }\n\n    async fn create_order(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n        symbol: \u0026str,\n        side: \u0026str,\n        amount: f64,\n        price: Option\u003cf64\u003e,\n    ) -\u003e ArbitrageResult\u003cValue\u003e {\n        Err(ArbitrageError::not_implemented(format!(\n            \"create_order not implemented for exchange: {}\", \n            exchange_id\n        )))\n    }\n\n    async fn cancel_order(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n        order_id: \u0026str,\n        symbol: \u0026str,\n    ) -\u003e ArbitrageResult\u003cValue\u003e {\n        Err(ArbitrageError::not_implemented(format!(\n            \"cancel_order not implemented for exchange: {}\", \n            exchange_id\n        )))\n    }\n\n    async fn get_open_orders(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n        symbol: Option\u003c\u0026str\u003e,\n    ) -\u003e ArbitrageResult\u003cVec\u003cValue\u003e\u003e {\n        Err(ArbitrageError::not_implemented(format!(\n            \"get_open_orders not implemented for exchange: {}\", \n            exchange_id\n        )))\n    }\n\n    async fn get_open_positions(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n        symbol: Option\u003c\u0026str\u003e,\n    ) -\u003e ArbitrageResult\u003cVec\u003cValue\u003e\u003e {\n        Err(ArbitrageError::not_implemented(format!(\n            \"get_open_positions not implemented for exchange: {}\", \n            exchange_id\n        )))\n    }\n\n    async fn set_leverage(\n        \u0026self,\n        exchange_id: \u0026str,\n        credentials: \u0026ExchangeCredentials,\n        symbol: \u0026str,\n        leverage: u32,\n    ) -\u003e ArbitrageResult\u003cValue\u003e {\n        Err(ArbitrageError::not_implemented(format!(\n            \"set_leverage not implemented for exchange: {}\", \n            exchange_id\n        )))\n    }\n\n    async fn get_trading_fees(\n        \u0026self,\n        exchange_id: \u0026str,\n        _credentials: \u0026ExchangeCredentials,\n        symbol: \u0026str,\n    ) -\u003e ArbitrageResult\u003cValue\u003e {\n        match exchange_id {\n            \"binance\" =\u003e {\n                // Binance trading fees endpoint\n                let response = self.binance_request(\n                    \"/api/v3/exchangeInfo\",\n                    Method::GET,\n                    Some(json!({\"symbol\": symbol})),\n                    None,\n                ).await?;\n                \n                // Extract trading fees from exchange info\n                if let Some(symbols) = response[\"symbols\"].as_array() {\n                    for symbol_info in symbols {\n                        if symbol_info[\"symbol\"].as_str() == Some(symbol) {\n                            // Default Binance fees if not specified in response\n                            return Ok(json!({\n                                \"symbol\": symbol,\n                                \"maker\": 0.001,  // 0.1% default maker fee\n                                \"taker\": 0.001,  // 0.1% default taker fee\n                                \"exchange\": \"binance\"\n                            }));\n                        }\n                    }\n                }\n                \n                // Fallback to default fees\n                Ok(json!({\n                    \"symbol\": symbol,\n                    \"maker\": 0.001,\n                    \"taker\": 0.001,\n                    \"exchange\": \"binance\"\n                }))\n            }\n            \"bybit\" =\u003e {\n                // Bybit trading fees - using default rates as API requires authentication\n                Ok(json!({\n                    \"symbol\": symbol,\n                    \"maker\": 0.001,  // 0.1% default maker fee\n                    \"taker\": 0.001,  // 0.1% default taker fee  \n                    \"exchange\": \"bybit\"\n                }))\n            }\n            _ =\u003e Err(ArbitrageError::validation_error(format!(\n                \"get_trading_fees not implemented for exchange: {}\", \n                exchange_id\n            ))),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n    use chrono::Utc;\n    use std::collections::HashMap;\n\n    // Mock environment for testing\n    struct MockEnv {\n        kv: HashMap\u003cString, String\u003e,\n    }\n\n    impl MockEnv {\n        fn new() -\u003e Self {\n            Self {\n                kv: HashMap::new(),\n            }\n        }\n\n        fn with_kv_data(mut self, key: \u0026str, value: \u0026str) -\u003e Self {\n            self.kv.insert(key.to_string(), value.to_string());\n            self\n        }\n    }\n\n    // Helper function to create test credentials\n    fn create_test_credentials() -\u003e ExchangeCredentials {\n        ExchangeCredentials {\n            api_key: \"test_api_key\".to_string(),\n            secret: \"test_secret_key\".to_string(),\n            default_leverage: 20,\n            exchange_type: \"spot\".to_string(),\n        }\n    }\n\n    // Helper function to create mock Binance ticker data\n    fn create_mock_binance_ticker_data() -\u003e Value {\n        json!({\n            \"bidPrice\": \"50000.50\",\n            \"askPrice\": \"50001.00\",\n            \"price\": \"50000.75\",\n            \"highPrice\": \"51000.00\",\n            \"lowPrice\": \"49000.00\",\n            \"volume\": \"1234.56\"\n        })\n    }\n\n    // Helper function to create mock Bybit ticker data\n    fn create_mock_bybit_ticker_data() -\u003e Value {\n        json!({\n            \"bid1Price\": \"50000.50\",\n            \"ask1Price\": \"50001.00\",\n            \"lastPrice\": \"50000.75\",\n            \"highPrice24h\": \"51000.00\",\n            \"lowPrice24h\": \"49000.00\",\n            \"volume24h\": \"1234.56\"\n        })\n    }\n\n    // Tests for ticker parsing methods\n    mod ticker_parsing_tests {\n        use super::*;\n\n        #[test]\n        fn test_parse_binance_ticker_success() {\n            // Create a mock service (we only need the parsing method)\n            let env = MockEnv::new();\n            // Note: We can't easily create ExchangeService without Worker KV, \n            // so we'll test the data parsing logic directly with mock data\n            \n            let ticker_data = create_mock_binance_ticker_data();\n            let symbol = \"BTCUSDT\";\n\n            // Expected values from mock data\n            assert_eq!(ticker_data[\"bidPrice\"], \"50000.50\");\n            assert_eq!(ticker_data[\"askPrice\"], \"50001.00\");\n            assert_eq!(ticker_data[\"price\"], \"50000.75\");\n            assert_eq!(ticker_data[\"highPrice\"], \"51000.00\");\n            assert_eq!(ticker_data[\"lowPrice\"], \"49000.00\");\n            assert_eq!(ticker_data[\"volume\"], \"1234.56\");\n\n            // Test individual field parsing\n            let bid = ticker_data[\"bidPrice\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let ask = ticker_data[\"askPrice\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let last = ticker_data[\"price\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let high = ticker_data[\"highPrice\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let low = ticker_data[\"lowPrice\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let volume = ticker_data[\"volume\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n\n            assert_eq!(bid, Some(50000.50));\n            assert_eq!(ask, Some(50001.00));\n            assert_eq!(last, Some(50000.75));\n            assert_eq!(high, Some(51000.00));\n            assert_eq!(low, Some(49000.00));\n            assert_eq!(volume, Some(1234.56));\n        }\n\n        #[test]\n        fn test_parse_bybit_ticker_success() {\n            let ticker_data = create_mock_bybit_ticker_data();\n            let symbol = \"BTCUSDT\";\n\n            // Expected values from mock data\n            assert_eq!(ticker_data[\"bid1Price\"], \"50000.50\");\n            assert_eq!(ticker_data[\"ask1Price\"], \"50001.00\");\n            assert_eq!(ticker_data[\"lastPrice\"], \"50000.75\");\n            assert_eq!(ticker_data[\"highPrice24h\"], \"51000.00\");\n            assert_eq!(ticker_data[\"lowPrice24h\"], \"49000.00\");\n            assert_eq!(ticker_data[\"volume24h\"], \"1234.56\");\n\n            // Test individual field parsing (Bybit format)\n            let bid = ticker_data[\"bid1Price\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let ask = ticker_data[\"ask1Price\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let last = ticker_data[\"lastPrice\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let high = ticker_data[\"highPrice24h\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let low = ticker_data[\"lowPrice24h\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let volume = ticker_data[\"volume24h\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n\n            assert_eq!(bid, Some(50000.50));\n            assert_eq!(ask, Some(50001.00));\n            assert_eq!(last, Some(50000.75));\n            assert_eq!(high, Some(51000.00));\n            assert_eq!(low, Some(49000.00));\n            assert_eq!(volume, Some(1234.56));\n        }\n\n        #[test]\n        fn test_binance_ticker_parsing_with_invalid_data() {\n            // Test with malformed price data\n            let invalid_data = json!({\n                \"bidPrice\": \"invalid_price\",\n                \"askPrice\": \"50001.00\",\n                \"price\": \"\",\n                \"highPrice\": null,\n                \"lowPrice\": \"49000.00\",\n                \"volume\": \"not_a_number\"\n            });\n\n            // Test parsing - invalid strings should return None\n            let bid = invalid_data[\"bidPrice\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let ask = invalid_data[\"askPrice\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let last = invalid_data[\"price\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let high = invalid_data[\"highPrice\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let low = invalid_data[\"lowPrice\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let volume = invalid_data[\"volume\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n\n            assert_eq!(bid, None); // Invalid price string\n            assert_eq!(ask, Some(50001.00)); // Valid price\n            assert_eq!(last, None); // Empty string\n            assert_eq!(high, None); // Null value\n            assert_eq!(low, Some(49000.00)); // Valid price\n            assert_eq!(volume, None); // Invalid number string\n        }\n\n        #[test]\n        fn test_ticker_field_extraction_edge_cases() {\n            // Test with missing fields\n            let minimal_data = json!({\n                \"bidPrice\": \"50000.50\"\n                // Missing other fields\n            });\n\n            let bid = minimal_data[\"bidPrice\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let ask = minimal_data[\"askPrice\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let last = minimal_data[\"price\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n\n            assert_eq!(bid, Some(50000.50));\n            assert_eq!(ask, None); // Missing field\n            assert_eq!(last, None); // Missing field\n        }\n    }\n\n    // Tests for signature generation and authentication\n    mod authentication_tests {\n        use super::*;\n        use hmac::{Hmac, Mac};\n        use sha2::Sha256;\n\n        #[test]\n        fn test_hmac_signature_generation() {\n            let secret = \"test_secret_key\";\n            let message = \"timestamp=1234567890\u0026symbol=BTCUSDT\";\n\n            // Test HMAC-SHA256 signature generation (same as used in binance_request)\n            let mut mac = Hmac::\u003cSha256\u003e::new_from_slice(secret.as_bytes()).unwrap();\n            mac.update(message.as_bytes());\n            let signature = hex::encode(mac.finalize().into_bytes());\n\n            // Signature should be consistent\n            assert!(!signature.is_empty());\n            assert_eq!(signature.len(), 64); // SHA256 hex string length\n\n            // Test with same input should produce same signature\n            let mut mac2 = Hmac::\u003cSha256\u003e::new_from_slice(secret.as_bytes()).unwrap();\n            mac2.update(message.as_bytes());\n            let signature2 = hex::encode(mac2.finalize().into_bytes());\n\n            assert_eq!(signature, signature2);\n        }\n\n        #[test]\n        fn test_query_parameter_sorting() {\n            // Test query parameter sorting logic (used in binance authentication)\n            let mut params = vec![\n                (\"symbol\".to_string(), \"BTCUSDT\".to_string()),\n                (\"timestamp\".to_string(), \"1234567890\".to_string()),\n                (\"limit\".to_string(), \"100\".to_string()),\n            ];\n\n            params.sort();\n            let query_string = params\n                .iter()\n                .map(|(k, v)| format!(\"{}={}\", k, v))\n                .collect::\u003cVec\u003c_\u003e\u003e()\n                .join(\"\u0026\");\n\n            assert_eq!(query_string, \"limit=100\u0026symbol=BTCUSDT\u0026timestamp=1234567890\");\n        }\n\n        #[test]\n        fn test_credentials_structure() {\n            let creds = create_test_credentials();\n            \n            assert_eq!(creds.api_key, \"test_api_key\");\n            assert_eq!(creds.secret, \"test_secret_key\");\n            assert_eq!(creds.default_leverage, 20);\n            assert_eq!(creds.exchange_type, \"spot\");\n        }\n\n        #[test]\n        fn test_credentials_serialization() {\n            let credentials = create_test_credentials();\n            \n            // Test that credentials can be serialized and deserialized\n            let serialized = serde_json::to_string(\u0026credentials).unwrap();\n            let deserialized: ExchangeCredentials = serde_json::from_str(\u0026serialized).unwrap();\n            \n            assert_eq!(credentials.api_key, deserialized.api_key);\n            assert_eq!(credentials.secret, deserialized.secret);\n            assert_eq!(credentials.default_leverage, deserialized.default_leverage);\n            assert_eq!(credentials.exchange_type, deserialized.exchange_type);\n        }\n    }\n\n    // Tests for market data parsing\n    mod market_data_tests {\n        use super::*;\n\n        #[test]\n        fn test_binance_market_parsing() {\n            let market_data = json!({\n                \"symbol\": \"BTCUSDT\",\n                \"baseAsset\": \"BTC\",\n                \"quoteAsset\": \"USDT\",\n                \"status\": \"TRADING\",\n                \"baseAssetPrecision\": 8,\n                \"quotePrecision\": 8\n            });\n\n            // Test individual field extraction\n            let symbol = market_data[\"symbol\"].as_str().unwrap_or(\"\");\n            let base = market_data[\"baseAsset\"].as_str().unwrap_or(\"\");\n            let quote = market_data[\"quoteAsset\"].as_str().unwrap_or(\"\");\n            let active = market_data[\"status\"].as_str() == Some(\"TRADING\");\n            let base_precision = market_data[\"baseAssetPrecision\"].as_i64().map(|x| x as i32);\n            let quote_precision = market_data[\"quotePrecision\"].as_i64().map(|x| x as i32);\n\n            assert_eq!(symbol, \"BTCUSDT\");\n            assert_eq!(base, \"BTC\");\n            assert_eq!(quote, \"USDT\");\n            assert_eq!(active, true);\n            assert_eq!(base_precision, Some(8));\n            assert_eq!(quote_precision, Some(8));\n        }\n\n        #[test]\n        fn test_bybit_market_parsing() {\n            let market_data = json!({\n                \"symbol\": \"BTCUSDT\",\n                \"baseCoin\": \"BTC\",\n                \"quoteCoin\": \"USDT\",\n                \"status\": \"Trading\"\n            });\n\n            // Test individual field extraction (Bybit format)\n            let symbol = market_data[\"symbol\"].as_str().unwrap_or(\"\");\n            let base = market_data[\"baseCoin\"].as_str().unwrap_or(\"\");\n            let quote = market_data[\"quoteCoin\"].as_str().unwrap_or(\"\");\n            let active = market_data[\"status\"].as_str() == Some(\"Trading\");\n\n            assert_eq!(symbol, \"BTCUSDT\");\n            assert_eq!(base, \"BTC\");\n            assert_eq!(quote, \"USDT\");\n            assert_eq!(active, true);\n        }\n\n        #[test]\n        fn test_inactive_market_detection() {\n            // Test inactive market for Binance\n            let inactive_binance = json!({\n                \"symbol\": \"OLDCOIN\",\n                \"status\": \"HALT\"\n            });\n            let active = inactive_binance[\"status\"].as_str() == Some(\"TRADING\");\n            assert_eq!(active, false);\n\n            // Test inactive market for Bybit\n            let inactive_bybit = json!({\n                \"symbol\": \"OLDCOIN\",\n                \"status\": \"Closed\"\n            });\n            let active_bybit = inactive_bybit[\"status\"].as_str() == Some(\"Trading\");\n            assert_eq!(active_bybit, false);\n        }\n    }\n\n    // Tests for orderbook parsing\n    mod orderbook_tests {\n        use super::*;\n\n        #[test]\n        fn test_binance_orderbook_parsing() {\n            let orderbook_data = json!({\n                \"bids\": [\n                    [\"50000.50\", \"1.5\"],\n                    [\"50000.00\", \"2.0\"],\n                    [\"49999.50\", \"0.5\"]\n                ],\n                \"asks\": [\n                    [\"50001.00\", \"1.2\"],\n                    [\"50001.50\", \"1.8\"],\n                    [\"50002.00\", \"0.3\"]\n                ]\n            });\n\n            // Test bid parsing\n            let empty_vec = vec![];\n            let bids: Vec\u003c[f64; 2]\u003e = orderbook_data[\"bids\"].as_array()\n                .unwrap_or(\u0026empty_vec)\n                .iter()\n                .filter_map(|bid| {\n                    if let Some(arr) = bid.as_array() {\n                        if arr.len() \u003e= 2 {\n                            let price = arr[0].as_str()?.parse().ok()?;\n                            let amount = arr[1].as_str()?.parse().ok()?;\n                            Some([price, amount])\n                        } else { None }\n                    } else { None }\n                })\n                .collect();\n\n            assert_eq!(bids.len(), 3);\n            assert_eq!(bids[0], [50000.50, 1.5]);\n            assert_eq!(bids[1], [50000.00, 2.0]);\n            assert_eq!(bids[2], [49999.50, 0.5]);\n\n            // Test ask parsing\n            let empty_vec2 = vec![];\n            let asks: Vec\u003c[f64; 2]\u003e = orderbook_data[\"asks\"].as_array()\n                .unwrap_or(\u0026empty_vec2)\n                .iter()\n                .filter_map(|ask| {\n                    if let Some(arr) = ask.as_array() {\n                        if arr.len() \u003e= 2 {\n                            let price = arr[0].as_str()?.parse().ok()?;\n                            let amount = arr[1].as_str()?.parse().ok()?;\n                            Some([price, amount])\n                        } else { None }\n                    } else { None }\n                })\n                .collect();\n\n            assert_eq!(asks.len(), 3);\n            assert_eq!(asks[0], [50001.00, 1.2]);\n            assert_eq!(asks[1], [50001.50, 1.8]);\n            assert_eq!(asks[2], [50002.00, 0.3]);\n        }\n\n        #[test]\n        fn test_malformed_orderbook_data() {\n            let malformed_data = json!({\n                \"bids\": [\n                    [\"invalid_price\", \"1.5\"],\n                    [\"50000.00\"], // Missing amount\n                    null, // Null entry\n                    [\"49999.50\", \"invalid_amount\"]\n                ],\n                \"asks\": []\n            });\n\n            // Test that malformed entries are filtered out\n            let empty_vec = vec![];\n            let bids: Vec\u003c[f64; 2]\u003e = malformed_data[\"bids\"].as_array()\n                .unwrap_or(\u0026empty_vec)\n                .iter()\n                .filter_map(|bid| {\n                    if let Some(arr) = bid.as_array() {\n                        if arr.len() \u003e= 2 {\n                            let price = arr[0].as_str()?.parse().ok()?;\n                            let amount = arr[1].as_str()?.parse().ok()?;\n                            Some([price, amount])\n                        } else { None }\n                    } else { None }\n                })\n                .collect();\n\n            // Only valid entries should remain (none in this case)\n            assert_eq!(bids.len(), 0);\n        }\n\n        #[test]\n        fn test_empty_orderbook() {\n            let empty_data = json!({\n                \"bids\": [],\n                \"asks\": []\n            });\n\n            let empty_vec = vec![];\n            let bids: Vec\u003c[f64; 2]\u003e = empty_data[\"bids\"].as_array()\n                .unwrap_or(\u0026empty_vec)\n                .iter()\n                .filter_map(|bid| {\n                    if let Some(arr) = bid.as_array() {\n                        if arr.len() \u003e= 2 {\n                            let price = arr[0].as_str()?.parse().ok()?;\n                            let amount = arr[1].as_str()?.parse().ok()?;\n                            Some([price, amount])\n                        } else { None }\n                    } else { None }\n                })\n                .collect();\n\n            let empty_vec2 = vec![];\n            let asks: Vec\u003c[f64; 2]\u003e = empty_data[\"asks\"].as_array()\n                .unwrap_or(\u0026empty_vec2)\n                .iter()\n                .filter_map(|ask| {\n                    if let Some(arr) = ask.as_array() {\n                        if arr.len() \u003e= 2 {\n                            let price = arr[0].as_str()?.parse().ok()?;\n                            let amount = arr[1].as_str()?.parse().ok()?;\n                            Some([price, amount])\n                        } else { None }\n                    } else { None }\n                })\n                .collect();\n\n            assert_eq!(bids.len(), 0);\n            assert_eq!(asks.len(), 0);\n        }\n    }\n\n    // Tests for funding rate data\n    mod funding_rate_tests {\n        use super::*;\n\n        #[test]\n        fn test_binance_funding_rate_single_symbol() {\n            let funding_data = json!({\n                \"symbol\": \"BTCUSDT\",\n                \"markPrice\": \"50000.12345678\",\n                \"indexPrice\": \"50000.01234567\", \n                \"estimatedSettlePrice\": \"50000.01234567\",\n                \"lastFundingRate\": \"0.00010000\",\n                \"nextFundingTime\": 1234567890000_u64,\n                \"interestRate\": \"0.00010000\",\n                \"time\": 1234567890000_u64\n            });\n\n            // Test that we can extract relevant funding rate information\n            let symbol = funding_data[\"symbol\"].as_str().unwrap_or(\"\");\n            let funding_rate = funding_data[\"lastFundingRate\"].as_str()\n                .and_then(|s| s.parse::\u003cf64\u003e().ok());\n            let next_funding_time = funding_data[\"nextFundingTime\"].as_u64();\n\n            assert_eq!(symbol, \"BTCUSDT\");\n            assert_eq!(funding_rate, Some(0.00010000));\n            assert_eq!(next_funding_time, Some(1234567890000));\n        }\n\n        #[test]\n        fn test_binance_funding_rate_array_response() {\n            let funding_array = json!([\n                {\n                    \"symbol\": \"BTCUSDT\",\n                    \"lastFundingRate\": \"0.00010000\"\n                },\n                {\n                    \"symbol\": \"ETHUSDT\", \n                    \"lastFundingRate\": \"0.00015000\"\n                }\n            ]);\n\n            // Test array processing\n            if let Some(arr) = funding_array.as_array() {\n                assert_eq!(arr.len(), 2);\n                \n                let btc_rate = arr[0][\"lastFundingRate\"].as_str()\n                    .and_then(|s| s.parse::\u003cf64\u003e().ok());\n                let eth_rate = arr[1][\"lastFundingRate\"].as_str()\n                    .and_then(|s| s.parse::\u003cf64\u003e().ok());\n\n                assert_eq!(btc_rate, Some(0.00010000));\n                assert_eq!(eth_rate, Some(0.00015000));\n            } else {\n                panic!(\"Expected array response\");\n            }\n        }\n    }\n\n    // Tests for exchange validation and error handling\n    mod validation_tests {\n        use super::*;\n\n        #[test]\n        fn test_supported_exchanges() {\n            let supported_exchanges = vec![\"binance\", \"bybit\"];\n            \n            for exchange in supported_exchanges {\n                // These should not return validation errors for basic checks\n                assert!(!exchange.is_empty());\n                assert!(exchange.len() \u003e 2);\n            }\n        }\n\n        #[test]\n        fn test_unsupported_exchange_detection() {\n            let unsupported_exchanges = vec![\"coinbase\", \"kraken\", \"ftx\", \"\"];\n            \n            // Test that unsupported exchange names would trigger validation errors\n            for exchange in unsupported_exchanges {\n                match exchange {\n                    \"binance\" | \"bybit\" =\u003e {\n                        // These should be supported\n                        assert!(false, \"Should not reach here for supported exchanges\");\n                    }\n                    _ =\u003e {\n                        // These should be unsupported\n                        assert!(true, \"Correctly identified as unsupported: {}\", exchange);\n                    }\n                }\n            }\n        }\n\n        #[test]\n        fn test_symbol_validation() {\n            let valid_symbols = vec![\"BTCUSDT\", \"ETHUSDT\", \"ADAUSDT\"];\n            let invalid_symbols = vec![\"\", \"BTC\", \"invalid_symbol_format\"];\n\n            for symbol in valid_symbols {\n                assert!(!symbol.is_empty());\n                assert!(symbol.len() \u003e= 6); // Minimum length for base+quote\n                assert!(symbol.chars().all(|c| c.is_ascii_uppercase()));\n            }\n\n            for symbol in invalid_symbols {\n                // These would trigger validation in real implementation\n                if symbol.is_empty() || symbol.len() \u003c 6 {\n                    assert!(true, \"Correctly identified as invalid: {}\", symbol);\n                }\n            }\n        }\n    }\n\n    // Tests for KV storage key generation\n    mod storage_tests {\n        use super::*;\n\n        #[test]\n        fn test_kv_key_generation() {\n            let exchange_id = \"binance\";\n            let expected_key = format!(\"exchange_credentials_{}\", exchange_id);\n            \n            assert_eq!(expected_key, \"exchange_credentials_binance\");\n        }\n\n        #[test]\n        fn test_kv_key_generation_different_exchanges() {\n            let exchanges = vec![\"binance\", \"bybit\", \"okx\"];\n            \n            for exchange in exchanges {\n                let key = format!(\"exchange_credentials_{}\", exchange);\n                assert!(key.starts_with(\"exchange_credentials_\"));\n                assert!(key.ends_with(exchange));\n            }\n        }\n    }\n\n    // Tests for error scenarios that should be handled\n    mod error_handling_tests {\n        use super::*;\n\n        #[test]\n        fn test_error_type_construction() {\n            // Test different error types that the service should handle\n            let network_error = ArbitrageError::network_error(\"Connection failed\".to_string());\n            let api_error = ArbitrageError::api_error(\"API rate limit\".to_string());\n            let parse_error = ArbitrageError::parse_error(\"Invalid JSON\".to_string());\n            let auth_error = ArbitrageError::authentication_error(\"Invalid credentials\".to_string());\n\n            // Verify error messages contain expected content\n            assert!(network_error.to_string().contains(\"Connection failed\"));\n            assert!(api_error.to_string().contains(\"API rate limit\"));\n            assert!(parse_error.to_string().contains(\"Invalid JSON\"));\n            assert!(auth_error.to_string().contains(\"Invalid credentials\"));\n        }\n\n        #[test]\n        fn test_not_implemented_methods() {\n            // Test that not-implemented methods return appropriate errors\n            let exchange_id = \"binance\";\n            let error_msg = format!(\"get_balance not implemented for exchange: {}\", exchange_id);\n            \n            assert!(error_msg.contains(\"not implemented\"));\n            assert!(error_msg.contains(exchange_id));\n        }\n\n        #[test]\n        fn test_empty_response_handling() {\n            // Test handling of empty or null responses\n            let empty_json = json!({});\n            let null_json = json!(null);\n            let missing_field = json!({\"other_field\": \"value\"});\n\n            // Test that missing fields are handled gracefully\n            assert!(empty_json[\"nonexistent\"].is_null());\n            assert!(null_json.is_null());\n            assert!(missing_field[\"expected_field\"].is_null());\n        }\n    }\n\n    // Integration-style tests for business logic\n    mod business_logic_tests {\n        use super::*;\n\n        #[test]\n        fn test_complete_ticker_flow() {\n            // Test the complete flow of ticker data processing\n            let mock_binance_response = create_mock_binance_ticker_data();\n            let symbol = \"BTCUSDT\";\n\n            // Simulate the ticker parsing logic\n            let ticker = Ticker {\n                symbol: symbol.to_string(),\n                bid: mock_binance_response[\"bidPrice\"].as_str().and_then(|s| s.parse().ok()),\n                ask: mock_binance_response[\"askPrice\"].as_str().and_then(|s| s.parse().ok()),\n                last: mock_binance_response[\"price\"].as_str().and_then(|s| s.parse().ok()),\n                high: mock_binance_response[\"highPrice\"].as_str().and_then(|s| s.parse().ok()),\n                low: mock_binance_response[\"lowPrice\"].as_str().and_then(|s| s.parse().ok()),\n                volume: mock_binance_response[\"volume\"].as_str().and_then(|s| s.parse().ok()),\n                timestamp: Some(Utc::now()),\n                datetime: Some(Utc::now().to_rfc3339()),\n            };\n\n            // Verify complete ticker structure\n            assert_eq!(ticker.symbol, \"BTCUSDT\");\n            assert_eq!(ticker.bid, Some(50000.5));\n            assert_eq!(ticker.ask, Some(50001.0));\n            assert_eq!(ticker.last, Some(50000.75));\n            assert_eq!(ticker.high, Some(51000.0));\n            assert_eq!(ticker.low, Some(49000.0));\n            assert_eq!(ticker.volume, Some(1234.56));\n            assert!(ticker.timestamp.is_some());\n            assert!(ticker.datetime.is_some());\n        }\n\n        #[test]\n        fn test_market_structure_creation() {\n            // Test creating a complete Market structure\n            let market = Market {\n                id: \"BTCUSDT\".to_string(),\n                symbol: \"BTCUSDT\".to_string(),\n                base: \"BTC\".to_string(),\n                quote: \"USDT\".to_string(),\n                active: true,\n                precision: Precision {\n                    amount: Some(8),\n                    price: Some(8),\n                },\n                limits: Limits {\n                    amount: MinMax { min: Some(0.001), max: Some(1000.0) },\n                    price: MinMax { min: Some(0.01), max: Some(100000.0) },\n                    cost: MinMax { min: Some(10.0), max: None },\n                },\n                fees: None,\n            };\n\n            // Verify market structure\n            assert_eq!(market.symbol, \"BTCUSDT\");\n            assert_eq!(market.base, \"BTC\");\n            assert_eq!(market.quote, \"USDT\");\n            assert_eq!(market.active, true);\n            assert_eq!(market.precision.amount, Some(8));\n            assert_eq!(market.precision.price, Some(8));\n        }\n\n        #[test]\n        fn test_orderbook_structure_creation() {\n            // Test creating a complete OrderBook structure\n            let orderbook = OrderBook {\n                symbol: \"BTCUSDT\".to_string(),\n                bids: vec![\n                    [50000.50, 1.5],\n                    [50000.00, 2.0],\n                ],\n                asks: vec![\n                    [50001.00, 1.2],\n                    [50001.50, 1.8],\n                ],\n                timestamp: Some(Utc::now()),\n                datetime: Some(Utc::now().to_rfc3339()),\n            };\n\n            // Verify orderbook structure\n            assert_eq!(orderbook.symbol, \"BTCUSDT\");\n            assert_eq!(orderbook.bids.len(), 2);\n            assert_eq!(orderbook.asks.len(), 2);\n            assert_eq!(orderbook.bids[0], [50000.50, 1.5]);\n            assert_eq!(orderbook.asks[0], [50001.00, 1.2]);\n            assert!(orderbook.timestamp.is_some());\n        }\n    }\n\n    mod service_integration_tests {\n        use super::*;\n        use std::collections::HashMap;\n\n        // Test the business logic without requiring actual worker environment\n        \n        #[test]\n        fn test_exchange_service_ticker_parsing_integration() {\n            // Test binance ticker parsing logic\n            let binance_data = create_mock_binance_ticker_data();\n            \n            // Manually test the parsing logic that would be used in parse_binance_ticker\n            let _symbol = \"BTCUSDT\";\n            let bid = binance_data[\"bidPrice\"].as_str().and_then(|s| s.parse().ok());\n            let ask = binance_data[\"askPrice\"].as_str().and_then(|s| s.parse().ok());\n            let last = binance_data[\"price\"].as_str().and_then(|s| s.parse().ok());\n            \n            // Update expected values to match the mock data\n            assert_eq!(bid, Some(50000.5));  // Changed from 50000.0 to 50000.5\n            assert_eq!(ask, Some(50001.0));  // Changed from 50050.0 to 50001.0\n            assert_eq!(last, Some(50000.75)); // Changed from 50025.0 to 50000.75\n            \n            // Test bybit ticker parsing logic\n            let bybit_data = create_mock_bybit_ticker_data();\n            let bid = bybit_data[\"bid1Price\"].as_str().and_then(|s| s.parse().ok());\n            let ask = bybit_data[\"ask1Price\"].as_str().and_then(|s| s.parse().ok());\n            let last = bybit_data[\"lastPrice\"].as_str().and_then(|s| s.parse().ok());\n            \n            // Update expected values to match the mock data  \n            assert_eq!(bid, Some(50000.5));  // Changed from 49999.0 to 50000.5\n            assert_eq!(ask, Some(50001.0));  // Same value\n            assert_eq!(last, Some(50000.75)); // Changed from 50000.0 to 50000.75\n        }\n\n        #[test]\n        fn test_exchange_credentials_key_generation() {\n            // Test the key generation logic for API credentials\n            let exchange_id = \"binance\";\n            let expected_key = format!(\"exchange_credentials_{}\", exchange_id);\n            assert_eq!(expected_key, \"exchange_credentials_binance\");\n            \n            let exchange_id = \"bybit\";\n            let expected_key = format!(\"exchange_credentials_{}\", exchange_id);\n            assert_eq!(expected_key, \"exchange_credentials_bybit\");\n        }\n\n        #[test]\n        fn test_exchange_credentials_serialization() {\n            let credentials = create_test_credentials();\n            \n            // Test that credentials can be serialized and deserialized\n            let serialized = serde_json::to_string(\u0026credentials).unwrap();\n            let deserialized: ExchangeCredentials = serde_json::from_str(\u0026serialized).unwrap();\n            \n            assert_eq!(credentials.api_key, deserialized.api_key);\n            assert_eq!(credentials.secret, deserialized.secret);\n            assert_eq!(credentials.default_leverage, deserialized.default_leverage);\n            assert_eq!(credentials.exchange_type, deserialized.exchange_type);\n        }\n\n        #[test]\n        fn test_exchange_orderbook_parsing_logic() {\n            // Test orderbook parsing logic for Binance format\n            let orderbook_data = json!({\n                \"bids\": [\n                    [\"50000.00\", \"1.50\"],\n                    [\"49999.00\", \"2.00\"],\n                    [\"49998.00\", \"0.50\"]\n                ],\n                \"asks\": [\n                    [\"50001.00\", \"1.00\"],\n                    [\"50002.00\", \"1.20\"],\n                    [\"50003.00\", \"0.80\"]\n                ]\n            });\n            \n            let empty_vec = vec![];\n            let bids: Vec\u003c[f64; 2]\u003e = orderbook_data[\"bids\"].as_array()\n                .unwrap_or(\u0026empty_vec)\n                .iter()\n                .filter_map(|bid| {\n                    if let Some(arr) = bid.as_array() {\n                        if arr.len() \u003e= 2 {\n                            let price = arr[0].as_str()?.parse().ok()?;\n                            let amount = arr[1].as_str()?.parse().ok()?;\n                            Some([price, amount])\n                        } else { None }\n                    } else { None }\n                })\n                .collect();\n            \n            assert_eq!(bids.len(), 3);\n            assert_eq!(bids[0], [50000.0, 1.5]);\n            assert_eq!(bids[1], [49999.0, 2.0]);\n            assert_eq!(bids[2], [49998.0, 0.5]);\n        }\n\n        #[test]\n        fn test_market_data_structure_validation() {\n            // Test that market data structures are properly formed\n            let market = Market {\n                id: \"BTCUSDT\".to_string(),\n                symbol: \"BTCUSDT\".to_string(),\n                base: \"BTC\".to_string(),\n                quote: \"USDT\".to_string(),\n                active: true,\n                precision: Precision {\n                    amount: Some(8),\n                    price: Some(2),\n                },\n                limits: Limits {\n                    amount: MinMax { min: Some(0.001), max: Some(1000.0) },\n                    price: MinMax { min: Some(0.01), max: Some(100000.0) },\n                    cost: MinMax { min: Some(10.0), max: None },\n                },\n                fees: None,\n            };\n            \n            assert_eq!(market.symbol, \"BTCUSDT\");\n            assert_eq!(market.base, \"BTC\");\n            assert_eq!(market.quote, \"USDT\");\n            assert!(market.active);\n            assert_eq!(market.precision.amount, Some(8));\n            assert_eq!(market.precision.price, Some(2));\n        }\n\n        #[test]\n        fn test_orderbook_data_structure_validation() {\n            // Test OrderBook structure creation and validation\n            let orderbook = OrderBook {\n                symbol: \"BTCUSDT\".to_string(),\n                bids: vec![[50000.0, 1.5], [49999.0, 2.0], [49998.0, 0.5]],\n                asks: vec![[50001.0, 1.0], [50002.0, 1.2], [50003.0, 0.8]],\n                timestamp: Some(Utc::now()),\n                datetime: Some(Utc::now().to_rfc3339()),\n            };\n            \n            assert_eq!(orderbook.symbol, \"BTCUSDT\");\n            assert_eq!(orderbook.bids.len(), 3);\n            assert_eq!(orderbook.asks.len(), 3);\n            \n            // Verify bid/ask ordering assumptions\n            assert!(orderbook.bids[0][0] \u003e orderbook.bids[1][0]); // Bids should be descending price\n            assert!(orderbook.asks[0][0] \u003c orderbook.asks[1][0]); // Asks should be ascending price\n            \n            // Verify spread\n            let best_bid = orderbook.bids[0][0];\n            let best_ask = orderbook.asks[0][0];\n            assert!(best_ask \u003e best_bid); // Spread should be positive\n        }\n\n        #[test]\n        fn test_ticker_data_structure_validation() {\n            let ticker = Ticker {\n                symbol: \"BTCUSDT\".to_string(),\n                bid: Some(50000.0),\n                ask: Some(50050.0),\n                last: Some(50025.0),\n                high: Some(51000.0),\n                low: Some(49000.0),\n                volume: Some(1234.56),\n                timestamp: Some(Utc::now()),\n                datetime: Some(Utc::now().to_rfc3339()),\n            };\n            \n            assert_eq!(ticker.symbol, \"BTCUSDT\");\n            assert!(ticker.bid.is_some());\n            assert!(ticker.ask.is_some());\n            assert!(ticker.last.is_some());\n            \n            // Verify bid/ask relationship\n            if let (Some(bid), Some(ask)) = (ticker.bid, ticker.ask) {\n                assert!(ask \u003e= bid); // Ask should be \u003e= bid\n            }\n            \n            // Verify high/low relationship\n            if let (Some(high), Some(low), Some(last)) = (ticker.high, ticker.low, ticker.last) {\n                assert!(high \u003e= low); // High should be \u003e= low\n                assert!(last \u003e= low \u0026\u0026 last \u003c= high); // Last should be within high/low range\n            }\n        }\n\n        #[test]\n        fn test_exchange_credentials_validation() {\n            let credentials = create_test_credentials();\n            \n            // Test that credentials have required fields\n            assert!(!credentials.api_key.is_empty());\n            assert!(!credentials.secret.is_empty());\n            \n            // Test default leverage\n            assert!(credentials.default_leverage \u003e 0);\n            \n            // Test exchange type\n            assert!(!credentials.exchange_type.is_empty());\n        }\n\n        #[test]\n        fn test_funding_rate_data_structure() {\n            // Test funding rate data structure validation\n            let funding_rate_data = json!({\n                \"symbol\": \"BTCUSDT\",\n                \"fundingRate\": \"0.0001\",\n                \"fundingTime\": 1234567890000u64,\n                \"nextFundingTime\": 1234567890000u64 + 28800000\n            });\n            \n            assert_eq!(funding_rate_data[\"symbol\"].as_str().unwrap(), \"BTCUSDT\");\n            assert_eq!(funding_rate_data[\"fundingRate\"].as_str().unwrap(), \"0.0001\");\n            assert!(funding_rate_data[\"fundingTime\"].as_u64().is_some());\n            assert!(funding_rate_data[\"nextFundingTime\"].as_u64().is_some());\n        }\n\n        #[test]\n        fn test_exchange_api_parameter_handling() {\n            // Test parameter handling for API requests\n            let symbol = \"BTCUSDT\";\n            let limit = 100u32;\n            \n            // Test Binance-style parameters\n            let binance_params = json!({\n                \"symbol\": symbol,\n                \"limit\": limit\n            });\n            \n            assert_eq!(binance_params[\"symbol\"].as_str().unwrap(), \"BTCUSDT\");\n            assert_eq!(binance_params[\"limit\"].as_u64().unwrap(), 100);\n            \n            // Test Bybit-style parameters\n            let bybit_params = json!({\n                \"category\": \"spot\",\n                \"symbol\": symbol\n            });\n            \n            assert_eq!(bybit_params[\"category\"].as_str().unwrap(), \"spot\");\n            assert_eq!(bybit_params[\"symbol\"].as_str().unwrap(), \"BTCUSDT\");\n        }\n\n        #[test]\n        fn test_exchange_error_handling_logic() {\n            // Test error handling for various scenarios\n            \n            // Test empty market data\n            let empty_markets: Vec\u003cValue\u003e = vec![];\n            assert_eq!(empty_markets.len(), 0);\n            \n            // Test invalid ticker data\n            let invalid_ticker = json!({\n                \"symbol\": \"INVALID\",\n                \"price\": \"not_a_number\"\n            });\n            \n            let parsed_price = invalid_ticker[\"price\"].as_str().and_then(|s| s.parse::\u003cf64\u003e().ok());\n            assert!(parsed_price.is_none());\n            \n            // Test missing required fields\n            let incomplete_data = json!({\n                \"symbol\": \"BTCUSDT\"\n                // Missing other required fields\n            });\n            \n            assert!(incomplete_data[\"bidPrice\"].as_str().is_none());\n            assert!(incomplete_data[\"askPrice\"].as_str().is_none());\n        }\n    }\n}\n","traces":[{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":295},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","services","global_opportunity.rs"],"content":"// src/services/global_opportunity.rs\n\nuse crate::types::{\n    ArbitrageOpportunity, ArbitrageType, ExchangeIdEnum, FundingRateInfo,\n    GlobalOpportunity, OpportunityQueue, OpportunitySource, DistributionStrategy,\n    UserOpportunityDistribution, GlobalOpportunityConfig, FairnessConfig,\n    UserProfile, SubscriptionTier\n};\nuse crate::utils::{ArbitrageError, ArbitrageResult};\nuse crate::services::exchange::{ExchangeService, ExchangeInterface};\nuse crate::services::user_profile::UserProfileService;\nuse crate::{log_info, log_error, log_debug};\nuse std::sync::Arc;\nuse std::collections::HashMap;\nuse futures::future::join_all;\nuse worker::kv::KvStore;\nuse serde_json;\nuse chrono::Utc;\n\n/// Global Opportunity Service for Task 2\n/// Implements system-wide opportunity detection, queue management, and fair distribution\npub struct GlobalOpportunityService {\n    config: GlobalOpportunityConfig,\n    exchange_service: Arc\u003cExchangeService\u003e,\n    user_profile_service: Arc\u003cUserProfileService\u003e,\n    kv_store: KvStore,\n    current_queue: Option\u003cOpportunityQueue\u003e,\n    distribution_tracking: HashMap\u003cString, UserOpportunityDistribution\u003e,\n}\n\nimpl GlobalOpportunityService {\n    const OPPORTUNITY_QUEUE_KEY: \u0026'static str = \"global_opportunity_queue\";\n    const DISTRIBUTION_TRACKING_PREFIX: \u0026'static str = \"user_opportunity_dist\";\n    const ACTIVE_USERS_KEY: \u0026'static str = \"active_users_list\";\n\n    pub fn new(\n        config: GlobalOpportunityConfig,\n        exchange_service: Arc\u003cExchangeService\u003e,\n        user_profile_service: Arc\u003cUserProfileService\u003e,\n        kv_store: KvStore,\n    ) -\u003e Self {\n        Self {\n            config,\n            exchange_service,\n            user_profile_service,\n            kv_store,\n            current_queue: None,\n            distribution_tracking: HashMap::new(),\n        }\n    }\n\n    /// Load or create the global opportunity queue\n    pub async fn initialize_queue(\u0026mut self) -\u003e ArbitrageResult\u003c()\u003e {\n        match self.load_queue().await {\n            Ok(queue) =\u003e {\n                log_info!(\"Loaded existing global opportunity queue\", serde_json::json!({\n                    \"queue_id\": queue.id,\n                    \"opportunities_count\": queue.opportunities.len(),\n                    \"active_users\": queue.active_users.len()\n                }));\n                self.current_queue = Some(queue);\n            }\n            Err(_) =\u003e {\n                log_info!(\"Creating new global opportunity queue\", serde_json::json!({}));\n                let new_queue = OpportunityQueue {\n                    id: uuid::Uuid::new_v4().to_string(),\n                    opportunities: Vec::new(),\n                    created_at: Utc::now().timestamp_millis() as u64,\n                    updated_at: Utc::now().timestamp_millis() as u64,\n                    total_distributed: 0,\n                    active_users: Vec::new(),\n                };\n                self.save_queue(\u0026new_queue).await?;\n                self.current_queue = Some(new_queue);\n            }\n        }\n        Ok(())\n    }\n\n    /// Main detection loop - discovers new opportunities using default strategy\n    pub async fn detect_opportunities(\u0026mut self) -\u003e ArbitrageResult\u003cVec\u003cGlobalOpportunity\u003e\u003e {\n        log_info!(\"Starting global opportunity detection\", serde_json::json!({\n            \"min_threshold\": self.config.min_threshold,\n            \"max_threshold\": self.config.max_threshold,\n            \"exchanges\": self.config.monitored_exchanges.len(),\n            \"pairs\": self.config.monitored_pairs.len()\n        }));\n\n        let mut new_opportunities = Vec::new();\n\n        // Step 1: Fetch funding rates for all monitored pairs and exchanges\n        let mut funding_rate_data: HashMap\u003cString, HashMap\u003cExchangeIdEnum, Option\u003cFundingRateInfo\u003e\u003e\u003e = HashMap::new();\n\n        // Initialize maps for each pair\n        for pair in \u0026self.config.monitored_pairs {\n            funding_rate_data.insert(pair.clone(), HashMap::new());\n        }\n\n        // Collect funding rate fetch tasks\n        let mut funding_tasks = Vec::new();\n\n        for pair in \u0026self.config.monitored_pairs {\n            for exchange_id in \u0026self.config.monitored_exchanges {\n                let exchange_service = Arc::clone(\u0026self.exchange_service);\n                let pair = pair.clone();\n                let exchange_id = *exchange_id;\n\n                let task = Box::pin(async move {\n                    let result = exchange_service\n                        .fetch_funding_rates(\u0026exchange_id.to_string(), Some(\u0026pair))\n                        .await;\n                    \n                    let funding_info = match result {\n                        Ok(rates) =\u003e {\n                            if let Some(rate_data) = rates.first() {\n                                match rate_data[\"fundingRate\"].as_str() {\n                                    Some(rate_str) =\u003e {\n                                        match rate_str.parse::\u003cf64\u003e() {\n                                            Ok(funding_rate) =\u003e Some(FundingRateInfo {\n                                                symbol: pair.clone(),\n                                                funding_rate,\n                                                timestamp: Some(Utc::now()),\n                                                datetime: Some(Utc::now().to_rfc3339()),\n                                                next_funding_time: None,\n                                                estimated_rate: None,\n                                            }),\n                                            Err(_) =\u003e None,\n                                        }\n                                    }\n                                    None =\u003e None,\n                                }\n                            } else {\n                                None\n                            }\n                        }\n                        Err(_) =\u003e None,\n                    };\n                    \n                    (pair, exchange_id, funding_info)\n                });\n                funding_tasks.push(task);\n            }\n        }\n\n        // Execute all funding rate fetch operations concurrently\n        let funding_results = join_all(funding_tasks).await;\n\n        // Process funding rate results\n        for (pair, exchange_id, funding_info) in funding_results {\n            if let Some(pair_map) = funding_rate_data.get_mut(\u0026pair) {\n                pair_map.insert(exchange_id, funding_info);\n            }\n        }\n\n        // Step 2: Identify arbitrage opportunities using default strategy\n        for pair in \u0026self.config.monitored_pairs {\n            if let Some(pair_funding_rates) = funding_rate_data.get(pair) {\n                let available_exchanges: Vec\u003cExchangeIdEnum\u003e = pair_funding_rates\n                    .iter()\n                    .filter_map(|(exchange_id, rate_info)| {\n                        if rate_info.is_some() {\n                            Some(*exchange_id)\n                        } else {\n                            None\n                        }\n                    })\n                    .collect();\n\n                if available_exchanges.len() \u003c 2 {\n                    continue;\n                }\n\n                // Compare all pairs of exchanges for opportunities\n                for i in 0..available_exchanges.len() {\n                    for j in (i + 1)..available_exchanges.len() {\n                        let exchange_a = available_exchanges[i];\n                        let exchange_b = available_exchanges[j];\n\n                        if let (Some(Some(rate_a)), Some(Some(rate_b))) = (\n                            pair_funding_rates.get(\u0026exchange_a),\n                            pair_funding_rates.get(\u0026exchange_b),\n                        ) {\n                            let rate_diff = (rate_a.funding_rate - rate_b.funding_rate).abs();\n\n                            // Check if opportunity meets our thresholds\n                            if rate_diff \u003e= self.config.min_threshold \u0026\u0026 rate_diff \u003c= self.config.max_threshold {\n                                let (long_exchange, short_exchange, long_rate, short_rate) =\n                                    if rate_a.funding_rate \u003e rate_b.funding_rate {\n                                        (exchange_b, exchange_a, rate_b.funding_rate, rate_a.funding_rate)\n                                    } else {\n                                        (exchange_a, exchange_b, rate_a.funding_rate, rate_b.funding_rate)\n                                    };\n\n                                // Create base arbitrage opportunity\n                                let opportunity = ArbitrageOpportunity {\n                                    id: uuid::Uuid::new_v4().to_string(),\n                                    pair: pair.clone(),\n                                    long_exchange: Some(long_exchange),\n                                    short_exchange: Some(short_exchange),\n                                    long_rate: Some(long_rate),\n                                    short_rate: Some(short_rate),\n                                    rate_difference: rate_diff,\n                                    net_rate_difference: Some(rate_diff), // Simplified for now\n                                    potential_profit_value: Some(rate_diff * 1000.0), // Estimate for $1000 position\n                                    timestamp: Utc::now().timestamp_millis() as u64,\n                                    r#type: ArbitrageType::FundingRate,\n                                    details: Some(format!(\n                                        \"Funding rate arbitrage: Long {} ({:.4}%) vs Short {} ({:.4}%)\",\n                                        long_exchange.as_str(),\n                                        long_rate * 100.0,\n                                        short_exchange.as_str(),\n                                        short_rate * 100.0\n                                    )),\n                                };\n\n                                // Calculate priority score (higher rate difference = higher priority)\n                                let priority_score = rate_diff * 1000.0; // Scale up for easier comparison\n\n                                // Create global opportunity\n                                let global_opportunity = GlobalOpportunity {\n                                    opportunity,\n                                    detection_timestamp: Utc::now().timestamp_millis() as u64,\n                                    expiry_timestamp: Utc::now().timestamp_millis() as u64 + (self.config.opportunity_ttl_minutes as u64 * 60 * 1000),\n                                    priority_score,\n                                    distributed_to: Vec::new(),\n                                    max_participants: Some(10), // Default limit\n                                    current_participants: 0,\n                                    distribution_strategy: self.config.distribution_strategy.clone(),\n                                    source: OpportunitySource::SystemGenerated,\n                                };\n\n                                new_opportunities.push(global_opportunity);\n\n                                log_info!(\"Detected new global opportunity\", serde_json::json!({\n                                    \"pair\": pair,\n                                    \"rate_difference\": rate_diff,\n                                    \"priority_score\": priority_score,\n                                    \"long_exchange\": long_exchange.as_str(),\n                                    \"short_exchange\": short_exchange.as_str()\n                                }));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        log_info!(\"Global opportunity detection completed\", serde_json::json!({\n            \"new_opportunities_count\": new_opportunities.len()\n        }));\n\n        Ok(new_opportunities)\n    }\n\n    /// Add new opportunities to the global queue\n    pub async fn add_opportunities_to_queue(\u0026mut self, opportunities: Vec\u003cGlobalOpportunity\u003e) -\u003e ArbitrageResult\u003c()\u003e {\n        let opportunities_count = opportunities.len(); // Store count before move\n        \n        // Extract the queue to avoid borrowing conflicts\n        if let Some(mut queue) = self.current_queue.take() {\n            // Add new opportunities\n            queue.opportunities.extend(opportunities);\n            \n            // Sort by priority score (highest first)\n            queue.opportunities.sort_by(|a, b| b.priority_score.partial_cmp(\u0026a.priority_score).unwrap_or(std::cmp::Ordering::Equal));\n            \n            // Limit queue size\n            if queue.opportunities.len() \u003e self.config.max_queue_size as usize {\n                queue.opportunities.truncate(self.config.max_queue_size as usize);\n            }\n            \n            // Remove expired opportunities\n            let now = Utc::now().timestamp_millis() as u64;\n            queue.opportunities.retain(|opp| opp.expiry_timestamp \u003e now);\n            \n            queue.updated_at = now;\n            \n            // Save the queue\n            self.save_queue(\u0026queue).await?;\n            \n            log_info!(\"Updated global opportunity queue\", serde_json::json!({\n                \"total_opportunities\": queue.opportunities.len(),\n                \"new_opportunities_added\": opportunities_count\n            }));\n            \n            // Put the queue back\n            self.current_queue = Some(queue);\n        }\n        \n        Ok(())\n    }\n\n    /// Distribute opportunities to eligible users using fairness algorithms\n    pub async fn distribute_opportunities(\u0026mut self) -\u003e ArbitrageResult\u003cVec\u003c(String, GlobalOpportunity)\u003e\u003e {\n        let mut distributions = Vec::new();\n        \n        // Extract the queue to avoid borrowing conflicts\n        if let Some(mut queue) = self.current_queue.take() {\n            // Load active users from KV store\n            let active_users = self.load_active_users().await?;\n            \n            // Load distribution tracking for all users\n            for user_id in \u0026active_users {\n                if !self.distribution_tracking.contains_key(user_id) {\n                    if let Ok(tracking) = self.load_user_distribution_tracking(user_id).await {\n                        self.distribution_tracking.insert(user_id.clone(), tracking);\n                    } else {\n                        // Create new tracking for user\n                        let new_tracking = UserOpportunityDistribution {\n                            user_id: user_id.clone(),\n                            last_opportunity_received: None,\n                            total_opportunities_received: 0,\n                            opportunities_today: 0,\n                            last_daily_reset: Utc::now().timestamp_millis() as u64,\n                            priority_weight: 1.0,\n                            is_eligible: true,\n                        };\n                        self.distribution_tracking.insert(user_id.clone(), new_tracking);\n                    }\n                }\n            }\n\n            // Apply fairness algorithm based on distribution strategy\n            match self.config.distribution_strategy {\n                DistributionStrategy::RoundRobin =\u003e {\n                    distributions = self.distribute_round_robin(\u0026active_users, \u0026mut queue).await?;\n                }\n                DistributionStrategy::FirstComeFirstServe =\u003e {\n                    distributions = self.distribute_first_come_first_serve(\u0026active_users, \u0026mut queue).await?;\n                }\n                DistributionStrategy::PriorityBased =\u003e {\n                    distributions = self.distribute_priority_based(\u0026active_users, \u0026mut queue).await?;\n                }\n                DistributionStrategy::Broadcast =\u003e {\n                    distributions = self.distribute_broadcast(\u0026active_users, \u0026mut queue).await?;\n                }\n            }\n\n            // Update distribution tracking\n            for (user_id, _) in \u0026distributions {\n                if let Some(tracking) = self.distribution_tracking.get_mut(user_id) {\n                    tracking.last_opportunity_received = Some(Utc::now().timestamp_millis() as u64);\n                    tracking.total_opportunities_received += 1;\n                    tracking.opportunities_today += 1;\n                    \n                    // Reset daily count if needed\n                    let now = Utc::now().timestamp_millis() as u64;\n                    let one_day_ms = 24 * 60 * 60 * 1000;\n                    if now - tracking.last_daily_reset \u003e one_day_ms {\n                        tracking.opportunities_today = 1;\n                        tracking.last_daily_reset = now;\n                    }\n                    \n                    // Clone to avoid borrowing issues\n                    let tracking_clone = tracking.clone();\n                    self.save_user_distribution_tracking(\u0026tracking_clone).await?;\n                }\n            }\n\n            queue.total_distributed += distributions.len() as u32;\n            \n            // Clone for saving\n            let queue_clone = queue.clone();\n            self.save_queue(\u0026queue_clone).await?;\n            \n            // Put the queue back\n            self.current_queue = Some(queue);\n        }\n\n        log_info!(\"Distributed opportunities\", serde_json::json!({\n            \"distributions_count\": distributions.len(),\n            \"strategy\": format!(\"{:?}\", self.config.distribution_strategy)\n        }));\n\n        Ok(distributions)\n    }\n\n    /// Round-robin distribution - fair rotation among users\n    async fn distribute_round_robin(\n        \u0026self,\n        active_users: \u0026[String],\n        queue: \u0026mut OpportunityQueue,\n    ) -\u003e ArbitrageResult\u003cVec\u003c(String, GlobalOpportunity)\u003e\u003e {\n        let mut distributions = Vec::new();\n        let mut user_index = 0;\n\n        for opportunity in queue.opportunities.iter_mut() {\n            if opportunity.distributed_to.len() \u003e= opportunity.max_participants.unwrap_or(10) as usize {\n                continue;\n            }\n\n            // Find next eligible user\n            let mut attempts = 0;\n            while attempts \u003c active_users.len() {\n                let user_id = \u0026active_users[user_index % active_users.len()];\n                \n                if self.is_user_eligible_for_opportunity(user_id, opportunity).await? {\n                    opportunity.distributed_to.push(user_id.clone());\n                    opportunity.current_participants += 1;\n                    distributions.push((user_id.clone(), opportunity.clone()));\n                    break;\n                }\n                \n                user_index = (user_index + 1) % active_users.len();\n                attempts += 1;\n            }\n            \n            user_index = (user_index + 1) % active_users.len();\n        }\n\n        Ok(distributions)\n    }\n\n    /// First-come-first-serve distribution\n    async fn distribute_first_come_first_serve(\n        \u0026self,\n        active_users: \u0026[String],\n        queue: \u0026mut OpportunityQueue,\n    ) -\u003e ArbitrageResult\u003cVec\u003c(String, GlobalOpportunity)\u003e\u003e {\n        let mut distributions = Vec::new();\n\n        for opportunity in queue.opportunities.iter_mut() {\n            if opportunity.distributed_to.len() \u003e= opportunity.max_participants.unwrap_or(10) as usize {\n                continue;\n            }\n\n            for user_id in active_users {\n                if opportunity.distributed_to.contains(user_id) {\n                    continue;\n                }\n\n                if self.is_user_eligible_for_opportunity(user_id, opportunity).await? {\n                    opportunity.distributed_to.push(user_id.clone());\n                    opportunity.current_participants += 1;\n                    distributions.push((user_id.clone(), opportunity.clone()));\n                    break;\n                }\n            }\n        }\n\n        Ok(distributions)\n    }\n\n    /// Priority-based distribution considering subscription tiers and activity\n    async fn distribute_priority_based(\n        \u0026self,\n        active_users: \u0026[String],\n        queue: \u0026mut OpportunityQueue,\n    ) -\u003e ArbitrageResult\u003cVec\u003c(String, GlobalOpportunity)\u003e\u003e {\n        let mut distributions = Vec::new();\n\n        // Calculate user priorities\n        let mut user_priorities: Vec\u003c(String, f64)\u003e = Vec::new();\n        \n        for user_id in active_users {\n            let priority = self.calculate_user_priority(user_id).await?;\n            user_priorities.push((user_id.clone(), priority));\n        }\n\n        // Sort by priority (highest first)\n        user_priorities.sort_by(|a, b| b.1.partial_cmp(\u0026a.1).unwrap_or(std::cmp::Ordering::Equal));\n\n        for opportunity in queue.opportunities.iter_mut() {\n            if opportunity.distributed_to.len() \u003e= opportunity.max_participants.unwrap_or(10) as usize {\n                continue;\n            }\n\n            for (user_id, _priority) in \u0026user_priorities {\n                if opportunity.distributed_to.contains(user_id) {\n                    continue;\n                }\n\n                if self.is_user_eligible_for_opportunity(user_id, opportunity).await? {\n                    opportunity.distributed_to.push(user_id.clone());\n                    opportunity.current_participants += 1;\n                    distributions.push((user_id.clone(), opportunity.clone()));\n                    break;\n                }\n            }\n        }\n\n        Ok(distributions)\n    }\n\n    /// Broadcast distribution - send to all eligible users\n    async fn distribute_broadcast(\n        \u0026self,\n        active_users: \u0026[String],\n        queue: \u0026mut OpportunityQueue,\n    ) -\u003e ArbitrageResult\u003cVec\u003c(String, GlobalOpportunity)\u003e\u003e {\n        let mut distributions = Vec::new();\n\n        for opportunity in queue.opportunities.iter_mut() {\n            for user_id in active_users {\n                if opportunity.distributed_to.contains(user_id) {\n                    continue;\n                }\n\n                if self.is_user_eligible_for_opportunity(user_id, opportunity).await? {\n                    opportunity.distributed_to.push(user_id.clone());\n                    opportunity.current_participants += 1;\n                    distributions.push((user_id.clone(), opportunity.clone()));\n                }\n            }\n        }\n\n        Ok(distributions)\n    }\n\n    /// Check if user is eligible to receive an opportunity\n    async fn is_user_eligible_for_opportunity(\n        \u0026self,\n        user_id: \u0026str,\n        _opportunity: \u0026GlobalOpportunity,\n    ) -\u003e ArbitrageResult\u003cbool\u003e {\n        // Check distribution tracking\n        if let Some(tracking) = self.distribution_tracking.get(user_id) {\n            if !tracking.is_eligible {\n                return Ok(false);\n            }\n\n            // Check daily limits\n            if tracking.opportunities_today \u003e= self.config.fairness_config.max_opportunities_per_user_per_day {\n                return Ok(false);\n            }\n\n            // Check cooldown period\n            if let Some(last_received) = tracking.last_opportunity_received {\n                let cooldown_ms = self.config.fairness_config.cooldown_period_minutes as u64 * 60 * 1000;\n                let now = Utc::now().timestamp_millis() as u64;\n                if now - last_received \u003c cooldown_ms {\n                    return Ok(false);\n                }\n            }\n        }\n\n        Ok(true)\n    }\n\n    /// Calculate user priority based on subscription tier and activity\n    async fn calculate_user_priority(\u0026self, user_id: \u0026str) -\u003e ArbitrageResult\u003cf64\u003e {\n        // Load user profile to get subscription tier\n        match self.user_profile_service.get_user_profile(user_id).await {\n            Ok(Some(profile)) =\u003e { // Handle Option\u003cUserProfile\u003e\n                let tier_name = match profile.subscription.tier {\n                    SubscriptionTier::Free =\u003e \"Free\",\n                    SubscriptionTier::Basic =\u003e \"Basic\",\n                    SubscriptionTier::Premium =\u003e \"Premium\",\n                    SubscriptionTier::Enterprise =\u003e \"Enterprise\",\n                };\n\n                let tier_multiplier = self.config.fairness_config.tier_multipliers\n                    .get(tier_name)\n                    .copied()\n                    .unwrap_or(1.0);\n\n                // Base priority with tier multiplier\n                let mut priority = tier_multiplier;\n\n                // Activity boost - check last active time\n                let now = Utc::now().timestamp_millis() as u64;\n                let one_hour_ms = 60 * 60 * 1000;\n                if now - profile.last_active \u003c one_hour_ms {\n                    priority *= self.config.fairness_config.activity_boost_factor;\n                }\n\n                Ok(priority)\n            }\n            Ok(None) =\u003e Ok(1.0), // No profile found, default priority\n            Err(_) =\u003e Ok(1.0), // Error loading profile, default priority\n        }\n    }\n\n    /// Get current queue status\n    pub fn get_queue_status(\u0026self) -\u003e Option\u003c\u0026OpportunityQueue\u003e {\n        self.current_queue.as_ref()\n    }\n\n    /// Update active users list\n    pub async fn update_active_users(\u0026self, user_ids: Vec\u003cString\u003e) -\u003e ArbitrageResult\u003c()\u003e {\n        let data = serde_json::to_string(\u0026user_ids)\n            .map_err(|e| ArbitrageError::serialization_error(format!(\"Failed to serialize active users: {}\", e)))?;\n        \n        self.kv_store\n            .put(Self::ACTIVE_USERS_KEY, data)?\n            .execute()\n            .await\n            .map_err(|e| ArbitrageError::database_error(format!(\"Failed to save active users: {}\", e)))?;\n        \n        Ok(())\n    }\n\n    // Storage operations\n    async fn load_queue(\u0026self) -\u003e ArbitrageResult\u003cOpportunityQueue\u003e {\n        let data = self.kv_store\n            .get(Self::OPPORTUNITY_QUEUE_KEY)\n            .text()\n            .await\n            .map_err(|e| ArbitrageError::database_error(format!(\"Failed to load opportunity queue: {}\", e)))?\n            .ok_or_else(|| ArbitrageError::not_found(\"Opportunity queue not found\".to_string()))?;\n\n        serde_json::from_str(\u0026data)\n            .map_err(|e| ArbitrageError::serialization_error(format!(\"Failed to deserialize opportunity queue: {}\", e)))\n    }\n\n    async fn save_queue(\u0026self, queue: \u0026OpportunityQueue) -\u003e ArbitrageResult\u003c()\u003e {\n        let data = serde_json::to_string(queue)\n            .map_err(|e| ArbitrageError::serialization_error(format!(\"Failed to serialize opportunity queue: {}\", e)))?;\n\n        self.kv_store\n            .put(Self::OPPORTUNITY_QUEUE_KEY, data)?\n            .execute()\n            .await\n            .map_err(|e| ArbitrageError::database_error(format!(\"Failed to save opportunity queue: {}\", e)))?;\n\n        Ok(())\n    }\n\n    async fn load_active_users(\u0026self) -\u003e ArbitrageResult\u003cVec\u003cString\u003e\u003e {\n        match self.kv_store.get(Self::ACTIVE_USERS_KEY).text().await {\n            Ok(Some(data)) =\u003e {\n                serde_json::from_str(\u0026data)\n                    .map_err(|e| ArbitrageError::serialization_error(format!(\"Failed to deserialize active users: {}\", e)))\n            }\n            Ok(None) =\u003e Ok(Vec::new()),\n            Err(e) =\u003e Err(ArbitrageError::database_error(format!(\"Failed to load active users: {}\", e))),\n        }\n    }\n\n    async fn load_user_distribution_tracking(\u0026self, user_id: \u0026str) -\u003e ArbitrageResult\u003cUserOpportunityDistribution\u003e {\n        let key = format!(\"{}:{}\", Self::DISTRIBUTION_TRACKING_PREFIX, user_id);\n        let data = self.kv_store\n            .get(\u0026key)\n            .text()\n            .await\n            .map_err(|e| ArbitrageError::database_error(format!(\"Failed to load user distribution tracking: {}\", e)))?\n            .ok_or_else(|| ArbitrageError::not_found(\"User distribution tracking not found\".to_string()))?;\n\n        serde_json::from_str(\u0026data)\n            .map_err(|e| ArbitrageError::serialization_error(format!(\"Failed to deserialize user distribution tracking: {}\", e)))\n    }\n\n    async fn save_user_distribution_tracking(\u0026self, tracking: \u0026UserOpportunityDistribution) -\u003e ArbitrageResult\u003c()\u003e {\n        let key = format!(\"{}:{}\", Self::DISTRIBUTION_TRACKING_PREFIX, tracking.user_id);\n        let data = serde_json::to_string(tracking)\n            .map_err(|e| ArbitrageError::serialization_error(format!(\"Failed to serialize user distribution tracking: {}\", e)))?;\n\n        self.kv_store\n            .put(\u0026key, data)?\n            .execute()\n            .await\n            .map_err(|e| ArbitrageError::database_error(format!(\"Failed to save user distribution tracking: {}\", e)))?;\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::SubscriptionInfo;\n    use std::collections::HashMap;\n    use uuid::Uuid;\n\n    // Mock structures for testing\n    struct MockKvStore {\n        data: std::sync::Arc\u003cstd::sync::Mutex\u003cHashMap\u003cString, String\u003e\u003e\u003e,\n    }\n\n    impl MockKvStore {\n        fn new() -\u003e Self {\n            Self {\n                data: std::sync::Arc::new(std::sync::Mutex::new(HashMap::new())),\n            }\n        }\n\n        fn with_data(mut self, key: \u0026str, value: \u0026str) -\u003e Self {\n            let mut data = self.data.lock().unwrap();\n            data.insert(key.to_string(), value.to_string());\n            drop(data);\n            self\n        }\n\n        async fn get(\u0026self, key: \u0026str) -\u003e Option\u003cString\u003e {\n            let data = self.data.lock().unwrap();\n            data.get(key).cloned()\n        }\n\n        async fn put(\u0026self, key: \u0026str, value: String) -\u003e Result\u003c(), String\u003e {\n            let mut data = self.data.lock().unwrap();\n            data.insert(key.to_string(), value);\n            Ok(())\n        }\n    }\n\n    fn create_test_config() -\u003e GlobalOpportunityConfig {\n        GlobalOpportunityConfig {\n            detection_interval_seconds: 30,\n            min_threshold: 0.001, // 0.1%\n            max_threshold: 0.02, // 2%\n            max_queue_size: 50,\n            opportunity_ttl_minutes: 10,\n            distribution_strategy: DistributionStrategy::RoundRobin,\n            fairness_config: FairnessConfig::default(),\n            monitored_exchanges: vec![ExchangeIdEnum::Binance, ExchangeIdEnum::Bybit],\n            monitored_pairs: vec![\"BTCUSDT\".to_string(), \"ETHUSDT\".to_string()],\n        }\n    }\n\n    fn create_test_opportunity() -\u003e GlobalOpportunity {\n        let opportunity = ArbitrageOpportunity {\n            id: Uuid::new_v4().to_string(),\n            pair: \"BTCUSDT\".to_string(),\n            long_exchange: Some(ExchangeIdEnum::Binance),\n            short_exchange: Some(ExchangeIdEnum::Bybit),\n            long_rate: Some(0.0005),\n            short_rate: Some(0.0015),\n            rate_difference: 0.001,\n            net_rate_difference: Some(0.001),\n            potential_profit_value: Some(1.0),\n            timestamp: Utc::now().timestamp_millis() as u64,\n            r#type: ArbitrageType::FundingRate,\n            details: Some(\"Test opportunity\".to_string()),\n        };\n\n        GlobalOpportunity {\n            opportunity,\n            detection_timestamp: Utc::now().timestamp_millis() as u64,\n            expiry_timestamp: Utc::now().timestamp_millis() as u64 + 600000, // 10 minutes\n            priority_score: 1.0,\n            distributed_to: Vec::new(),\n            max_participants: Some(5),\n            current_participants: 0,\n            distribution_strategy: DistributionStrategy::RoundRobin,\n            source: OpportunitySource::SystemGenerated,\n        }\n    }\n\n    fn create_test_user_profile(user_id: \u0026str, tier: SubscriptionTier) -\u003e UserProfile {\n        UserProfile {\n            user_id: user_id.to_string(),\n            telegram_user_id: 12345,\n            telegram_username: Some(\"testuser\".to_string()),\n            subscription: SubscriptionInfo {\n                tier,\n                is_active: true,\n                expires_at: None,\n                created_at: Utc::now().timestamp_millis() as u64,\n                features: vec![\"basic_features\".to_string()],\n            },\n            configuration: crate::types::UserConfiguration::default(),\n            api_keys: Vec::new(),\n            invitation_code: None,\n            created_at: Utc::now().timestamp_millis() as u64,\n            updated_at: Utc::now().timestamp_millis() as u64,\n            last_active: Utc::now().timestamp_millis() as u64,\n            is_active: true,\n            total_trades: 0,\n            total_pnl_usdt: 0.0,\n        }\n    }\n\n    #[tokio::test]\n    async fn test_global_opportunity_config_creation() {\n        let config = create_test_config();\n        \n        assert_eq!(config.detection_interval_seconds, 30);\n        assert_eq!(config.min_threshold, 0.001);\n        assert_eq!(config.max_threshold, 0.02);\n        assert_eq!(config.max_queue_size, 50);\n        assert_eq!(config.opportunity_ttl_minutes, 10);\n        assert!(matches!(config.distribution_strategy, DistributionStrategy::RoundRobin));\n        assert_eq!(config.monitored_exchanges.len(), 2);\n        assert_eq!(config.monitored_pairs.len(), 2);\n    }\n\n    #[tokio::test]\n    async fn test_global_opportunity_structure() {\n        let global_opp = create_test_opportunity();\n        \n        assert_eq!(global_opp.opportunity.pair, \"BTCUSDT\");\n        assert_eq!(global_opp.opportunity.rate_difference, 0.001);\n        assert_eq!(global_opp.priority_score, 1.0);\n        assert_eq!(global_opp.distributed_to.len(), 0);\n        assert_eq!(global_opp.max_participants, Some(5));\n        assert_eq!(global_opp.current_participants, 0);\n        assert!(matches!(global_opp.distribution_strategy, DistributionStrategy::RoundRobin));\n        assert!(matches!(global_opp.source, OpportunitySource::SystemGenerated));\n    }\n\n    #[tokio::test]\n    async fn test_opportunity_queue_management() {\n        let mut queue = OpportunityQueue {\n            id: Uuid::new_v4().to_string(),\n            opportunities: Vec::new(),\n            created_at: Utc::now().timestamp_millis() as u64,\n            updated_at: Utc::now().timestamp_millis() as u64,\n            total_distributed: 0,\n            active_users: vec![\"user1\".to_string(), \"user2\".to_string()],\n        };\n\n        // Test adding opportunities\n        let opp1 = create_test_opportunity();\n        let mut opp2 = create_test_opportunity();\n        opp2.priority_score = 2.0; // Higher priority\n\n        queue.opportunities.push(opp1);\n        queue.opportunities.push(opp2);\n\n        // Test sorting by priority\n        queue.opportunities.sort_by(|a, b| b.priority_score.partial_cmp(\u0026a.priority_score).unwrap_or(std::cmp::Ordering::Equal));\n        \n        assert_eq!(queue.opportunities.len(), 2);\n        assert_eq!(queue.opportunities[0].priority_score, 2.0); // Higher priority first\n        assert_eq!(queue.opportunities[1].priority_score, 1.0);\n        assert_eq!(queue.active_users.len(), 2);\n    }\n\n    #[tokio::test]\n    async fn test_user_distribution_tracking() {\n        let tracking = UserOpportunityDistribution {\n            user_id: \"test_user\".to_string(),\n            last_opportunity_received: Some(Utc::now().timestamp_millis() as u64),\n            total_opportunities_received: 5,\n            opportunities_today: 2,\n            last_daily_reset: Utc::now().timestamp_millis() as u64,\n            priority_weight: 1.5,\n            is_eligible: true,\n        };\n\n        assert_eq!(tracking.user_id, \"test_user\");\n        assert_eq!(tracking.total_opportunities_received, 5);\n        assert_eq!(tracking.opportunities_today, 2);\n        assert_eq!(tracking.priority_weight, 1.5);\n        assert!(tracking.is_eligible);\n        assert!(tracking.last_opportunity_received.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_fairness_config_defaults() {\n        let config = FairnessConfig::default();\n        \n        assert_eq!(config.rotation_interval_minutes, 15);\n        assert_eq!(config.max_opportunities_per_user_per_hour, 10);\n        assert_eq!(config.max_opportunities_per_user_per_day, 50);\n        assert_eq!(config.activity_boost_factor, 1.2);\n        assert_eq!(config.cooldown_period_minutes, 5);\n        \n        // Test tier multipliers\n        assert_eq!(config.tier_multipliers.get(\"Free\"), Some(\u00261.0));\n        assert_eq!(config.tier_multipliers.get(\"Basic\"), Some(\u00261.5));\n        assert_eq!(config.tier_multipliers.get(\"Premium\"), Some(\u00262.0));\n        assert_eq!(config.tier_multipliers.get(\"Enterprise\"), Some(\u00263.0));\n    }\n\n    #[tokio::test]\n    async fn test_distribution_strategies() {\n        // Test all distribution strategy variants\n        let strategies = vec![\n            DistributionStrategy::FirstComeFirstServe,\n            DistributionStrategy::RoundRobin,\n            DistributionStrategy::PriorityBased,\n            DistributionStrategy::Broadcast,\n        ];\n\n        for strategy in strategies {\n            match strategy {\n                DistributionStrategy::FirstComeFirstServe =\u003e {\n                    // Test first-come-first-serve logic\n                    assert!(true); // Placeholder for actual implementation test\n                }\n                DistributionStrategy::RoundRobin =\u003e {\n                    // Test round-robin logic\n                    assert!(true); // Placeholder for actual implementation test\n                }\n                DistributionStrategy::PriorityBased =\u003e {\n                    // Test priority-based logic\n                    assert!(true); // Placeholder for actual implementation test\n                }\n                DistributionStrategy::Broadcast =\u003e {\n                    // Test broadcast logic\n                    assert!(true); // Placeholder for actual implementation test\n                }\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_opportunity_source_types() {\n        let sources = vec![\n            OpportunitySource::SystemGenerated,\n            OpportunitySource::UserAI(\"user123\".to_string()),\n            OpportunitySource::External,\n        ];\n\n        for source in sources {\n            match source {\n                OpportunitySource::SystemGenerated =\u003e {\n                    assert!(true); // System-generated opportunities\n                }\n                OpportunitySource::UserAI(user_id) =\u003e {\n                    assert_eq!(user_id, \"user123\"); // User AI-generated\n                }\n                OpportunitySource::External =\u003e {\n                    assert!(true); // External source opportunities\n                }\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_opportunity_expiry_logic() {\n        let now = Utc::now().timestamp_millis() as u64;\n        \n        // Create expired opportunity\n        let mut expired_opp = create_test_opportunity();\n        expired_opp.expiry_timestamp = now - 1000; // 1 second ago\n        \n        // Create valid opportunity\n        let valid_opp = create_test_opportunity();\n        // expiry_timestamp is set in the future by create_test_opportunity()\n        \n        assert!(expired_opp.expiry_timestamp \u003c now);\n        assert!(valid_opp.expiry_timestamp \u003e now);\n        \n        // Test filtering logic\n        let opportunities = vec![expired_opp, valid_opp];\n        let valid_opportunities: Vec\u003c_\u003e = opportunities\n            .into_iter()\n            .filter(|opp| opp.expiry_timestamp \u003e now)\n            .collect();\n        \n        assert_eq!(valid_opportunities.len(), 1);\n    }\n\n    #[tokio::test]\n    async fn test_priority_score_calculation() {\n        let base_rate_diff = 0.001; // 0.1%\n        let priority_score = base_rate_diff * 1000.0; // Scale up\n        \n        assert_eq!(priority_score, 1.0);\n        \n        // Test higher rate difference\n        let higher_rate_diff = 0.005; // 0.5%\n        let higher_priority = higher_rate_diff * 1000.0;\n        \n        assert_eq!(higher_priority, 5.0);\n        assert!(higher_priority \u003e priority_score);\n    }\n\n    #[tokio::test]\n    async fn test_user_eligibility_checks() {\n        let config = FairnessConfig::default();\n        \n        // Test daily limit check\n        let mut tracking = UserOpportunityDistribution {\n            user_id: \"test_user\".to_string(),\n            last_opportunity_received: None,\n            total_opportunities_received: 0,\n            opportunities_today: config.max_opportunities_per_user_per_day,\n            last_daily_reset: Utc::now().timestamp_millis() as u64,\n            priority_weight: 1.0,\n            is_eligible: true,\n        };\n        \n        // User at daily limit should not be eligible\n        assert!(!tracking.is_eligible || tracking.opportunities_today \u003e= config.max_opportunities_per_user_per_day);\n        \n        // Test cooldown period\n        tracking.opportunities_today = 0;\n        tracking.last_opportunity_received = Some(Utc::now().timestamp_millis() as u64 - 1000); // 1 second ago\n        \n        let cooldown_ms = config.cooldown_period_minutes as u64 * 60 * 1000;\n        let time_since_last = 1000u64; // 1 second\n        \n        // Should not be eligible due to cooldown\n        assert!(time_since_last \u003c cooldown_ms);\n    }\n\n    #[tokio::test]\n    async fn test_subscription_tier_priority() {\n        let free_user = create_test_user_profile(\"user1\", SubscriptionTier::Free);\n        let premium_user = create_test_user_profile(\"user2\", SubscriptionTier::Premium);\n        \n        let config = FairnessConfig::default();\n        \n        let free_multiplier = config.tier_multipliers.get(\"Free\").copied().unwrap_or(1.0);\n        let premium_multiplier = config.tier_multipliers.get(\"Premium\").copied().unwrap_or(1.0);\n        \n        assert_eq!(free_multiplier, 1.0);\n        assert_eq!(premium_multiplier, 2.0);\n        assert!(premium_multiplier \u003e free_multiplier);\n    }\n\n    #[tokio::test]\n    async fn test_opportunity_participant_limits() {\n        let mut opportunity = create_test_opportunity();\n        opportunity.max_participants = Some(2);\n        \n        // Test adding participants\n        opportunity.distributed_to.push(\"user1\".to_string());\n        opportunity.current_participants += 1;\n        assert_eq!(opportunity.current_participants, 1);\n        assert!(opportunity.current_participants \u003c opportunity.max_participants.unwrap_or(10));\n        \n        // Add second participant\n        opportunity.distributed_to.push(\"user2\".to_string());\n        opportunity.current_participants += 1;\n        assert_eq!(opportunity.current_participants, 2);\n        assert_eq!(opportunity.current_participants, opportunity.max_participants.unwrap_or(10));\n        \n        // Check if at limit\n        assert_eq!(opportunity.distributed_to.len(), opportunity.max_participants.unwrap_or(10) as usize);\n    }\n\n    #[tokio::test]\n    async fn test_queue_size_limits() {\n        let config = create_test_config();\n        let mut opportunities = Vec::new();\n        \n        // Create more opportunities than max queue size\n        for i in 0..(config.max_queue_size + 10) {\n            let mut opp = create_test_opportunity();\n            opp.priority_score = i as f64; // Different priorities\n            opportunities.push(opp);\n        }\n        \n        // Sort by priority (highest first)\n        opportunities.sort_by(|a, b| b.priority_score.partial_cmp(\u0026a.priority_score).unwrap_or(std::cmp::Ordering::Equal));\n        \n        // Truncate to max size\n        if opportunities.len() \u003e config.max_queue_size as usize {\n            opportunities.truncate(config.max_queue_size as usize);\n        }\n        \n        assert_eq!(opportunities.len(), config.max_queue_size as usize);\n        \n        // Verify highest priority opportunities are kept\n        assert_eq!(opportunities[0].priority_score, (config.max_queue_size + 10 - 1) as f64);\n        assert_eq!(opportunities.last().unwrap().priority_score, 10.0);\n    }\n\n    #[tokio::test]\n    async fn test_activity_boost_calculation() {\n        let config = FairnessConfig::default();\n        let base_priority = 1.0;\n        \n        // Test with recent activity (within 1 hour)\n        let now = Utc::now().timestamp_millis() as u64;\n        let one_hour_ms = 60 * 60 * 1000;\n        let recent_activity = now - (one_hour_ms / 2); // 30 minutes ago\n        \n        let boosted_priority = if now - recent_activity \u003c one_hour_ms {\n            base_priority * config.activity_boost_factor\n        } else {\n            base_priority\n        };\n        \n        assert_eq!(boosted_priority, base_priority * 1.2);\n        \n        // Test with old activity (more than 1 hour)\n        let old_activity = now - (one_hour_ms * 2); // 2 hours ago\n        \n        let unboosted_priority = if now - old_activity \u003c one_hour_ms {\n            base_priority * config.activity_boost_factor\n        } else {\n            base_priority\n        };\n        \n        assert_eq!(unboosted_priority, base_priority);\n    }\n} ","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":305},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","services","mod.rs"],"content":"// src/services/mod.rs\n\npub mod exchange;\npub mod opportunity;\npub mod positions;\npub mod telegram;\npub mod user_profile;\npub mod global_opportunity;\npub mod ai_integration;\n\n// Re-export main service structs\npub use exchange::{ExchangeInterface, ExchangeService};\npub use opportunity::{OpportunityService, OpportunityServiceConfig};\npub use positions::{PositionsService, CreatePositionData, UpdatePositionData};\npub use telegram::{TelegramService, TelegramConfig};\npub use user_profile::UserProfileService;\npub use global_opportunity::GlobalOpportunityService;\npub use ai_integration::{AiIntegrationService, AiIntegrationConfig, AiProvider, AiAnalysisRequest, AiAnalysisResponse};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","services","opportunity.rs"],"content":"// src/services/opportunity.rs\n\nuse crate::log_error;\nuse crate::services::exchange::ExchangeService;\nuse crate::services::telegram::TelegramService;\nuse crate::types::{ArbitrageOpportunity, ArbitrageType, ExchangeIdEnum, FundingRateInfo, StructuredTradingPair};\nuse crate::utils::{ArbitrageError, ArbitrageResult};\nuse crate::services::exchange::ExchangeInterface;\nuse std::sync::Arc;\n\nuse futures::future::join_all;\nuse std::collections::HashMap;\n\n#[derive(Clone)]\npub struct OpportunityServiceConfig {\n    pub exchanges: Vec\u003cExchangeIdEnum\u003e,\n    pub monitored_pairs: Vec\u003cStructuredTradingPair\u003e,\n    pub threshold: f64,\n}\n\npub struct OpportunityService {\n    config: OpportunityServiceConfig,\n    exchange_service: Arc\u003cExchangeService\u003e,\n    telegram_service: Option\u003cArc\u003cTelegramService\u003e\u003e,\n}\n\nimpl OpportunityService {\n    pub fn new(\n        config: OpportunityServiceConfig,\n        exchange_service: Arc\u003cExchangeService\u003e,\n        telegram_service: Option\u003cArc\u003cTelegramService\u003e\u003e,\n    ) -\u003e Self {\n        Self {\n            config,\n            exchange_service,\n            telegram_service,\n        }\n    }\n\n    pub async fn find_opportunities(\n        \u0026self,\n        exchange_ids: \u0026[ExchangeIdEnum],\n        pairs: \u0026[String],\n        threshold: f64,\n    ) -\u003e ArbitrageResult\u003cVec\u003cArbitrageOpportunity\u003e\u003e {\n        let mut opportunities = Vec::new();\n\n        // Step 1: Fetch funding rates for all pairs and exchanges\n        let mut funding_rate_data: HashMap\u003c\n            String,\n            HashMap\u003cExchangeIdEnum, Option\u003cFundingRateInfo\u003e\u003e,\n        \u003e = HashMap::new();\n\n        // Initialize maps\n        for pair in pairs {\n            funding_rate_data.insert(pair.clone(), HashMap::new());\n        }\n\n        // Collect funding rate fetch operations\n        let mut funding_tasks = Vec::new();\n\n        for pair in pairs {\n            for exchange_id in exchange_ids {\n                let exchange_service = Arc::clone(\u0026self.exchange_service);\n                let pair = pair.clone();\n                let exchange_id = *exchange_id;\n\n                let task = Box::pin(async move {\n                    let result = exchange_service\n                        .fetch_funding_rates(\u0026exchange_id.to_string(), Some(\u0026pair))\n                        .await;\n                    \n                    // Parse the result to extract FundingRateInfo\n                    let funding_info = match result {\n                        Ok(rates) =\u003e {\n                            if let Some(rate_data) = rates.first() {\n                                // Extract funding rate from the response - handle parsing errors properly\n                                match rate_data[\"fundingRate\"].as_str() {\n                                    Some(rate_str) =\u003e {\n                                        match rate_str.parse::\u003cf64\u003e() {\n                                            Ok(funding_rate) =\u003e Some(FundingRateInfo {\n                                                symbol: pair.clone(),\n                                                funding_rate,\n                                                timestamp: Some(chrono::Utc::now()),\n                                                datetime: Some(chrono::Utc::now().to_rfc3339()),\n                                                next_funding_time: None,\n                                                estimated_rate: None,\n                                            }),\n                                            Err(parse_err) =\u003e {\n                                                log_error!(\"Failed to parse funding rate\", serde_json::json!({\n                                                    \"exchange\": exchange_id.to_string(),\n                                                    \"pair\": pair,\n                                                    \"raw_value\": rate_str,\n                                                    \"error\": parse_err.to_string()\n                                                }));\n                                                None\n                                            }\n                                        }\n                                    }\n                                    None =\u003e {\n                                        log_error!(\"Missing fundingRate field in response\", serde_json::json!({\n                                            \"exchange\": exchange_id.to_string(),\n                                            \"pair\": pair,\n                                            \"response\": rate_data\n                                        }));\n                                        None\n                                    }\n                                }\n                            } else {\n                                log_error!(\"Empty funding rates response\", serde_json::json!({\n                                    \"exchange\": exchange_id.to_string(),\n                                    \"pair\": pair\n                                }));\n                                None\n                            }\n                        }\n                        Err(fetch_err) =\u003e {\n                            log_error!(\"Failed to fetch funding rates\", serde_json::json!({\n                                \"exchange\": exchange_id.to_string(),\n                                \"pair\": pair,\n                                \"error\": fetch_err.to_string()\n                            }));\n                            None\n                        }\n                    };\n                    \n                    (pair, exchange_id, funding_info)\n                });\n                funding_tasks.push(task);\n            }\n        }\n\n        // Execute all funding rate fetch operations concurrently\n        let funding_results = join_all(funding_tasks).await;\n\n        // Process funding rate results\n        for (pair, exchange_id, funding_info) in funding_results {\n            if let Some(pair_map) = funding_rate_data.get_mut(\u0026pair) {\n                pair_map.insert(exchange_id, funding_info);\n            }\n        }\n\n        // Step 2: Identify opportunities\n        for pair in pairs {\n            if let Some(pair_funding_rates) = funding_rate_data.get(pair) {\n                let available_exchanges: Vec\u003cExchangeIdEnum\u003e = pair_funding_rates\n                    .iter()\n                    .filter_map(|(exchange_id, rate_info)| {\n                        if rate_info.is_some() {\n                            Some(*exchange_id)\n                        } else {\n                            None\n                        }\n                    })\n                    .collect();\n\n                if available_exchanges.len() \u003c 2 {\n                    continue;\n                }\n\n                // Compare all pairs of exchanges\n                for i in 0..available_exchanges.len() {\n                    for j in (i + 1)..available_exchanges.len() {\n                        let exchange_a = available_exchanges[i];\n                        let exchange_b = available_exchanges[j];\n\n                        if let (Some(Some(rate_a)), Some(Some(rate_b))) = (\n                            pair_funding_rates.get(\u0026exchange_a),\n                            pair_funding_rates.get(\u0026exchange_b),\n                        ) {\n                            let rate_diff = (rate_a.funding_rate - rate_b.funding_rate).abs();\n\n                            if rate_diff \u003e= threshold {\n                                // Determine which exchange to go long/short\n                                let (long_exchange, short_exchange, long_rate, short_rate) =\n                                    if rate_a.funding_rate \u003e rate_b.funding_rate {\n                                        (\n                                            exchange_b,\n                                            exchange_a,\n                                            rate_b.funding_rate,\n                                            rate_a.funding_rate,\n                                        )\n                                    } else {\n                                        (\n                                            exchange_a,\n                                            exchange_b,\n                                            rate_a.funding_rate,\n                                            rate_b.funding_rate,\n                                        )\n                                    };\n\n                                // For now, we'll set net difference same as rate difference\n                                // In a real implementation, you'd fetch trading fees and subtract them\n                                let net_difference = Some(rate_diff);\n\n                                // Create opportunity\n                                let opportunity = ArbitrageOpportunity {\n                                    id: uuid::Uuid::new_v4().to_string(),\n                                    pair: pair.clone(),\n                                    r#type: ArbitrageType::FundingRate,\n                                    long_exchange: Some(long_exchange),\n                                    short_exchange: Some(short_exchange),\n                                    long_rate: Some(long_rate),\n                                    short_rate: Some(short_rate),\n                                    rate_difference: rate_diff,\n                                    net_rate_difference: net_difference,\n                                    potential_profit_value: None, // Will be calculated if position size is known\n                                    timestamp: chrono::Utc::now().timestamp_millis() as u64,\n                                    details: Some(format!(\n                                        \"Funding rate arbitrage: Long {} ({}%) / Short {} ({}%)\",\n                                        long_exchange,\n                                        (long_rate * 100.0 * 10000.0).round() / 10000.0,\n                                        short_exchange,\n                                        (short_rate * 100.0 * 10000.0).round() / 10000.0\n                                    )),\n                                };\n\n                                opportunities.push(opportunity);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        Ok(opportunities)\n    }\n\n    pub async fn monitor_opportunities(\u0026self) -\u003e ArbitrageResult\u003cVec\u003cArbitrageOpportunity\u003e\u003e {\n        let pair_symbols: Vec\u003cString\u003e = self\n            .config\n            .monitored_pairs\n            .iter()\n            .map(|p| p.symbol.clone())\n            .collect();\n\n        self.find_opportunities(\u0026self.config.exchanges, \u0026pair_symbols, self.config.threshold)\n            .await\n    }\n\n    pub async fn process_opportunities(\n        \u0026self,\n        opportunities: \u0026[ArbitrageOpportunity],\n    ) -\u003e ArbitrageResult\u003c()\u003e {\n        if opportunities.is_empty() {\n            return Ok(());\n        }\n\n        // Send notifications if Telegram service is available\n        if let Some(telegram_service) = \u0026self.telegram_service {\n            for opportunity in opportunities {\n                if let Err(e) = telegram_service\n                    .send_opportunity_notification(opportunity)\n                    .await\n                {\n                    // Log error but don't fail the whole process\n                    log_error!(\"Failed to send Telegram notification\", serde_json::json!({\n                        \"error\": e.to_string(),\n                        \"opportunity_id\": opportunity.id,\n                        \"pair\": opportunity.pair\n                    }));\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    pub fn get_config(\u0026self) -\u003e \u0026OpportunityServiceConfig {\n        \u0026self.config\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":121},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","services","positions.rs"],"content":"// src/services/positions.rs\n\nuse crate::types::{ArbitragePosition, ExchangeIdEnum, PositionSide, PositionStatus};\nuse crate::utils::{ArbitrageError, ArbitrageResult};\nuse worker::kv::KvStore;\n\npub struct PositionsService {\n    kv_store: KvStore,\n}\n\nimpl PositionsService {\n    pub fn new(kv_store: KvStore) -\u003e Self {\n        Self { kv_store }\n    }\n\n    pub async fn create_position(\n        \u0026self,\n        position_data: CreatePositionData,\n    ) -\u003e ArbitrageResult\u003cArbitragePosition\u003e {\n        let id = uuid::Uuid::new_v4().to_string();\n        let now = chrono::Utc::now().timestamp_millis() as u64;\n\n        let position = ArbitragePosition {\n            id: id.clone(),\n            exchange: position_data.exchange,\n            pair: position_data.pair,\n            side: position_data.side,\n            size: position_data.size,\n            entry_price: position_data.entry_price,\n            current_price: None,\n            pnl: None,\n            status: PositionStatus::Open,\n            created_at: now,\n            updated_at: now,\n        };\n\n        // Store position\n        let key = format!(\"position:{}\", id);\n        let value = serde_json::to_string(\u0026position).map_err(|e| {\n            ArbitrageError::parse_error(format!(\"Failed to serialize position: {}\", e))\n        })?;\n\n        self.kv_store\n            .put(\u0026key, value)\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to store position: {}\", e))\n            })?\n            .execute()\n            .await\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to execute KV put: {}\", e))\n            })?;\n\n        // Update position index\n        self.add_to_position_index(\u0026id).await?;\n\n        Ok(position)\n    }\n\n    pub async fn get_position(\u0026self, id: \u0026str) -\u003e ArbitrageResult\u003cOption\u003cArbitragePosition\u003e\u003e {\n        let key = format!(\"position:{}\", id);\n\n        match self.kv_store.get(\u0026key).text().await {\n            Ok(Some(value)) =\u003e {\n                let position: ArbitragePosition = serde_json::from_str(\u0026value).map_err(|e| {\n                    ArbitrageError::parse_error(format!(\"Failed to deserialize position: {}\", e))\n                })?;\n                Ok(Some(position))\n            }\n            Ok(None) =\u003e Ok(None),\n            Err(e) =\u003e Err(ArbitrageError::database_error(format!(\n                \"Failed to get position: {}\",\n                e\n            ))),\n        }\n    }\n\n    pub async fn update_position(\n        \u0026self,\n        id: \u0026str,\n        update_data: UpdatePositionData,\n    ) -\u003e ArbitrageResult\u003cOption\u003cArbitragePosition\u003e\u003e {\n        let mut position = match self.get_position(id).await? {\n            Some(pos) =\u003e pos,\n            None =\u003e return Ok(None),\n        };\n\n        // Update fields if provided\n        if let Some(size) = update_data.size {\n            position.size = size;\n        }\n        if let Some(current_price) = update_data.current_price {\n            position.current_price = Some(current_price);\n        }\n        if let Some(pnl) = update_data.pnl {\n            position.pnl = Some(pnl);\n        }\n        if let Some(status) = update_data.status {\n            position.status = status;\n        }\n\n        position.updated_at = chrono::Utc::now().timestamp_millis() as u64;\n\n        // Store updated position\n        let key = format!(\"position:{}\", id);\n        let value = serde_json::to_string(\u0026position).map_err(|e| {\n            ArbitrageError::parse_error(format!(\"Failed to serialize position: {}\", e))\n        })?;\n\n        self.kv_store\n            .put(\u0026key, value)\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to store position: {}\", e))\n            })?\n            .execute()\n            .await\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to execute KV put: {}\", e))\n            })?;\n\n        Ok(Some(position))\n    }\n\n    pub async fn close_position(\u0026self, id: \u0026str) -\u003e ArbitrageResult\u003cbool\u003e {\n        let update_data = UpdatePositionData {\n            size: None,\n            current_price: None,\n            pnl: None,\n            status: Some(PositionStatus::Closed),\n        };\n\n        match self.update_position(id, update_data).await? {\n            Some(_) =\u003e Ok(true),\n            None =\u003e Ok(false),\n        }\n    }\n\n    pub async fn get_all_positions(\u0026self) -\u003e ArbitrageResult\u003cVec\u003cArbitragePosition\u003e\u003e {\n        // Get position IDs from index\n        let position_ids = self.get_position_index().await?;\n        let mut positions = Vec::new();\n\n        for id in position_ids {\n            if let Some(position) = self.get_position(\u0026id).await? {\n                positions.push(position);\n            }\n        }\n\n        Ok(positions)\n    }\n\n    pub async fn get_open_positions(\u0026self) -\u003e ArbitrageResult\u003cVec\u003cArbitragePosition\u003e\u003e {\n        let all_positions = self.get_all_positions().await?;\n        Ok(all_positions\n            .into_iter()\n            .filter(|pos| pos.status == PositionStatus::Open)\n            .collect())\n    }\n\n    pub async fn calculate_total_pnl(\u0026self) -\u003e ArbitrageResult\u003cf64\u003e {\n        let positions = self.get_open_positions().await?;\n        let total_pnl = positions.iter().filter_map(|pos| pos.pnl).sum();\n        Ok(total_pnl)\n    }\n\n    // Helper methods for position index management\n    async fn get_position_index(\u0026self) -\u003e ArbitrageResult\u003cVec\u003cString\u003e\u003e {\n        match self.kv_store.get(\"positions:index\").text().await {\n            Ok(Some(value)) =\u003e {\n                let ids: Vec\u003cString\u003e = serde_json::from_str(\u0026value).map_err(|e| {\n                    ArbitrageError::parse_error(format!(\"Failed to deserialize position index: {}\", e))\n                })?;\n                Ok(ids)\n            }\n            Ok(None) =\u003e Ok(Vec::new()),\n            Err(e) =\u003e Err(ArbitrageError::database_error(format!(\n                \"Failed to get position index: {}\",\n                e\n            ))),\n        }\n    }\n\n    async fn add_to_position_index(\u0026self, position_id: \u0026str) -\u003e ArbitrageResult\u003c()\u003e {\n        let mut index = self.get_position_index().await?;\n        if !index.contains(\u0026position_id.to_string()) {\n            index.push(position_id.to_string());\n            self.save_position_index(\u0026index).await?;\n        }\n        Ok(())\n    }\n\n    async fn remove_from_position_index(\u0026self, position_id: \u0026str) -\u003e ArbitrageResult\u003c()\u003e {\n        let mut index = self.get_position_index().await?;\n        index.retain(|id| id != position_id);\n        self.save_position_index(\u0026index).await?;\n        Ok(())\n    }\n\n    async fn save_position_index(\u0026self, index: \u0026[String]) -\u003e ArbitrageResult\u003c()\u003e {\n        let value = serde_json::to_string(index).map_err(|e| {\n            ArbitrageError::parse_error(format!(\"Failed to serialize position index: {}\", e))\n        })?;\n\n        self.kv_store\n            .put(\"positions:index\", value)\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to store position index: {}\", e))\n            })?\n            .execute()\n            .await\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to execute position index put: {}\", e))\n            })?;\n\n        Ok(())\n    }\n}\n\n// Helper structs for position operations\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct CreatePositionData {\n    pub exchange: ExchangeIdEnum,\n    pub pair: String,\n    pub side: PositionSide,\n    pub size: f64,\n    pub entry_price: f64,\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct UpdatePositionData {\n    pub size: Option\u003cf64\u003e,\n    pub current_price: Option\u003cf64\u003e,\n    pub pnl: Option\u003cf64\u003e,\n    pub status: Option\u003cPositionStatus\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::{ArbitragePosition, ExchangeIdEnum, ArbitrageType};\n    use serde_json::json;\n    use std::collections::HashMap;\n\n    // Mock KV storage for testing\n    #[derive(Debug, Clone)]\n    struct MockKvNamespace {\n        data: HashMap\u003cString, String\u003e,\n    }\n\n    impl MockKvNamespace {\n        fn new() -\u003e Self {\n            Self {\n                data: HashMap::new(),\n            }\n        }\n\n        fn with_data(mut self, key: \u0026str, value: \u0026str) -\u003e Self {\n            self.data.insert(key.to_string(), value.to_string());\n            self\n        }\n\n        async fn get(\u0026self, key: \u0026str) -\u003e Option\u003cString\u003e {\n            self.data.get(key).cloned()\n        }\n\n        async fn put(\u0026mut self, key: \u0026str, value: \u0026str) -\u003e Result\u003c(), String\u003e {\n            self.data.insert(key.to_string(), value.to_string());\n            Ok(())\n        }\n\n        async fn delete(\u0026mut self, key: \u0026str) -\u003e Result\u003c(), String\u003e {\n            self.data.remove(key);\n            Ok(())\n        }\n\n        async fn list_with_prefix(\u0026self, prefix: \u0026str) -\u003e Vec\u003cString\u003e {\n            self.data\n                .keys()\n                .filter(|k| k.starts_with(prefix))\n                .cloned()\n                .collect()\n        }\n    }\n\n    fn create_test_position(id: \u0026str, pair: \u0026str) -\u003e ArbitragePosition {\n        ArbitragePosition {\n            id: id.to_string(),\n            exchange: ExchangeIdEnum::Binance,\n            pair: pair.to_string(),\n            side: PositionSide::Long,\n            size: 1000.0,\n            entry_price: 45000.0,\n            current_price: Some(45100.0),\n            pnl: Some(15.5),\n            status: PositionStatus::Open,\n            created_at: chrono::Utc::now().timestamp_millis() as u64,\n            updated_at: chrono::Utc::now().timestamp_millis() as u64,\n        }\n    }\n\n    mod service_initialization {\n        use super::*;\n        use worker::kv::KvStore;\n\n        // Mock KV store for testing\n        fn create_mock_kv_store() -\u003e KvStore {\n            // This would normally be created from worker::Env in real usage\n            // For testing, we'll need to handle this differently\n            panic!(\"Mock KV store creation not implemented - this test needs actual Worker environment\")\n        }\n\n        #[test]\n        #[should_panic(expected = \"Mock KV store creation not implemented\")]\n        fn test_new_positions_service() {\n            let kv_store = create_mock_kv_store();\n            let service = PositionsService::new(kv_store);\n            \n            // Service should be created successfully\n            assert_eq!(std::mem::size_of_val(\u0026service), std::mem::size_of::\u003cPositionsService\u003e());\n        }\n\n        #[test]\n        fn test_positions_service_is_send_sync() {\n            fn assert_send\u003cT: Send\u003e() {}\n            fn assert_sync\u003cT: Sync\u003e() {}\n            \n            assert_send::\u003cPositionsService\u003e();\n            assert_sync::\u003cPositionsService\u003e();\n        }\n    }\n\n    mod position_data_validation {\n        use super::*;\n\n        #[test]\n        fn test_position_structure_creation() {\n            let position = create_test_position(\"test_001\", \"BTCUSDT\");\n            \n            assert_eq!(position.id, \"test_001\");\n            assert_eq!(position.pair, \"BTCUSDT\");\n            assert_eq!(position.size, 1000.0);\n            assert_eq!(position.entry_price, 45000.0);\n            assert_eq!(position.status, PositionStatus::Open);\n            assert_eq!(position.exchange, ExchangeIdEnum::Binance);\n            assert_eq!(position.side, PositionSide::Long);\n        }\n\n        #[test]\n        fn test_position_pnl_calculations() {\n            let position = create_test_position(\"test_002\", \"ETHUSDT\");\n            \n            // Test that PnL values are reasonable\n            assert!(position.pnl.unwrap() \u003e 0.0);\n            \n            // Test price data\n            assert!(position.entry_price \u003e 0.0);\n            assert!(position.current_price.unwrap() \u003e 0.0);\n        }\n\n        #[test]\n        fn test_position_exchange_assignment() {\n            let position = create_test_position(\"test_003\", \"ADAUSDT\");\n            \n            assert_eq!(position.exchange, ExchangeIdEnum::Binance);\n            assert_eq!(position.side, PositionSide::Long);\n        }\n\n        #[test]\n        fn test_position_timing_validation() {\n            let position = create_test_position(\"test_004\", \"SOLUSDT\");\n            \n            // Created at should be recent\n            let now = chrono::Utc::now().timestamp_millis() as u64;\n            assert!(position.created_at \u003c= now);\n            assert!(position.created_at \u003e now - 1000); // Within last second\n            \n            // Updated at should be recent\n            assert!(position.updated_at \u003c= now);\n            assert!(position.updated_at \u003e now - 1000);\n        }\n    }\n\n    mod kv_storage_operations {\n        use super::*;\n\n        #[test]\n        fn test_position_key_generation() {\n            let position_id = \"test_pos_001\";\n            \n            let key = format!(\"position:{}\", position_id);\n            assert_eq!(key, \"position:test_pos_001\");\n        }\n\n        #[test]\n        fn test_index_key_generation() {\n            let key = \"positions:index\";\n            assert_eq!(key, \"positions:index\");\n        }\n\n        #[test]\n        fn test_position_serialization() {\n            let position = create_test_position(\"ser_test\", \"BTCUSDT\");\n            \n            // Test that position can be serialized to JSON\n            let json_result = serde_json::to_string(\u0026position);\n            assert!(json_result.is_ok());\n            \n            let json_str = json_result.unwrap();\n            assert!(json_str.contains(\"ser_test\"));\n            assert!(json_str.contains(\"BTCUSDT\"));\n            assert!(json_str.contains(\"open\")); // Status is serialized as lowercase due to serde rename_all\n        }\n\n        #[test]\n        fn test_position_deserialization() {\n            let position = create_test_position(\"deser_test\", \"ETHUSDT\");\n            \n            // Serialize then deserialize\n            let json_str = serde_json::to_string(\u0026position).unwrap();\n            let deserialized: Result\u003cArbitragePosition, _\u003e = serde_json::from_str(\u0026json_str);\n            \n            assert!(deserialized.is_ok());\n            let deser_position = deserialized.unwrap();\n            \n            assert_eq!(deser_position.id, position.id);\n            assert_eq!(deser_position.pair, position.pair);\n            assert_eq!(deser_position.size, position.size);\n            assert_eq!(deser_position.status, position.status);\n        }\n    }\n\n    mod error_handling {\n        use super::*;\n\n        #[test]\n        fn test_invalid_position_id_handling() {\n            // Test with empty position ID\n            let empty_id = \"\";\n            assert!(empty_id.is_empty());\n            \n            // Test with invalid UUID format\n            let invalid_uuid = \"not-a-uuid\";\n            assert!(!invalid_uuid.contains('-') || invalid_uuid.len() \u003c 36);\n        }\n\n        #[test]\n        fn test_json_parsing_errors() {\n            // Test invalid JSON\n            let invalid_json = r#\"{\"id\": \"test\", \"pair\": }\"#;\n            let result: Result\u003cArbitragePosition, _\u003e = serde_json::from_str(invalid_json);\n            assert!(result.is_err());\n            \n            // Test missing required fields\n            let incomplete_json = r#\"{\"id\": \"test\"}\"#;\n            let result: Result\u003cArbitragePosition, _\u003e = serde_json::from_str(incomplete_json);\n            assert!(result.is_err());\n        }\n\n        #[test]\n        fn test_position_validation_edge_cases() {\n            let mut position = create_test_position(\"edge_test\", \"BTCUSDT\");\n            \n            // Test with zero position size\n            position.size = 0.0;\n            assert_eq!(position.size, 0.0);\n            \n            // Test with negative entry price (should be handled by business logic)\n            position.entry_price = -10.0;\n            assert!(position.entry_price \u003c 0.0);\n            \n            // Test with very large numbers\n            position.size = f64::MAX / 2.0;\n            assert!(position.size \u003e 1e100);\n        }\n    }\n\n    mod business_logic {\n        use super::*;\n\n        #[test]\n        fn test_position_status_transitions() {\n            let mut position = create_test_position(\"status_test\", \"BTCUSDT\");\n            \n            // Initial status should be open\n            assert_eq!(position.status, PositionStatus::Open);\n            \n            // Simulate status change\n            position.status = PositionStatus::Closed;\n            position.updated_at = chrono::Utc::now().timestamp_millis() as u64;\n            \n            assert_eq!(position.status, PositionStatus::Closed);\n        }\n\n        #[test]\n        fn test_pnl_calculation_logic() {\n            let position = create_test_position(\"pnl_test\", \"ETHUSDT\");\n            \n            // Test that PnL calculation inputs are present\n            assert!(position.entry_price \u003e 0.0);\n            assert!(position.current_price.is_some());\n            assert!(position.size \u003e 0.0);\n            \n            // Simulate PnL calculation\n            let entry_price = position.entry_price;\n            let current_price = position.current_price.unwrap();\n            let size = position.size;\n            \n            let calculated_pnl = if position.side == PositionSide::Long {\n                (current_price - entry_price) * size\n            } else {\n                (entry_price - current_price) * size\n            };\n            \n            // Should be able to calculate PnL\n            assert!(calculated_pnl.is_finite());\n        }\n\n        #[test]\n        fn test_position_side_logic() {\n            let long_position = create_test_position(\"long_test\", \"BTCUSDT\");\n            assert_eq!(long_position.side, PositionSide::Long);\n            \n            let mut short_position = create_test_position(\"short_test\", \"ETHUSDT\");\n            short_position.side = PositionSide::Short;\n            assert_eq!(short_position.side, PositionSide::Short);\n        }\n\n        #[test]\n        fn test_exchange_assignment() {\n            let position = create_test_position(\"exchange_test\", \"ADAUSDT\");\n            assert_eq!(position.exchange, ExchangeIdEnum::Binance);\n            \n            let mut bybit_position = create_test_position(\"bybit_test\", \"SOLUSDT\");\n            bybit_position.exchange = ExchangeIdEnum::Bybit;\n            assert_eq!(bybit_position.exchange, ExchangeIdEnum::Bybit);\n        }\n\n        #[test]\n        fn test_risk_metrics_calculation() {\n            let position = create_test_position(\"risk_test\", \"BTCUSDT\");\n            \n            // Calculate percentage return\n            let pnl = position.pnl.unwrap();\n            let notional_value = position.entry_price * position.size;\n            let return_percentage = (pnl / notional_value) * 100.0;\n            \n            assert!(return_percentage.is_finite());\n            assert!(return_percentage \u003e -100.0); // Reasonable bounds\n        }\n\n        #[test]\n        fn test_position_lifecycle_timing() {\n            let position = create_test_position(\"lifecycle_test\", \"ETHUSDT\");\n            \n            let created_at = position.created_at;\n            let updated_at = position.updated_at;\n            let now = chrono::Utc::now().timestamp_millis() as u64;\n            \n            // Created at should be in the past or present\n            assert!(created_at \u003c= now);\n            \n            // Updated at should be \u003e= created at\n            assert!(updated_at \u003e= created_at);\n        }\n    }\n\n    mod service_methods {\n        use super::*;\n\n        #[test]\n        fn test_create_position_data_structure() {\n            let create_data = CreatePositionData {\n                exchange: ExchangeIdEnum::Binance,\n                pair: \"BTCUSDT\".to_string(),\n                side: PositionSide::Long,\n                size: 1000.0,\n                entry_price: 45000.0,\n            };\n            \n            assert_eq!(create_data.exchange, ExchangeIdEnum::Binance);\n            assert_eq!(create_data.pair, \"BTCUSDT\");\n            assert_eq!(create_data.side, PositionSide::Long);\n            assert_eq!(create_data.size, 1000.0);\n            assert_eq!(create_data.entry_price, 45000.0);\n        }\n\n        #[test]\n        fn test_update_position_data_structure() {\n            let update_data = UpdatePositionData {\n                size: Some(1500.0),\n                current_price: Some(45200.0),\n                pnl: Some(25.5),\n                status: Some(PositionStatus::Open),\n            };\n            \n            assert_eq!(update_data.size, Some(1500.0));\n            assert_eq!(update_data.current_price, Some(45200.0));\n            assert_eq!(update_data.pnl, Some(25.5));\n            assert_eq!(update_data.status, Some(PositionStatus::Open));\n        }\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":111},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","services","telegram.rs"],"content":"// src/services/telegram.rs\n\nuse crate::types::ArbitrageOpportunity;\nuse crate::utils::{ArbitrageError, ArbitrageResult};\nuse crate::utils::formatter::{format_opportunity_message, escape_markdown_v2};\nuse chrono::Utc;\nuse reqwest::Client;\nuse serde_json::{json, Value};\n\n#[derive(Clone)]\npub struct TelegramConfig {\n    pub bot_token: String,\n    pub chat_id: String,\n}\n\npub struct TelegramService {\n    config: TelegramConfig,\n    http_client: Client,\n}\n\nimpl TelegramService {\n    pub fn new(config: TelegramConfig) -\u003e Self {\n        Self {\n            config,\n            http_client: Client::new(),\n        }\n    }\n\n    pub async fn send_message(\u0026self, text: \u0026str) -\u003e ArbitrageResult\u003c()\u003e {\n        let url = format!(\"https://api.telegram.org/bot{}/sendMessage\", self.config.bot_token);\n        \n        let payload = json!({\n            \"chat_id\": self.config.chat_id,\n            \"text\": text,\n            \"parse_mode\": \"MarkdownV2\"\n        });\n\n        let response = self.http_client\n            .post(\u0026url)\n            .json(\u0026payload)\n            .send()\n            .await\n            .map_err(|e| ArbitrageError::network_error(format!(\"Failed to send Telegram message: {}\", e)))?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_default();\n            return Err(ArbitrageError::telegram_error(format!(\"Telegram API error: {}\", error_text)));\n        }\n\n        let result: Value = response.json().await\n            .map_err(|e| ArbitrageError::parse_error(format!(\"Failed to parse Telegram response: {}\", e)))?;\n\n        if !result[\"ok\"].as_bool().unwrap_or(false) {\n            let error_description = result[\"description\"].as_str().unwrap_or(\"Unknown error\");\n            return Err(ArbitrageError::telegram_error(format!(\"Telegram API error: {}\", error_description)));\n        }\n\n        Ok(())\n    }\n\n    pub async fn send_opportunity_notification(\u0026self, opportunity: \u0026ArbitrageOpportunity) -\u003e ArbitrageResult\u003c()\u003e {\n        let message = format_opportunity_message(opportunity);\n        self.send_message(\u0026message).await\n    }\n\n    // Bot command handlers (for webhook mode)\n    pub async fn handle_webhook(\u0026self, update: Value) -\u003e ArbitrageResult\u003cOption\u003cString\u003e\u003e {\n        if let Some(message) = update[\"message\"].as_object() {\n            if let Some(text) = message[\"text\"].as_str() {\n                return self.handle_command(text).await;\n            }\n        }\n        Ok(None)\n    }\n\n    async fn handle_command(\u0026self, text: \u0026str) -\u003e ArbitrageResult\u003cOption\u003cString\u003e\u003e {\n        match text {\n            \"/start\" =\u003e Ok(Some(\n                \"Welcome to the Arbitrage Bot!\\n\\\n                I can help you detect funding rate arbitrage opportunities and notify you about them.\\n\\n\\\n                Here are the available commands:\\n\\\n                /help - Show this help message and list all commands.\\n\\\n                /status - Check the bot's current operational status.\\n\\\n                /opportunities - Show recent arbitrage opportunities (currently placeholder).\\n\\\n                /settings - View current bot settings (currently placeholder).\\n\\n\\\n                Use /help to see this list again.\".to_string()\n            )),\n            \"/help\" =\u003e Ok(Some(\n                \"Available commands:\\n\\\n                /help - Show this help message\\n\\\n                /status - Check bot status\\n\\\n                /opportunities - Show recent opportunities\\n\\\n                /settings - View current settings\".to_string()\n            )),\n            \"/status\" =\u003e {\n                let now = chrono::Utc::now().format(\"%Y-%m-%d %H:%M:%S UTC\");\n                Ok(Some(format!(\n                    \"Bot is active and monitoring for arbitrage opportunities.\\nCurrent time: {}\",\n                    now\n                )))\n            }\n            \"/opportunities\" =\u003e Ok(Some(\n                \"No recent opportunities found. Will notify you when new ones are detected.\".to_string()\n            )),\n            \"/settings\" =\u003e Ok(Some(\n                \"Current settings:\\n\\\n                Threshold: 0.001 (0.1%)\\n\\\n                Pairs monitored: BTC/USDT, ETH/USDT\\n\\\n                Exchanges: Binance, Bybit, OKX\".to_string()\n            )),\n            _ =\u003e Ok(None), // Unknown command, no response\n        }\n    }\n\n    pub async fn set_webhook(\u0026self, webhook_url: \u0026str) -\u003e ArbitrageResult\u003c()\u003e {\n        let url = format!(\"https://api.telegram.org/bot{}/setWebhook\", self.config.bot_token);\n        \n        let payload = json!({\n            \"url\": webhook_url\n        });\n\n        let response = self.http_client\n            .post(\u0026url)\n            .json(\u0026payload)\n            .send()\n            .await\n            .map_err(|e| ArbitrageError::network_error(format!(\"Failed to set webhook: {}\", e)))?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_default();\n            return Err(ArbitrageError::telegram_error(format!(\"Failed to set webhook: {}\", error_text)));\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::{ArbitrageOpportunity, ArbitrageType, ExchangeIdEnum};\n    use serde_json::json;\n    use chrono::Datelike; // Import for year(), month(), day() methods\n\n    fn create_test_config() -\u003e TelegramConfig {\n        TelegramConfig {\n            bot_token: \"test_token_123456789:ABCDEF\".to_string(),\n            chat_id: \"-123456789\".to_string(),\n        }\n    }\n\n    fn create_test_opportunity() -\u003e ArbitrageOpportunity {\n        ArbitrageOpportunity {\n            id: \"test_opp_001\".to_string(),\n            pair: \"BTCUSDT\".to_string(),\n            r#type: ArbitrageType::FundingRate,\n            long_exchange: Some(ExchangeIdEnum::Binance),\n            short_exchange: Some(ExchangeIdEnum::Bybit),\n            long_rate: Some(0.001),\n            short_rate: Some(0.003),\n            rate_difference: 0.002,\n            net_rate_difference: Some(0.0018),\n            potential_profit_value: Some(18.0),\n            timestamp: 1640995200000, // Jan 1, 2022\n            details: Some(\"Test funding rate arbitrage opportunity\".to_string()),\n        }\n    }\n\n    mod service_initialization {\n        use super::*;\n\n        #[test]\n        fn test_new_telegram_service() {\n            let config = create_test_config();\n            let service = TelegramService::new(config.clone());\n            \n            // Service should be created successfully\n            assert_eq!(std::mem::size_of_val(\u0026service), std::mem::size_of::\u003cTelegramService\u003e());\n        }\n\n        #[test]\n        fn test_telegram_service_is_send_sync() {\n            fn assert_send\u003cT: Send\u003e() {}\n            fn assert_sync\u003cT: Sync\u003e() {}\n            \n            assert_send::\u003cTelegramService\u003e();\n            assert_sync::\u003cTelegramService\u003e();\n        }\n\n        #[test]\n        fn test_config_validation_valid() {\n            let config = create_test_config();\n            \n            assert!(!config.bot_token.is_empty());\n            assert!(!config.chat_id.is_empty());\n        }\n\n        #[test]\n        fn test_config_basic_structure() {\n            let config = create_test_config();\n            \n            let service = TelegramService::new(config);\n            // Service should be created successfully\n            assert_eq!(std::mem::size_of_val(\u0026service), std::mem::size_of::\u003cTelegramService\u003e());\n        }\n\n        #[test]\n        fn test_disabled_service_handling() {\n            let config = create_test_config();\n            \n            let service = TelegramService::new(config);\n            // Service should be created (enabling/disabling would be handled at application level)\n            assert_eq!(std::mem::size_of_val(\u0026service), std::mem::size_of::\u003cTelegramService\u003e());\n        }\n    }\n\n    mod configuration_validation {\n        use super::*;\n\n        #[test]\n        fn test_bot_token_format() {\n            let config = create_test_config();\n            \n            // Bot token should contain colon\n            assert!(config.bot_token.contains(':'));\n            \n            // Should have reasonable length\n            assert!(config.bot_token.len() \u003e 10);\n        }\n\n        #[test]\n        fn test_chat_id_format() {\n            let config = create_test_config();\n            \n            // Chat ID should be negative for groups\n            assert!(config.chat_id.starts_with('-'));\n            \n            // Should be numeric after the dash\n            let numeric_part = \u0026config.chat_id[1..];\n            assert!(numeric_part.parse::\u003ci64\u003e().is_ok());\n        }\n\n        #[test]\n        fn test_webhook_url_validation() {\n            let config = create_test_config();\n            \n            // Test webhook URL format validation (separate from config)\n            let webhook_url = \"https://example.com/webhook\";\n            assert!(webhook_url.starts_with(\"https://\"));\n            assert!(webhook_url.len() \u003e 10);\n        }\n\n        #[test]\n        fn test_optional_webhook() {\n            let config = create_test_config();\n            \n            let service = TelegramService::new(config);\n            // Should work without webhook URL (webhook is set separately)\n            assert_eq!(std::mem::size_of_val(\u0026service), std::mem::size_of::\u003cTelegramService\u003e());\n        }\n    }\n\n    mod message_formatting {\n        use super::*;\n\n        #[test]\n        fn test_escape_markdown_v2_basic() {\n            let input = \"Hello World!\";\n            let escaped = escape_markdown_v2(input);\n            \n            // Should escape exclamation mark since it's a special MarkdownV2 character\n            assert_eq!(escaped, \"Hello World\\\\!\");\n        }\n\n        #[test]\n        fn test_escape_markdown_v2_special_chars() {\n            let input = \"Price: $1,234.56 (10% gain)\";\n            let escaped = escape_markdown_v2(input);\n            \n            // Should escape special characters that are in the escape list\n            // Note: $ is not a special character in MarkdownV2, so it won't be escaped\n            assert!(escaped.contains(\"\\\\(\"));\n            assert!(escaped.contains(\"\\\\)\"));\n            assert!(escaped.contains(\"\\\\.\"));\n            // $ remains unescaped as it's not a special MarkdownV2 character\n            assert!(escaped.contains(\"$\"));\n        }\n\n        #[test]\n        fn test_escape_markdown_v2_comprehensive() {\n            let input = \"_*[]()~`\u003e#+-=|{}.!\";\n            let escaped = escape_markdown_v2(input);\n            \n            // All special characters should be escaped\n            assert!(escaped.contains(\"\\\\_\"));\n            assert!(escaped.contains(\"\\\\*\"));\n            assert!(escaped.contains(\"\\\\[\"));\n            assert!(escaped.contains(\"\\\\]\"));\n            assert!(escaped.contains(\"\\\\(\"));\n            assert!(escaped.contains(\"\\\\)\"));\n            assert!(escaped.contains(\"\\\\~\"));\n            assert!(escaped.contains(\"\\\\`\"));\n            assert!(escaped.contains(\"\\\\\u003e\"));\n            assert!(escaped.contains(\"\\\\#\"));\n            assert!(escaped.contains(\"\\\\+\"));\n            assert!(escaped.contains(\"\\\\-\"));\n            assert!(escaped.contains(\"\\\\=\"));\n            assert!(escaped.contains(\"\\\\|\"));\n            assert!(escaped.contains(\"\\\\{\"));\n            assert!(escaped.contains(\"\\\\}\"));\n            assert!(escaped.contains(\"\\\\.\"));\n            assert!(escaped.contains(\"\\\\!\"));\n        }\n\n        #[test]\n        fn test_format_percentage() {\n            let rate = 0.001; // 0.1%\n            \n            // Should format as percentage with basis points\n            let formatted_100 = format!(\"{:.2}%\", rate * 100.0);\n            assert_eq!(formatted_100, \"0.10%\");\n            \n            let formatted_10000 = format!(\"{:.1} bps\", rate * 10000.0);\n            assert_eq!(formatted_10000, \"10.0 bps\");\n        }\n\n        #[test]\n        fn test_opportunity_message_components() {\n            let opportunity = create_test_opportunity();\n            \n            // Test individual message components\n            assert_eq!(opportunity.pair, \"BTCUSDT\");\n            assert_eq!(opportunity.rate_difference, 0.002);\n            assert!(opportunity.long_exchange.is_some());\n            assert!(opportunity.short_exchange.is_some());\n            assert!(opportunity.potential_profit_value.is_some());\n        }\n    }\n\n    mod opportunity_notifications {\n        use super::*;\n\n        #[test]\n        fn test_opportunity_data_extraction() {\n            let opportunity = create_test_opportunity();\n            \n            // Verify all required data is present\n            assert!(!opportunity.id.is_empty());\n            assert!(!opportunity.pair.is_empty());\n            assert!(opportunity.rate_difference \u003e 0.0);\n            \n            // Exchange data\n            let long_exchange = opportunity.long_exchange.unwrap();\n            let short_exchange = opportunity.short_exchange.unwrap();\n            assert_ne!(long_exchange, short_exchange);\n            \n            // Rate data\n            let long_rate = opportunity.long_rate.unwrap();\n            let short_rate = opportunity.short_rate.unwrap();\n            assert_ne!(long_rate, short_rate);\n        }\n\n        #[test]\n        fn test_profit_calculation_data() {\n            let opportunity = create_test_opportunity();\n            \n            if let Some(profit) = opportunity.potential_profit_value {\n                assert!(profit \u003e 0.0);\n                assert!(profit.is_finite());\n            }\n            \n            if let Some(net_diff) = opportunity.net_rate_difference {\n                assert!(net_diff \u003e 0.0);\n                assert!(net_diff \u003c= opportunity.rate_difference);\n            }\n        }\n\n        #[test]\n        fn test_message_timestamp_handling() {\n            let opportunity = create_test_opportunity();\n            \n            // Timestamp should be valid\n            assert!(opportunity.timestamp \u003e 0);\n            \n            // Should be reasonable (after year 2020, before year 2030)\n            let min_timestamp = 1577836800000u64; // Jan 1, 2020\n            let max_timestamp = 1893456000000u64; // Jan 1, 2030\n            \n            assert!(opportunity.timestamp \u003e min_timestamp);\n            assert!(opportunity.timestamp \u003c max_timestamp);\n        }\n\n        #[test]\n        fn test_opportunity_type_validation() {\n            let opportunity = create_test_opportunity();\n            \n            assert_eq!(opportunity.r#type, ArbitrageType::FundingRate);\n        }\n    }\n\n    mod error_handling {\n        use super::*;\n\n        #[test]\n        fn test_invalid_config_handling() {\n            // Empty bot token\n            let mut config = create_test_config();\n            config.bot_token = String::new();\n            \n            // Service should still be created but might fail on API calls\n            let service = TelegramService::new(config);\n            assert_eq!(std::mem::size_of_val(\u0026service), std::mem::size_of::\u003cTelegramService\u003e());\n        }\n\n        #[test]\n        fn test_malformed_chat_id() {\n            let mut config = create_test_config();\n            config.chat_id = \"not_a_number\".to_string();\n            \n            // Service creation should work, validation happens at runtime\n            let service = TelegramService::new(config);\n            assert_eq!(std::mem::size_of_val(\u0026service), std::mem::size_of::\u003cTelegramService\u003e());\n        }\n\n        #[test]\n        fn test_disabled_service_handling() {\n            let config = create_test_config();\n            \n            let service = TelegramService::new(config);\n            // Service should be created (enabling/disabling would be handled at application level)\n            assert_eq!(std::mem::size_of_val(\u0026service), std::mem::size_of::\u003cTelegramService\u003e());\n        }\n\n        #[test]\n        fn test_empty_opportunity_data() {\n            let mut opportunity = create_test_opportunity();\n            opportunity.id = String::new();\n            opportunity.pair = String::new();\n            \n            // Should handle empty data gracefully\n            assert!(opportunity.id.is_empty());\n            assert!(opportunity.pair.is_empty());\n        }\n    }\n\n    mod api_interaction {\n        use super::*;\n\n        #[test]\n        fn test_telegram_api_url_construction() {\n            let config = create_test_config();\n            let service = TelegramService::new(config.clone());\n            \n            // Construct expected API URL\n            let expected_base = format!(\"https://api.telegram.org/bot{}\", config.bot_token);\n            assert!(expected_base.contains(\"test_token_123456789\"));\n            assert!(expected_base.contains(\"api.telegram.org\"));\n        }\n\n        #[test]\n        fn test_webhook_url_validation() {\n            let config = create_test_config();\n            \n            // Test webhook URL format validation (separate from config)\n            let webhook_url = \"https://example.com/webhook\";\n            assert!(webhook_url.starts_with(\"https://\"));\n            assert!(webhook_url.len() \u003e 10);\n        }\n\n        #[test]\n        fn test_message_payload_structure() {\n            let config = create_test_config();\n            let opportunity = create_test_opportunity();\n            \n            // Simulate message payload construction\n            let payload = json!({\n                \"chat_id\": config.chat_id,\n                \"text\": \"Test message\",\n                \"parse_mode\": \"MarkdownV2\"\n            });\n            \n            assert_eq!(payload[\"chat_id\"], config.chat_id);\n            assert_eq!(payload[\"parse_mode\"], \"MarkdownV2\");\n            assert!(payload[\"text\"].is_string());\n        }\n    }\n\n    mod webhook_handling {\n        use super::*;\n\n        #[test]\n        fn test_webhook_data_structure() {\n            // Simulate incoming webhook data\n            let webhook_data = json!({\n                \"update_id\": 123456789,\n                \"message\": {\n                    \"message_id\": 1,\n                    \"from\": {\n                        \"id\": 987654321,\n                        \"is_bot\": false,\n                        \"first_name\": \"Test\",\n                        \"username\": \"testuser\"\n                    },\n                    \"chat\": {\n                        \"id\": -123456789,\n                        \"title\": \"Test Group\",\n                        \"type\": \"group\"\n                    },\n                    \"date\": 1640995200,\n                    \"text\": \"/start\"\n                }\n            });\n            \n            // Validate webhook structure\n            assert!(webhook_data[\"update_id\"].is_number());\n            assert!(webhook_data[\"message\"][\"message_id\"].is_number());\n            assert!(webhook_data[\"message\"][\"text\"].is_string());\n            assert_eq!(webhook_data[\"message\"][\"text\"], \"/start\");\n        }\n\n        #[test]\n        fn test_command_extraction() {\n            let command_text = \"/start\";\n            assert!(command_text.starts_with('/'));\n            \n            let command = \u0026command_text[1..]; // Remove '/' prefix\n            assert_eq!(command, \"start\");\n        }\n\n        #[test]\n        fn test_chat_id_extraction() {\n            let webhook_data = json!({\n                \"message\": {\n                    \"chat\": {\n                        \"id\": -123456789\n                    }\n                }\n            });\n            \n            if let Some(chat_id) = webhook_data[\"message\"][\"chat\"][\"id\"].as_i64() {\n                assert_eq!(chat_id, -123456789);\n            }\n        }\n    }\n\n    mod utility_functions {\n        use super::*;\n\n        #[test]\n        fn test_service_configuration_access() {\n            let config = create_test_config();\n            let original_token = config.bot_token.clone();\n            let service = TelegramService::new(config);\n            \n            // Service should store configuration\n            // (In real implementation, there would be a getter method)\n        }\n\n        #[test]\n        fn test_exchange_name_formatting() {\n            let binance = ExchangeIdEnum::Binance;\n            let bybit = ExchangeIdEnum::Bybit;\n            \n            // Test that exchange enums can be formatted\n            let binance_str = format!(\"{:?}\", binance);\n            let bybit_str = format!(\"{:?}\", bybit);\n            \n            assert_eq!(binance_str, \"Binance\");\n            assert_eq!(bybit_str, \"Bybit\");\n        }\n\n        #[test]\n        fn test_rate_difference_formatting() {\n            let rate_diff = 0.002f64; // 0.2%\n            \n            // Test percentage formatting\n            let percentage = rate_diff * 100.0;\n            assert!((percentage - 0.2).abs() \u003c 1e-10);\n            \n            // Test basis points formatting\n            let basis_points = rate_diff * 10000.0;\n            assert!((basis_points - 20.0).abs() \u003c 1e-10);\n        }\n\n        #[test]\n        fn test_timestamp_conversion() {\n            let timestamp = 1640995200000u64; // Jan 1, 2022\n            \n            // Should be convertible to datetime\n            let datetime = chrono::DateTime::from_timestamp_millis(timestamp as i64);\n            assert!(datetime.is_some());\n            \n            if let Some(dt) = datetime {\n                assert_eq!(dt.year(), 2022);\n                assert_eq!(dt.month(), 1);\n                assert_eq!(dt.day(), 1);\n            }\n        }\n    }\n\n    mod integration_scenarios {\n        use super::*;\n\n        #[test]\n        fn test_complete_notification_workflow() {\n            let config = create_test_config();\n            let service = TelegramService::new(config);\n            let opportunity = create_test_opportunity();\n            \n            // Verify all components needed for notification are present\n            assert!(!opportunity.id.is_empty());\n            assert!(!opportunity.pair.is_empty());\n            assert!(opportunity.rate_difference \u003e 0.0);\n            assert!(opportunity.long_exchange.is_some());\n            assert!(opportunity.short_exchange.is_some());\n        }\n\n        #[test]\n        fn test_multiple_opportunities_handling() {\n            let config = create_test_config();\n            let service = TelegramService::new(config);\n            \n            // Create multiple opportunities\n            let mut opp1 = create_test_opportunity();\n            opp1.id = \"opp_001\".to_string();\n            opp1.pair = \"BTCUSDT\".to_string();\n            \n            let mut opp2 = create_test_opportunity();\n            opp2.id = \"opp_002\".to_string();\n            opp2.pair = \"ETHUSDT\".to_string();\n            \n            // Should handle multiple opportunities\n            assert_ne!(opp1.id, opp2.id);\n            assert_ne!(opp1.pair, opp2.pair);\n        }\n\n        #[test]\n        fn test_service_state_consistency() {\n            let config = create_test_config();\n            let service = TelegramService::new(config.clone());\n            \n            // Service should maintain consistent state\n            assert_eq!(std::mem::size_of_val(\u0026service), std::mem::size_of::\u003cTelegramService\u003e());\n        }\n    }\n} ","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":12}},{"line":25,"address":[],"length":0,"stats":{"Line":12}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":73},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","services","user_profile.rs"],"content":"// src/services/user_profile.rs\n\nuse crate::types::{UserProfile, UserApiKey, InvitationCode, UserSession, ExchangeIdEnum, ApiKeyProvider};\nuse crate::utils::{ArbitrageError, ArbitrageResult};\nuse worker::kv::KvStore;\nuse std::collections::HashMap;\n\npub struct UserProfileService {\n    kv_store: KvStore,\n    encryption_key: String, // For encrypting API keys\n}\n\nimpl UserProfileService {\n    pub fn new(kv_store: KvStore, encryption_key: String) -\u003e Self {\n        Self {\n            kv_store,\n            encryption_key,\n        }\n    }\n\n    // User Profile CRUD Operations\n    pub async fn create_user_profile(\n        \u0026self,\n        telegram_user_id: i64,\n        invitation_code: Option\u003cString\u003e,\n        telegram_username: Option\u003cString\u003e,\n    ) -\u003e ArbitrageResult\u003cUserProfile\u003e {\n        // Check if user already exists\n        if let Some(_existing) = self.get_user_by_telegram_id(telegram_user_id).await? {\n            return Err(ArbitrageError::validation_error(\n                \"User profile already exists for this Telegram ID\"\n            ));\n        }\n\n        // Validate invitation code if provided\n        if let Some(ref code) = invitation_code {\n            self.validate_and_use_invitation_code(code).await?;\n        }\n\n        let mut profile = UserProfile::new(telegram_user_id, invitation_code);\n        profile.telegram_username = telegram_username;\n\n        // Store profile\n        self.store_user_profile(\u0026profile).await?;\n\n        // Create user session\n        let session = UserSession::new(profile.user_id.clone(), telegram_user_id);\n        self.store_user_session(\u0026session).await?;\n\n        Ok(profile)\n    }\n\n    pub async fn get_user_profile(\u0026self, user_id: \u0026str) -\u003e ArbitrageResult\u003cOption\u003cUserProfile\u003e\u003e {\n        let key = format!(\"user_profile:{}\", user_id);\n\n        match self.kv_store.get(\u0026key).text().await {\n            Ok(Some(value)) =\u003e {\n                let profile: UserProfile = serde_json::from_str(\u0026value).map_err(|e| {\n                    ArbitrageError::parse_error(format!(\"Failed to deserialize user profile: {}\", e))\n                })?;\n                Ok(Some(profile))\n            }\n            Ok(None) =\u003e Ok(None),\n            Err(e) =\u003e Err(ArbitrageError::database_error(format!(\n                \"Failed to get user profile: {}\",\n                e\n            ))),\n        }\n    }\n\n    pub async fn get_user_by_telegram_id(\u0026self, telegram_user_id: i64) -\u003e ArbitrageResult\u003cOption\u003cUserProfile\u003e\u003e {\n        let key = format!(\"telegram_user:{}\", telegram_user_id);\n\n        match self.kv_store.get(\u0026key).text().await {\n            Ok(Some(user_id)) =\u003e {\n                self.get_user_profile(\u0026user_id).await\n            }\n            Ok(None) =\u003e Ok(None),\n            Err(e) =\u003e Err(ArbitrageError::database_error(format!(\n                \"Failed to get user by Telegram ID: {}\",\n                e\n            ))),\n        }\n    }\n\n    pub async fn update_user_profile(\u0026self, profile: \u0026UserProfile) -\u003e ArbitrageResult\u003c()\u003e {\n        let mut updated_profile = profile.clone();\n        updated_profile.updated_at = chrono::Utc::now().timestamp_millis() as u64;\n\n        self.store_user_profile(\u0026updated_profile).await\n    }\n\n    pub async fn update_user_last_active(\u0026self, user_id: \u0026str) -\u003e ArbitrageResult\u003c()\u003e {\n        if let Some(mut profile) = self.get_user_profile(user_id).await? {\n            profile.update_last_active();\n            self.update_user_profile(\u0026profile).await?;\n        }\n        Ok(())\n    }\n\n    // API Key Management\n    pub async fn add_user_api_key(\n        \u0026self,\n        user_id: \u0026str,\n        exchange: ExchangeIdEnum,\n        api_key: \u0026str,\n        secret: \u0026str,\n        permissions: Vec\u003cString\u003e,\n    ) -\u003e ArbitrageResult\u003c()\u003e {\n        let mut profile = self.get_user_profile(user_id).await?\n            .ok_or_else(|| ArbitrageError::not_found(\"User profile not found\"))?;\n\n        let api_key_encrypted = self.encrypt_string(api_key)?;\n        let secret_encrypted = self.encrypt_string(secret)?;\n\n        let user_api_key = UserApiKey::new_exchange_key(\n            user_id.to_string(),\n            exchange,\n            api_key_encrypted,\n            secret_encrypted,\n            permissions,\n        );\n\n        profile.add_api_key(user_api_key);\n        self.update_user_profile(\u0026profile).await?;\n\n        Ok(())\n    }\n\n    pub async fn remove_user_api_key(\n        \u0026self,\n        user_id: \u0026str,\n        exchange: \u0026ExchangeIdEnum,\n    ) -\u003e ArbitrageResult\u003cbool\u003e {\n        let mut profile = self.get_user_profile(user_id).await?\n            .ok_or_else(|| ArbitrageError::not_found(\"User profile not found\"))?;\n\n        let removed = profile.remove_api_key(exchange);\n        if removed {\n            self.update_user_profile(\u0026profile).await?;\n        }\n\n        Ok(removed)\n    }\n\n    pub async fn get_user_api_keys(\u0026self, user_id: \u0026str) -\u003e ArbitrageResult\u003cVec\u003cUserApiKey\u003e\u003e {\n        let profile = self.get_user_profile(user_id).await?\n            .ok_or_else(|| ArbitrageError::not_found(\"User profile not found\"))?;\n\n        Ok(profile.api_keys.clone())\n    }\n\n    pub async fn decrypt_user_api_key(\n        \u0026self,\n        encrypted_key: \u0026str,\n        encrypted_secret: \u0026str,\n    ) -\u003e ArbitrageResult\u003c(String, String)\u003e {\n        let api_key = self.decrypt_string(encrypted_key)?;\n        let secret = self.decrypt_string(encrypted_secret)?;\n        Ok((api_key, secret))\n    }\n\n    // Session Management\n    pub async fn store_user_session(\u0026self, session: \u0026UserSession) -\u003e ArbitrageResult\u003c()\u003e {\n        let key = format!(\"user_session:{}\", session.telegram_chat_id);\n        let value = serde_json::to_string(session).map_err(|e| {\n            ArbitrageError::parse_error(format!(\"Failed to serialize user session: {}\", e))\n        })?;\n\n        self.kv_store\n            .put(\u0026key, value)\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to store user session: {}\", e))\n            })?\n            .execute()\n            .await\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to execute session put: {}\", e))\n            })?;\n\n        Ok(())\n    }\n\n    pub async fn get_user_session(\u0026self, telegram_chat_id: i64) -\u003e ArbitrageResult\u003cOption\u003cUserSession\u003e\u003e {\n        let key = format!(\"user_session:{}\", telegram_chat_id);\n\n        match self.kv_store.get(\u0026key).text().await {\n            Ok(Some(value)) =\u003e {\n                let session: UserSession = serde_json::from_str(\u0026value).map_err(|e| {\n                    ArbitrageError::parse_error(format!(\"Failed to deserialize user session: {}\", e))\n                })?;\n\n                // Check if session is expired\n                if session.is_expired() {\n                    self.delete_user_session(telegram_chat_id).await?;\n                    Ok(None)\n                } else {\n                    Ok(Some(session))\n                }\n            }\n            Ok(None) =\u003e Ok(None),\n            Err(e) =\u003e Err(ArbitrageError::database_error(format!(\n                \"Failed to get user session: {}\",\n                e\n            ))),\n        }\n    }\n\n    pub async fn update_user_session(\u0026self, session: \u0026UserSession) -\u003e ArbitrageResult\u003c()\u003e {\n        self.store_user_session(session).await\n    }\n\n    pub async fn delete_user_session(\u0026self, telegram_chat_id: i64) -\u003e ArbitrageResult\u003c()\u003e {\n        let key = format!(\"user_session:{}\", telegram_chat_id);\n\n        self.kv_store\n            .delete(\u0026key)\n            .await\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to delete user session: {}\", e))\n            })?;\n\n        Ok(())\n    }\n\n    // Invitation Code Management\n    pub async fn create_invitation_code(\n        \u0026self,\n        purpose: String,\n        max_uses: Option\u003cu32\u003e,\n        expires_in_days: Option\u003cu32\u003e,\n        created_by: Option\u003cString\u003e,\n    ) -\u003e ArbitrageResult\u003cInvitationCode\u003e {\n        let mut invitation = InvitationCode::new(purpose, max_uses, expires_in_days);\n        invitation.created_by = created_by;\n\n        self.store_invitation_code(\u0026invitation).await?;\n\n        Ok(invitation)\n    }\n\n    pub async fn validate_and_use_invitation_code(\u0026self, code: \u0026str) -\u003e ArbitrageResult\u003c()\u003e {\n        let mut invitation = self.get_invitation_code(code).await?\n            .ok_or_else(|| ArbitrageError::not_found(\"Invitation code not found\"))?;\n\n        if !invitation.can_be_used() {\n            return Err(ArbitrageError::validation_error(\n                \"Invitation code is expired or has reached maximum uses\"\n            ));\n        }\n\n        invitation.use_code();\n        self.store_invitation_code(\u0026invitation).await?;\n\n        Ok(())\n    }\n\n    pub async fn get_invitation_code(\u0026self, code: \u0026str) -\u003e ArbitrageResult\u003cOption\u003cInvitationCode\u003e\u003e {\n        let key = format!(\"invitation_code:{}\", code);\n\n        match self.kv_store.get(\u0026key).text().await {\n            Ok(Some(value)) =\u003e {\n                let invitation: InvitationCode = serde_json::from_str(\u0026value).map_err(|e| {\n                    ArbitrageError::parse_error(format!(\"Failed to deserialize invitation code: {}\", e))\n                })?;\n                Ok(Some(invitation))\n            }\n            Ok(None) =\u003e Ok(None),\n            Err(e) =\u003e Err(ArbitrageError::database_error(format!(\n                \"Failed to get invitation code: {}\",\n                e\n            ))),\n        }\n    }\n\n    // Helper methods\n    async fn store_user_profile(\u0026self, profile: \u0026UserProfile) -\u003e ArbitrageResult\u003c()\u003e {\n        let user_key = format!(\"user_profile:{}\", profile.user_id);\n        let telegram_key = format!(\"telegram_user:{}\", profile.telegram_user_id);\n\n        let profile_value = serde_json::to_string(profile).map_err(|e| {\n            ArbitrageError::parse_error(format!(\"Failed to serialize user profile: {}\", e))\n        })?;\n\n        // Store profile by user ID\n        self.kv_store\n            .put(\u0026user_key, \u0026profile_value)\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to store user profile: {}\", e))\n            })?\n            .execute()\n            .await\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to execute profile put: {}\", e))\n            })?;\n\n        // Store mapping from Telegram ID to user ID\n        self.kv_store\n            .put(\u0026telegram_key, \u0026profile.user_id)\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to store telegram mapping: {}\", e))\n            })?\n            .execute()\n            .await\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to execute telegram mapping put: {}\", e))\n            })?;\n\n        Ok(())\n    }\n\n    async fn store_invitation_code(\u0026self, invitation: \u0026InvitationCode) -\u003e ArbitrageResult\u003c()\u003e {\n        let key = format!(\"invitation_code:{}\", invitation.code);\n        let value = serde_json::to_string(invitation).map_err(|e| {\n            ArbitrageError::parse_error(format!(\"Failed to serialize invitation code: {}\", e))\n        })?;\n\n        self.kv_store\n            .put(\u0026key, value)\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to store invitation code: {}\", e))\n            })?\n            .execute()\n            .await\n            .map_err(|e| {\n                ArbitrageError::database_error(format!(\"Failed to execute invitation put: {}\", e))\n            })?;\n\n        Ok(())\n    }\n\n    // Simple encryption/decryption (in production, use proper encryption)\n    fn encrypt_string(\u0026self, plaintext: \u0026str) -\u003e ArbitrageResult\u003cString\u003e {\n        // For MVP, we'll use base64 encoding with a simple XOR cipher\n        // In production, use proper encryption like AES-GCM\n        use base64::{Engine as _, engine::general_purpose};\n        \n        let key_bytes = self.encryption_key.as_bytes();\n        let plaintext_bytes = plaintext.as_bytes();\n        \n        let encrypted: Vec\u003cu8\u003e = plaintext_bytes\n            .iter()\n            .enumerate()\n            .map(|(i, \u0026byte)| byte ^ key_bytes[i % key_bytes.len()])\n            .collect();\n        \n        Ok(general_purpose::STANDARD.encode(encrypted))\n    }\n\n    fn decrypt_string(\u0026self, ciphertext: \u0026str) -\u003e ArbitrageResult\u003cString\u003e {\n        use base64::{Engine as _, engine::general_purpose};\n        \n        let encrypted = general_purpose::STANDARD.decode(ciphertext).map_err(|e| {\n            ArbitrageError::parse_error(format!(\"Failed to decode base64: {}\", e))\n        })?;\n        \n        let key_bytes = self.encryption_key.as_bytes();\n        let decrypted: Vec\u003cu8\u003e = encrypted\n            .iter()\n            .enumerate()\n            .map(|(i, \u0026byte)| byte ^ key_bytes[i % key_bytes.len()])\n            .collect();\n        \n        String::from_utf8(decrypted).map_err(|e| {\n            ArbitrageError::parse_error(format!(\"Failed to convert decrypted bytes to string: {}\", e))\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::{ExchangeIdEnum, SubscriptionTier, ApiKeyProvider};\n\n    // Mock KV storage for testing\n    #[derive(Debug, Clone)]\n    struct MockKvStore {\n        data: std::sync::Arc\u003cstd::sync::Mutex\u003cHashMap\u003cString, String\u003e\u003e\u003e,\n    }\n\n    impl MockKvStore {\n        fn new() -\u003e Self {\n            Self {\n                data: std::sync::Arc::new(std::sync::Mutex::new(HashMap::new())),\n            }\n        }\n\n        async fn get(\u0026self, key: \u0026str) -\u003e Option\u003cString\u003e {\n            let data = self.data.lock().unwrap();\n            data.get(key).cloned()\n        }\n\n        async fn put(\u0026self, key: \u0026str, value: \u0026str) -\u003e Result\u003c(), String\u003e {\n            let mut data = self.data.lock().unwrap();\n            data.insert(key.to_string(), value.to_string());\n            Ok(())\n        }\n\n        async fn delete(\u0026self, key: \u0026str) -\u003e Result\u003c(), String\u003e {\n            let mut data = self.data.lock().unwrap();\n            data.remove(key);\n            Ok(())\n        }\n    }\n\n    fn create_test_service() -\u003e UserProfileService {\n        // Note: In real tests, we'd need proper KV store mocking\n        // For now, this demonstrates the service structure\n        panic!(\"Test service creation requires proper KV store mock implementation\")\n    }\n\n    #[test]\n    fn test_user_profile_creation() {\n        let telegram_user_id = 123456789;\n        let invitation_code = Some(\"ARB-TEST1234\".to_string());\n        \n        let profile = UserProfile::new(telegram_user_id, invitation_code.clone());\n        \n        assert_eq!(profile.telegram_user_id, telegram_user_id);\n        assert_eq!(profile.invitation_code, invitation_code);\n        assert_eq!(profile.subscription.tier, SubscriptionTier::Free);\n        assert!(profile.subscription.is_active);\n        assert!(profile.is_active);\n        assert_eq!(profile.api_keys.len(), 0);\n        assert!(!profile.has_minimum_exchanges());\n        assert!(!profile.can_trade()); // Can't trade without API keys\n    }\n\n    #[test]\n    fn test_user_profile_api_key_management() {\n        let mut profile = UserProfile::new(123456789, None);\n        \n        let api_key = UserApiKey::new_exchange_key(\n            profile.user_id.clone(),\n            ExchangeIdEnum::Binance,\n            \"encrypted_key\".to_string(),\n            \"encrypted_secret\".to_string(),\n            vec![\"read\".to_string(), \"trade\".to_string()],\n        );\n\n        // Add API key\n        profile.add_api_key(api_key);\n        assert_eq!(profile.api_keys.len(), 1);\n        \n        // Check that we can find the Binance key\n        let has_binance = profile.api_keys.iter().any(|key| {\n            if let ApiKeyProvider::Exchange(exchange) = \u0026key.provider {\n                exchange == \u0026ExchangeIdEnum::Binance\n            } else {\n                false\n            }\n        });\n        assert!(has_binance);\n        assert!(!profile.has_minimum_exchanges()); // Still need 2 exchanges\n\n        // Add second API key for different exchange\n        let api_key2 = UserApiKey::new_exchange_key(\n            profile.user_id.clone(),\n            ExchangeIdEnum::Bybit,\n            \"encrypted_key2\".to_string(),\n            \"encrypted_secret2\".to_string(),\n            vec![\"read\".to_string(), \"trade\".to_string()],\n        );\n\n        profile.add_api_key(api_key2);\n        assert_eq!(profile.api_keys.len(), 2);\n        assert!(profile.has_minimum_exchanges());\n        assert!(profile.can_trade());\n\n        // Test that we have both exchanges\n        let exchange_count = profile.api_keys.iter()\n            .filter(|key| key.is_exchange_key())\n            .count();\n        assert_eq!(exchange_count, 2);\n    }\n\n    #[test]\n    fn test_invitation_code_creation() {\n        let purpose = \"beta_testing\".to_string();\n        let invitation = InvitationCode::new(purpose.clone(), Some(10), Some(30));\n        \n        assert!(invitation.code.starts_with(\"ARB-\"));\n        assert_eq!(invitation.purpose, purpose);\n        assert_eq!(invitation.max_uses, Some(10));\n        assert_eq!(invitation.current_uses, 0);\n        assert!(invitation.is_active);\n        assert!(invitation.can_be_used());\n    }\n\n    #[test]\n    fn test_invitation_code_usage() {\n        let mut invitation = InvitationCode::new(\"test\".to_string(), Some(2), None);\n        \n        // First use\n        assert!(invitation.use_code());\n        assert_eq!(invitation.current_uses, 1);\n        assert!(invitation.can_be_used());\n\n        // Second use\n        assert!(invitation.use_code());\n        assert_eq!(invitation.current_uses, 2);\n        assert!(!invitation.can_be_used()); // Max uses reached\n\n        // Third use should fail\n        assert!(!invitation.use_code());\n        assert_eq!(invitation.current_uses, 2);\n    }\n\n    #[test]\n    fn test_user_session_creation() {\n        let user_id = \"test-user-123\".to_string();\n        let telegram_chat_id = 987654321;\n        \n        let session = UserSession::new(user_id.clone(), telegram_chat_id);\n        \n        assert_eq!(session.user_id, user_id);\n        assert_eq!(session.telegram_chat_id, telegram_chat_id);\n        assert!(!session.is_expired());\n        assert_eq!(session.current_state, crate::types::SessionState::Idle);\n    }\n\n    #[test]\n    fn test_encryption_decryption() {\n        // Create a minimal service just for testing encryption\n        let encryption_key = \"test_encryption_key_123\".to_string();\n        \n        // Test the encryption/decryption methods directly\n        let plaintext = \"sensitive_api_key_123\";\n        \n        // Create a temporary service for testing\n        let temp_service = UserProfileService {\n            kv_store: unsafe { std::mem::zeroed() }, // Not used in this test\n            encryption_key,\n        };\n        \n        let encrypted = temp_service.encrypt_string(plaintext).unwrap();\n        let decrypted = temp_service.decrypt_string(\u0026encrypted).unwrap();\n        \n        assert_eq!(plaintext, decrypted);\n        assert_ne!(plaintext, encrypted); // Should be different when encrypted\n        \n        // Forget the temp_service to avoid drop issues\n        std::mem::forget(temp_service);\n    }\n} ","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":1}},{"line":338,"address":[],"length":0,"stats":{"Line":1}},{"line":339,"address":[],"length":0,"stats":{"Line":1}},{"line":341,"address":[],"length":0,"stats":{"Line":1}},{"line":344,"address":[],"length":0,"stats":{"Line":23}},{"line":347,"address":[],"length":0,"stats":{"Line":1}},{"line":350,"address":[],"length":0,"stats":{"Line":1}},{"line":353,"address":[],"length":0,"stats":{"Line":2}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":21}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}}],"covered":9,"coverable":175},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","types.rs"],"content":"// src/types.rs\n\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::time::{SystemTime, UNIX_EPOCH};\nuse thiserror::Error;\n\n/// Exchange identifiers\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\n#[allow(clippy::upper_case_acronyms)]\npub enum ExchangeIdEnum {\n    Binance,\n    Bybit,\n    OKX,\n    Bitget,\n    // Add other exchanges as needed\n}\n\nimpl ExchangeIdEnum {\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            ExchangeIdEnum::Binance =\u003e \"binance\",\n            ExchangeIdEnum::Bybit =\u003e \"bybit\",\n            ExchangeIdEnum::OKX =\u003e \"okx\",\n            ExchangeIdEnum::Bitget =\u003e \"bitget\",\n        }\n    }\n}\n\nimpl std::fmt::Display for ExchangeIdEnum {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }\n}\n\n// AI Provider enum for different AI services\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum ApiKeyProvider {\n    OpenAI,\n    Anthropic,\n    Custom,\n    Exchange(ExchangeIdEnum), // For exchange API keys\n}\n\nimpl std::fmt::Display for ApiKeyProvider {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            ApiKeyProvider::OpenAI =\u003e write!(f, \"openai\"),\n            ApiKeyProvider::Anthropic =\u003e write!(f, \"anthropic\"),\n            ApiKeyProvider::Custom =\u003e write!(f, \"custom\"),\n            ApiKeyProvider::Exchange(exchange) =\u003e write!(f, \"exchange_{}\", exchange),\n        }\n    }\n}\n\n// String alias for exchange identifiers (for compatibility with CCXT-like interface)\npub type ExchangeId = String;\npub type TradingPairSymbol = String;\n\n/// Types of arbitrage opportunities\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub enum ArbitrageType {\n    FundingRate,\n    SpotFutures,\n    CrossExchange,\n}\n\n/// Core arbitrage opportunity structure\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ArbitrageOpportunity {\n    pub id: String,\n    pub pair: String,\n    pub long_exchange: Option\u003cExchangeIdEnum\u003e,\n    pub short_exchange: Option\u003cExchangeIdEnum\u003e,\n    pub long_rate: Option\u003cf64\u003e,\n    pub short_rate: Option\u003cf64\u003e,\n    pub rate_difference: f64,\n    pub net_rate_difference: Option\u003cf64\u003e,\n    pub potential_profit_value: Option\u003cf64\u003e,\n    pub timestamp: u64, // Unix timestamp in milliseconds\n    pub r#type: ArbitrageType,\n    pub details: Option\u003cString\u003e,\n}\n\nimpl ArbitrageOpportunity {\n    pub fn new(\n        pair: String,\n        long_exchange: Option\u003cExchangeIdEnum\u003e,\n        short_exchange: Option\u003cExchangeIdEnum\u003e,\n        long_rate: Option\u003cf64\u003e,\n        short_rate: Option\u003cf64\u003e,\n        rate_difference: f64,\n        r#type: ArbitrageType,\n    ) -\u003e Self {\n        Self {\n            id: String::new(),\n            pair,\n            long_exchange,\n            short_exchange,\n            long_rate,\n            short_rate,\n            rate_difference,\n            net_rate_difference: None,\n            potential_profit_value: None,\n            timestamp: SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .unwrap()\n                .as_millis() as u64,\n            r#type,\n            details: None,\n        }\n    }\n\n    pub fn with_net_difference(mut self, net_rate_difference: f64) -\u003e Self {\n        self.net_rate_difference = Some(net_rate_difference);\n        self\n    }\n\n    pub fn with_potential_profit(mut self, potential_profit_value: f64) -\u003e Self {\n        self.potential_profit_value = Some(potential_profit_value);\n        self\n    }\n\n    pub fn with_details(mut self, details: String) -\u003e Self {\n        self.details = Some(details);\n        self\n    }\n}\n\n/// Exchange rate data\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ExchangeRate {\n    pub exchange: ExchangeIdEnum,\n    pub pair: String,\n    pub rate: f64,\n    pub timestamp: u64,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum PositionSide {\n    Long,\n    Short,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum PositionStatus {\n    Open,\n    Closed,\n    Pending,\n}\n\n/// Position data for tracking open positions\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ArbitragePosition {\n    pub id: String,\n    pub exchange: ExchangeIdEnum,\n    pub pair: String,\n    pub side: PositionSide,\n    pub size: f64,\n    pub entry_price: f64,\n    pub current_price: Option\u003cf64\u003e,\n    pub pnl: Option\u003cf64\u003e,\n    pub status: PositionStatus,\n    pub created_at: u64,\n    pub updated_at: u64,\n}\n\n/// Configuration for the application\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AppConfig {\n    pub environment: String,\n    pub usdt_amount: f64,\n    pub bybit_leverage: u32,\n    pub binance_leverage: u32,\n    pub log_level: String,\n}\n\nimpl Default for AppConfig {\n    fn default() -\u003e Self {\n        Self {\n            environment: \"development\".to_string(),\n            usdt_amount: 10.0,\n            bybit_leverage: 20,\n            binance_leverage: 20,\n            log_level: \"info\".to_string(),\n        }\n    }\n}\n\n// Exchange trading types (CCXT-like interface)\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum OrderType {\n    Market,\n    Limit,\n    StopMarket,\n    StopLimit,\n    TrailingStop,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum OrderSide {\n    Buy,\n    Sell,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum OrderStatus {\n    Open,\n    Closed,\n    Canceled,\n    Expired,\n    Rejected,\n    Pending,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Market {\n    pub id: String,\n    pub symbol: String,\n    pub base: String,\n    pub quote: String,\n    pub active: bool,\n    pub precision: Precision,\n    pub limits: Limits,\n    pub fees: Option\u003cTradingFee\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Precision {\n    pub amount: Option\u003ci32\u003e,\n    pub price: Option\u003ci32\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Limits {\n    pub amount: MinMax,\n    pub price: MinMax,\n    pub cost: MinMax,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MinMax {\n    pub min: Option\u003cf64\u003e,\n    pub max: Option\u003cf64\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Ticker {\n    pub symbol: String,\n    pub bid: Option\u003cf64\u003e,\n    pub ask: Option\u003cf64\u003e,\n    pub last: Option\u003cf64\u003e,\n    pub high: Option\u003cf64\u003e,\n    pub low: Option\u003cf64\u003e,\n    pub volume: Option\u003cf64\u003e,\n    pub timestamp: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    pub datetime: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OrderBook {\n    pub symbol: String,\n    pub bids: Vec\u003c[f64; 2]\u003e, // [price, amount]\n    pub asks: Vec\u003c[f64; 2]\u003e, // [price, amount]\n    pub timestamp: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    pub datetime: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Balance {\n    pub free: f64,\n    pub used: f64,\n    pub total: f64,\n}\n\npub type Balances = HashMap\u003cString, Balance\u003e;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Order {\n    pub id: String,\n    pub client_order_id: Option\u003cString\u003e,\n    pub symbol: String,\n    pub r#type: OrderType,\n    pub side: OrderSide,\n    pub amount: f64,\n    pub price: Option\u003cf64\u003e,\n    pub cost: Option\u003cf64\u003e,\n    pub filled: f64,\n    pub remaining: f64,\n    pub status: OrderStatus,\n    pub timestamp: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    pub datetime: Option\u003cString\u003e,\n    pub fee: Option\u003cFee\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Position {\n    pub id: Option\u003cString\u003e,\n    pub symbol: String,\n    pub side: PositionSide,\n    pub size: f64,\n    pub notional: f64,\n    pub entry_price: f64,\n    pub mark_price: Option\u003cf64\u003e,\n    pub unrealized_pnl: f64,\n    pub realized_pnl: f64,\n    pub leverage: f64,\n    pub margin: f64,\n    pub timestamp: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    pub datetime: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Fee {\n    pub currency: String,\n    pub cost: f64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TradingFee {\n    pub maker: f64,\n    pub taker: f64,\n    pub percentage: bool,\n}\n\npub type TradingFeeInterface = TradingFee;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FundingRateInfo {\n    pub symbol: String,\n    pub funding_rate: f64,\n    pub timestamp: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    pub datetime: Option\u003cString\u003e,\n    pub next_funding_time: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    pub estimated_rate: Option\u003cf64\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ExchangeCredentials {\n    pub api_key: String,\n    pub secret: String,\n    pub default_leverage: i32,\n    pub exchange_type: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct StructuredTradingPair {\n    pub symbol: String,\n    pub base: String,\n    pub quote: String,\n    pub exchange_id: String,\n}\n\n// Environment and configuration types\npub struct LoggerInterface {\n    // Implementation will be in logger.rs\n}\n\npub struct Env {\n    // Worker environment interface containing the full environment\n    pub worker_env: worker::Env,\n}\n\nimpl Env {\n    pub fn new(worker_env: worker::Env) -\u003e Self {\n        Self { worker_env }\n    }\n    \n    pub fn get_kv_store(\u0026self, binding_name: \u0026str) -\u003e Option\u003cworker::kv::KvStore\u003e {\n        self.worker_env.kv(binding_name).ok()\n    }\n}\n\n// Error types\n#[derive(Debug, thiserror::Error)]\npub enum ExchangeError {\n    #[error(\"Network error: {0}\")]\n    Network(String),\n    #[error(\"API error: {0}\")]\n    Api(String),\n    #[error(\"Authentication error: {0}\")]\n    Auth(String),\n    #[error(\"Order not found: {0}\")]\n    OrderNotFound(String),\n    #[error(\"Invalid symbol: {0}\")]\n    InvalidSymbol(String),\n    #[error(\"Insufficient funds\")]\n    InsufficientFunds,\n    #[error(\"Rate limit exceeded\")]\n    RateLimit,\n    #[error(\"Exchange not supported: {0}\")]\n    ExchangeNotSupported(String),\n    #[error(\"Serialization error: {0}\")]\n    Serialization(#[from] serde_json::Error),\n    #[error(\"HTTP error: {0}\")]\n    Http(#[from] reqwest::Error),\n}\n\npub type ExchangeResult\u003cT\u003e = Result\u003cT, ExchangeError\u003e;\n\n// User Profile and Subscription System\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum SubscriptionTier {\n    Free,\n    Basic,\n    Premium,\n    Enterprise,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct SubscriptionInfo {\n    pub tier: SubscriptionTier,\n    pub is_active: bool,\n    pub expires_at: Option\u003cu64\u003e, // Unix timestamp in milliseconds\n    pub created_at: u64,\n    pub features: Vec\u003cString\u003e, // List of enabled features\n}\n\nimpl Default for SubscriptionInfo {\n    fn default() -\u003e Self {\n        Self {\n            tier: SubscriptionTier::Free,\n            is_active: true,\n            expires_at: None, // Free tier doesn't expire\n            created_at: chrono::Utc::now().timestamp_millis() as u64,\n            features: vec![\"basic_arbitrage\".to_string(), \"manual_trading\".to_string()],\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct UserConfiguration {\n    pub max_leverage: u32,\n    pub max_entry_size_usdt: f64,\n    pub min_entry_size_usdt: f64,\n    pub risk_tolerance_percentage: f64, // 0.0 to 1.0\n    pub opportunity_threshold: f64, // Minimum rate difference to consider\n    pub auto_trading_enabled: bool,\n    pub notification_preferences: NotificationPreferences,\n    pub trading_pairs: Vec\u003cString\u003e, // Monitored trading pairs\n    pub excluded_pairs: Vec\u003cString\u003e, // Excluded trading pairs\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NotificationPreferences {\n    pub push_opportunities: bool,\n    pub push_executions: bool,\n    pub push_risk_alerts: bool,\n    pub push_system_status: bool,\n    pub min_profit_threshold_usdt: f64, // Only notify if potential profit \u003e this\n    pub max_notifications_per_hour: u32,\n}\n\nimpl Default for UserConfiguration {\n    fn default() -\u003e Self {\n        Self {\n            max_leverage: 10,\n            max_entry_size_usdt: 1000.0,\n            min_entry_size_usdt: 50.0,\n            risk_tolerance_percentage: 0.02, // 2%\n            opportunity_threshold: 0.001, // 0.1%\n            auto_trading_enabled: false,\n            notification_preferences: NotificationPreferences::default(),\n            trading_pairs: vec![\"BTCUSDT\".to_string(), \"ETHUSDT\".to_string()],\n            excluded_pairs: vec![],\n        }\n    }\n}\n\nimpl Default for NotificationPreferences {\n    fn default() -\u003e Self {\n        Self {\n            push_opportunities: true,\n            push_executions: true,\n            push_risk_alerts: true,\n            push_system_status: false,\n            min_profit_threshold_usdt: 1.0,\n            max_notifications_per_hour: 10,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct UserApiKey {\n    pub id: String, // Unique identifier for this API key\n    pub user_id: String, // User who owns this key\n    pub provider: ApiKeyProvider, // Which service this key is for\n    pub encrypted_key: String, // Encrypted API key\n    pub encrypted_secret: Option\u003cString\u003e, // Optional secret (for exchanges)\n    pub metadata: serde_json::Value, // Additional configuration (models, base_urls, etc.)\n    pub is_active: bool,\n    pub created_at: u64,\n    pub last_used: Option\u003cu64\u003e,\n    pub permissions: Vec\u003cString\u003e, // e.g., [\"read\", \"trade\", \"futures\"] for exchanges, [\"chat\", \"analysis\"] for AI\n}\n\nimpl UserApiKey {\n    pub fn new_exchange_key(\n        user_id: String,\n        exchange: ExchangeIdEnum,\n        encrypted_api_key: String,\n        encrypted_secret: String,\n        permissions: Vec\u003cString\u003e,\n    ) -\u003e Self {\n        Self {\n            id: uuid::Uuid::new_v4().to_string(),\n            user_id,\n            provider: ApiKeyProvider::Exchange(exchange),\n            encrypted_key: encrypted_api_key,\n            encrypted_secret: Some(encrypted_secret),\n            metadata: serde_json::json!({}),\n            is_active: true,\n            created_at: chrono::Utc::now().timestamp_millis() as u64,\n            last_used: None,\n            permissions,\n        }\n    }\n\n    pub fn new_ai_key(\n        user_id: String,\n        provider: ApiKeyProvider,\n        encrypted_api_key: String,\n        metadata: serde_json::Value,\n    ) -\u003e Self {\n        Self {\n            id: uuid::Uuid::new_v4().to_string(),\n            user_id,\n            provider,\n            encrypted_key: encrypted_api_key,\n            encrypted_secret: None,\n            metadata,\n            is_active: true,\n            created_at: chrono::Utc::now().timestamp_millis() as u64,\n            last_used: None,\n            permissions: vec![\"analysis\".to_string(), \"chat\".to_string()],\n        }\n    }\n\n    pub fn is_exchange_key(\u0026self) -\u003e bool {\n        matches!(self.provider, ApiKeyProvider::Exchange(_))\n    }\n\n    pub fn is_ai_key(\u0026self) -\u003e bool {\n        matches!(self.provider, ApiKeyProvider::OpenAI | ApiKeyProvider::Anthropic | ApiKeyProvider::Custom)\n    }\n\n    pub fn update_last_used(\u0026mut self) {\n        self.last_used = Some(chrono::Utc::now().timestamp_millis() as u64);\n    }\n}\n\n// Keep the old structure for backward compatibility during migration\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct LegacyUserApiKey {\n    pub exchange: ExchangeIdEnum,\n    pub api_key_encrypted: String, // Encrypted with user-specific key\n    pub secret_encrypted: String, // Encrypted with user-specific key\n    pub is_active: bool,\n    pub created_at: u64,\n    pub last_validated: Option\u003cu64\u003e,\n    pub permissions: Vec\u003cString\u003e, // e.g., [\"read\", \"trade\", \"futures\"]\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct UserProfile {\n    pub user_id: String, // Primary identifier\n    pub telegram_user_id: i64,\n    pub telegram_username: Option\u003cString\u003e,\n    pub subscription: SubscriptionInfo,\n    pub configuration: UserConfiguration,\n    pub api_keys: Vec\u003cUserApiKey\u003e,\n    pub invitation_code: Option\u003cString\u003e, // Code used to join\n    pub created_at: u64,\n    pub updated_at: u64,\n    pub last_active: u64,\n    pub is_active: bool,\n    pub total_trades: u32,\n    pub total_pnl_usdt: f64,\n}\n\nimpl UserProfile {\n    pub fn new(telegram_user_id: i64, invitation_code: Option\u003cString\u003e) -\u003e Self {\n        let now = chrono::Utc::now().timestamp_millis() as u64;\n        let user_id = uuid::Uuid::new_v4().to_string();\n        \n        Self {\n            user_id,\n            telegram_user_id,\n            telegram_username: None,\n            subscription: SubscriptionInfo::default(),\n            configuration: UserConfiguration::default(),\n            api_keys: vec![],\n            invitation_code,\n            created_at: now,\n            updated_at: now,\n            last_active: now,\n            is_active: true,\n            total_trades: 0,\n            total_pnl_usdt: 0.0,\n        }\n    }\n\n    pub fn update_last_active(\u0026mut self) {\n        self.last_active = chrono::Utc::now().timestamp_millis() as u64;\n        self.updated_at = self.last_active;\n    }\n\n    pub fn add_api_key(\u0026mut self, api_key: UserApiKey) {\n        // Remove existing key for same provider if present\n        self.api_keys.retain(|key| key.provider != api_key.provider);\n        self.api_keys.push(api_key);\n        self.updated_at = chrono::Utc::now().timestamp_millis() as u64;\n    }\n\n    pub fn remove_api_key(\u0026mut self, exchange: \u0026ExchangeIdEnum) -\u003e bool {\n        let initial_len = self.api_keys.len();\n        self.api_keys.retain(|key| {\n            if let ApiKeyProvider::Exchange(key_exchange) = \u0026key.provider {\n                key_exchange != exchange\n            } else {\n                true // Keep non-exchange keys\n            }\n        });\n        if self.api_keys.len() \u003c initial_len {\n            self.updated_at = chrono::Utc::now().timestamp_millis() as u64;\n            true\n        } else {\n            false\n        }\n    }\n\n    pub fn get_active_exchanges(\u0026self) -\u003e Vec\u003cExchangeIdEnum\u003e {\n        self.api_keys\n            .iter()\n            .filter(|key| key.is_active)\n            .filter_map(|key| {\n                if let ApiKeyProvider::Exchange(exchange) = \u0026key.provider {\n                    Some(exchange.clone())\n                } else {\n                    None\n                }\n            })\n            .collect()\n    }\n\n    pub fn has_minimum_exchanges(\u0026self) -\u003e bool {\n        self.get_active_exchanges().len() \u003e= 2\n    }\n\n    pub fn can_trade(\u0026self) -\u003e bool {\n        self.is_active \u0026\u0026 self.subscription.is_active \u0026\u0026 self.has_minimum_exchanges()\n    }\n}\n\n// Invitation System\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct InvitationCode {\n    pub code: String,\n    pub created_by: Option\u003cString\u003e, // User ID who created this code\n    pub created_at: u64,\n    pub expires_at: Option\u003cu64\u003e,\n    pub max_uses: Option\u003cu32\u003e,\n    pub current_uses: u32,\n    pub is_active: bool,\n    pub purpose: String, // e.g., \"beta_testing\", \"referral\", \"admin\"\n}\n\nimpl InvitationCode {\n    pub fn new(purpose: String, max_uses: Option\u003cu32\u003e, expires_in_days: Option\u003cu32\u003e) -\u003e Self {\n        let now = chrono::Utc::now().timestamp_millis() as u64;\n        let code = format!(\"ARB-{}\", uuid::Uuid::new_v4().to_string().replace('-', \"\").to_uppercase()[..8].to_string());\n        \n        let expires_at = expires_in_days.map(|days| {\n            now + (days as u64 * 24 * 60 * 60 * 1000) // Convert days to milliseconds\n        });\n\n        Self {\n            code,\n            created_by: None,\n            created_at: now,\n            expires_at,\n            max_uses,\n            current_uses: 0,\n            is_active: true,\n            purpose,\n        }\n    }\n\n    pub fn can_be_used(\u0026self) -\u003e bool {\n        let now = chrono::Utc::now().timestamp_millis() as u64;\n        \n        self.is_active\n            \u0026\u0026 self.expires_at.map_or(true, |exp| now \u003c exp)\n            \u0026\u0026 self.max_uses.map_or(true, |max| self.current_uses \u003c max)\n    }\n\n    pub fn use_code(\u0026mut self) -\u003e bool {\n        if self.can_be_used() {\n            self.current_uses += 1;\n            true\n        } else {\n            false\n        }\n    }\n}\n\n// Trading Session and State Management\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct UserSession {\n    pub user_id: String,\n    pub telegram_chat_id: i64,\n    pub last_command: Option\u003cString\u003e,\n    pub current_state: SessionState,\n    pub temporary_data: std::collections::HashMap\u003cString, String\u003e,\n    pub created_at: u64,\n    pub expires_at: u64,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum SessionState {\n    Idle,\n    AddingApiKey,\n    ConfiguringLeverage,\n    ConfiguringEntrySize,\n    ConfiguringRisk,\n    ExecutingTrade,\n    ViewingOpportunities,\n}\n\nimpl UserSession {\n    pub fn new(user_id: String, telegram_chat_id: i64) -\u003e Self {\n        let now = chrono::Utc::now().timestamp_millis() as u64;\n        let expires_at = now + (24 * 60 * 60 * 1000); // 24 hours\n\n        Self {\n            user_id,\n            telegram_chat_id,\n            last_command: None,\n            current_state: SessionState::Idle,\n            temporary_data: std::collections::HashMap::new(),\n            created_at: now,\n            expires_at,\n        }\n    }\n\n    pub fn is_expired(\u0026self) -\u003e bool {\n        let now = chrono::Utc::now().timestamp_millis() as u64;\n        now \u003e self.expires_at\n    }\n\n    pub fn extend_session(\u0026mut self) {\n        let now = chrono::Utc::now().timestamp_millis() as u64;\n        self.expires_at = now + (24 * 60 * 60 * 1000); // Extend by 24 hours\n    }\n}\n\n/// Global Opportunity System Types for Task 2\n\n/// Global opportunity with distribution metadata\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GlobalOpportunity {\n    pub opportunity: ArbitrageOpportunity,\n    pub detection_timestamp: u64,\n    pub expiry_timestamp: u64,\n    pub priority_score: f64, // Higher means more urgent/profitable\n    pub distributed_to: Vec\u003cString\u003e, // User IDs who received this opportunity\n    pub max_participants: Option\u003cu32\u003e, // Maximum number of users who can take this opportunity\n    pub current_participants: u32,\n    pub distribution_strategy: DistributionStrategy,\n    pub source: OpportunitySource,\n}\n\n/// How opportunities should be distributed\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum DistributionStrategy {\n    FirstComeFirstServe, // Simple queue-based\n    RoundRobin, // Fair rotation among active users\n    PriorityBased, // Based on user subscription tier and activity\n    Broadcast, // Send to all eligible users\n}\n\n/// Source of the opportunity\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum OpportunitySource {\n    SystemGenerated, // Generated by default strategy\n    UserAI(String), // Generated by user's AI with user_id\n    External, // From external sources\n}\n\n/// Opportunity queue management\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OpportunityQueue {\n    pub id: String,\n    pub opportunities: Vec\u003cGlobalOpportunity\u003e,\n    pub created_at: u64,\n    pub updated_at: u64,\n    pub total_distributed: u32,\n    pub active_users: Vec\u003cString\u003e, // Currently active user IDs\n}\n\n/// Distribution tracking per user\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct UserOpportunityDistribution {\n    pub user_id: String,\n    pub last_opportunity_received: Option\u003cu64\u003e, // timestamp\n    pub total_opportunities_received: u32,\n    pub opportunities_today: u32,\n    pub last_daily_reset: u64, // timestamp for daily reset\n    pub priority_weight: f64, // User's priority in distribution\n    pub is_eligible: bool, // Whether user can receive opportunities\n}\n\n/// Fairness algorithm configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FairnessConfig {\n    pub rotation_interval_minutes: u32, // How often to rotate in round-robin\n    pub max_opportunities_per_user_per_hour: u32,\n    pub max_opportunities_per_user_per_day: u32,\n    pub tier_multipliers: std::collections::HashMap\u003cString, f64\u003e, // Subscription tier multipliers\n    pub activity_boost_factor: f64, // Boost for active users\n    pub cooldown_period_minutes: u32, // Minimum time between opportunities for same user\n}\n\nimpl Default for FairnessConfig {\n    fn default() -\u003e Self {\n        let mut tier_multipliers = std::collections::HashMap::new();\n        tier_multipliers.insert(\"Free\".to_string(), 1.0);\n        tier_multipliers.insert(\"Basic\".to_string(), 1.5);\n        tier_multipliers.insert(\"Premium\".to_string(), 2.0);\n        tier_multipliers.insert(\"Enterprise\".to_string(), 3.0);\n        \n        Self {\n            rotation_interval_minutes: 15,\n            max_opportunities_per_user_per_hour: 10,\n            max_opportunities_per_user_per_day: 50,\n            tier_multipliers,\n            activity_boost_factor: 1.2,\n            cooldown_period_minutes: 5,\n        }\n    }\n}\n\n/// Global opportunity detection configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GlobalOpportunityConfig {\n    pub detection_interval_seconds: u32,\n    pub min_threshold: f64,\n    pub max_threshold: f64,\n    pub max_queue_size: u32,\n    pub opportunity_ttl_minutes: u32, // Time to live for opportunities\n    pub distribution_strategy: DistributionStrategy,\n    pub fairness_config: FairnessConfig,\n    pub monitored_exchanges: Vec\u003cExchangeIdEnum\u003e,\n    pub monitored_pairs: Vec\u003cString\u003e,\n}\n\nimpl Default for GlobalOpportunityConfig {\n    fn default() -\u003e Self {\n        Self {\n            detection_interval_seconds: 30,\n            min_threshold: 0.0005, // 0.05% minimum rate difference\n            max_threshold: 0.02, // 2% maximum rate difference (avoid unrealistic opportunities)\n            max_queue_size: 100,\n            opportunity_ttl_minutes: 10,\n            distribution_strategy: DistributionStrategy::RoundRobin,\n            fairness_config: FairnessConfig::default(),\n            monitored_exchanges: vec![ExchangeIdEnum::Binance, ExchangeIdEnum::Bybit],\n            monitored_pairs: vec![\"BTCUSDT\".to_string(), \"ETHUSDT\".to_string()],\n        }\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":2}},{"line":436,"address":[],"length":0,"stats":{"Line":2}},{"line":437,"address":[],"length":0,"stats":{"Line":2}},{"line":468,"address":[],"length":0,"stats":{"Line":4}},{"line":476,"address":[],"length":0,"stats":{"Line":4}},{"line":477,"address":[],"length":0,"stats":{"Line":4}},{"line":478,"address":[],"length":0,"stats":{"Line":4}},{"line":484,"address":[],"length":0,"stats":{"Line":4}},{"line":512,"address":[],"length":0,"stats":{"Line":3}},{"line":520,"address":[],"length":0,"stats":{"Line":3}},{"line":522,"address":[],"length":0,"stats":{"Line":3}},{"line":524,"address":[],"length":0,"stats":{"Line":3}},{"line":525,"address":[],"length":0,"stats":{"Line":3}},{"line":527,"address":[],"length":0,"stats":{"Line":3}},{"line":533,"address":[],"length":0,"stats":{"Line":1}},{"line":540,"address":[],"length":0,"stats":{"Line":1}},{"line":547,"address":[],"length":0,"stats":{"Line":1}},{"line":549,"address":[],"length":0,"stats":{"Line":1}},{"line":553,"address":[],"length":0,"stats":{"Line":3}},{"line":554,"address":[],"length":0,"stats":{"Line":3}},{"line":557,"address":[],"length":0,"stats":{"Line":1}},{"line":558,"address":[],"length":0,"stats":{"Line":2}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":2}},{"line":599,"address":[],"length":0,"stats":{"Line":2}},{"line":600,"address":[],"length":0,"stats":{"Line":2}},{"line":606,"address":[],"length":0,"stats":{"Line":2}},{"line":607,"address":[],"length":0,"stats":{"Line":2}},{"line":608,"address":[],"length":0,"stats":{"Line":2}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":2}},{"line":626,"address":[],"length":0,"stats":{"Line":5}},{"line":627,"address":[],"length":0,"stats":{"Line":2}},{"line":628,"address":[],"length":0,"stats":{"Line":2}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":5}},{"line":649,"address":[],"length":0,"stats":{"Line":5}},{"line":651,"address":[],"length":0,"stats":{"Line":15}},{"line":652,"address":[],"length":0,"stats":{"Line":10}},{"line":653,"address":[],"length":0,"stats":{"Line":10}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":5}},{"line":663,"address":[],"length":0,"stats":{"Line":5}},{"line":666,"address":[],"length":0,"stats":{"Line":2}},{"line":667,"address":[],"length":0,"stats":{"Line":6}},{"line":686,"address":[],"length":0,"stats":{"Line":2}},{"line":687,"address":[],"length":0,"stats":{"Line":2}},{"line":688,"address":[],"length":0,"stats":{"Line":2}},{"line":690,"address":[],"length":0,"stats":{"Line":3}},{"line":691,"address":[],"length":0,"stats":{"Line":1}},{"line":706,"address":[],"length":0,"stats":{"Line":6}},{"line":707,"address":[],"length":0,"stats":{"Line":6}},{"line":709,"address":[],"length":0,"stats":{"Line":6}},{"line":710,"address":[],"length":0,"stats":{"Line":13}},{"line":711,"address":[],"length":0,"stats":{"Line":18}},{"line":714,"address":[],"length":0,"stats":{"Line":3}},{"line":715,"address":[],"length":0,"stats":{"Line":3}},{"line":716,"address":[],"length":0,"stats":{"Line":2}},{"line":717,"address":[],"length":0,"stats":{"Line":2}},{"line":719,"address":[],"length":0,"stats":{"Line":1}},{"line":750,"address":[],"length":0,"stats":{"Line":1}},{"line":751,"address":[],"length":0,"stats":{"Line":1}},{"line":752,"address":[],"length":0,"stats":{"Line":1}},{"line":759,"address":[],"length":0,"stats":{"Line":1}},{"line":765,"address":[],"length":0,"stats":{"Line":1}},{"line":766,"address":[],"length":0,"stats":{"Line":1}},{"line":767,"address":[],"length":0,"stats":{"Line":1}},{"line":770,"address":[],"length":0,"stats":{"Line":0}},{"line":771,"address":[],"length":0,"stats":{"Line":0}},{"line":772,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":6}},{"line":845,"address":[],"length":0,"stats":{"Line":6}},{"line":846,"address":[],"length":0,"stats":{"Line":6}},{"line":847,"address":[],"length":0,"stats":{"Line":6}},{"line":848,"address":[],"length":0,"stats":{"Line":6}},{"line":849,"address":[],"length":0,"stats":{"Line":6}},{"line":877,"address":[],"length":0,"stats":{"Line":0}},{"line":885,"address":[],"length":0,"stats":{"Line":0}},{"line":886,"address":[],"length":0,"stats":{"Line":0}},{"line":887,"address":[],"length":0,"stats":{"Line":0}}],"covered":69,"coverable":124},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","utils","calculations.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","utils","error.rs"],"content":"// src/utils/error.rs\n\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fmt;\n\npub type ArbitrageResult\u003cT\u003e = Result\u003cT, ArbitrageError\u003e;\n\n/// Custom error details for additional context\npub type ErrorDetails = HashMap\u003cString, serde_json::Value\u003e;\n\n/// Main error type for the arbitrage application\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ArbitrageError {\n    pub message: String,\n    pub details: Option\u003cErrorDetails\u003e,\n    pub status: Option\u003cu16\u003e,\n    pub error_code: Option\u003cString\u003e,\n    pub method: Option\u003cString\u003e,\n    pub kind: ErrorKind,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum ErrorKind {\n    NetworkError,\n    ApiError,\n    ValidationError,\n    NotFound,\n    Authentication,\n    Authorization,\n    RateLimit,\n    ExchangeError,\n    ParseError,\n    ConfigError,\n    DatabaseError,\n    TelegramError,\n    NotImplemented,\n    Serialization,\n    Internal,\n    Storage,\n}\n\nimpl fmt::Display for ArbitrageError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.message)\n    }\n}\n\nimpl std::error::Error for ArbitrageError {}\n\nimpl ArbitrageError {\n    pub fn new(kind: ErrorKind, message: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            message: message.into(),\n            details: None,\n            status: None,\n            error_code: None,\n            method: None,\n            kind,\n        }\n    }\n\n    pub fn with_details(mut self, details: ErrorDetails) -\u003e Self {\n        self.details = Some(details);\n        self\n    }\n\n    pub fn with_status(mut self, status: u16) -\u003e Self {\n        self.status = Some(status);\n        self\n    }\n\n    pub fn with_code(mut self, error_code: impl Into\u003cString\u003e) -\u003e Self {\n        self.error_code = Some(error_code.into());\n        self\n    }\n\n    pub fn with_method(mut self, method: impl Into\u003cString\u003e) -\u003e Self {\n        self.method = Some(method.into());\n        self\n    }\n\n    // Convenience constructors for common error types\n    pub fn network_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::NetworkError, message)\n            .with_status(503)\n            .with_code(\"NETWORK_ERROR\")\n    }\n\n    pub fn api_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::ApiError, message)\n            .with_status(500)\n            .with_code(\"API_ERROR\")\n    }\n\n    pub fn validation_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::ValidationError, message)\n            .with_status(400)\n            .with_code(\"VALIDATION_ERROR\")\n    }\n\n    pub fn not_found(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::NotFound, message)\n            .with_status(404)\n            .with_code(\"NOT_FOUND\")\n    }\n\n    pub fn authentication_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::Authentication, message)\n            .with_status(401)\n            .with_code(\"AUTH_ERROR\")\n    }\n\n    pub fn authorization_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::Authorization, message)\n            .with_status(403)\n            .with_code(\"AUTH_Z_ERROR\")\n    }\n\n    pub fn rate_limit_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::RateLimit, message)\n            .with_status(429)\n            .with_code(\"RATE_LIMIT\")\n    }\n\n    pub fn exchange_error(exchange: \u0026str, message: impl Into\u003cString\u003e) -\u003e Self {\n        let mut details = ErrorDetails::new();\n        details.insert(\n            \"exchange\".to_string(),\n            serde_json::Value::String(exchange.to_string()),\n        );\n\n        Self::new(ErrorKind::ExchangeError, message)\n            .with_details(details)\n            .with_status(502)\n            .with_code(\"EXCHANGE_ERROR\")\n    }\n\n    pub fn parse_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::ParseError, message)\n            .with_status(400)\n            .with_code(\"PARSE_ERROR\")\n    }\n\n    pub fn config_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::ConfigError, message)\n            .with_status(500)\n            .with_code(\"CONFIG_ERROR\")\n    }\n\n    pub fn database_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::DatabaseError, message)\n            .with_status(500)\n            .with_code(\"DATABASE_ERROR\")\n    }\n\n    pub fn telegram_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::TelegramError, message)\n            .with_status(502)\n            .with_code(\"TELEGRAM_ERROR\")\n    }\n\n    pub fn internal_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::Internal, message)\n            .with_status(500)\n            .with_code(\"INTERNAL_ERROR\")\n    }\n\n    pub fn not_implemented(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::NotImplemented, message)\n            .with_status(501)\n            .with_code(\"NOT_IMPLEMENTED\")\n    }\n\n    pub fn serialization_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::Serialization, message)\n            .with_status(400)\n            .with_code(\"SERIALIZATION_ERROR\")\n    }\n\n    pub fn storage_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::Storage, message)\n    }\n}\n\n// Implement From conversions for common error types\nimpl From\u003cserde_json::Error\u003e for ArbitrageError {\n    fn from(err: serde_json::Error) -\u003e Self {\n        ArbitrageError::parse_error(format!(\"JSON parsing error: {}\", err))\n    }\n}\n\nimpl From\u003cworker::Error\u003e for ArbitrageError {\n    fn from(err: worker::Error) -\u003e Self {\n        ArbitrageError::internal_error(format!(\"Worker error: {:?}\", err))\n    }\n}\n\nimpl From\u003cworker::kv::KvError\u003e for ArbitrageError {\n    fn from(err: worker::kv::KvError) -\u003e Self {\n        ArbitrageError::database_error(format!(\"KV store error: {:?}\", err))\n    }\n}\n\n// Helper macro for creating errors with context\n#[macro_export]\nmacro_rules! arbitrage_error {\n    ($kind:expr, $msg:expr) =\u003e {\n        ArbitrageError::new($kind, $msg)\n    };\n    ($kind:expr, $msg:expr, $($key:expr =\u003e $value:expr),+) =\u003e {{\n        let mut details = std::collections::HashMap::new();\n        $(\n            details.insert($key.to_string(), serde_json::json!($value));\n        )+\n        ArbitrageError::new($kind, $msg).with_details(details)\n    }};\n}\n","traces":[{"line":45,"address":[],"length":0,"stats":{"Line":5}},{"line":46,"address":[],"length":0,"stats":{"Line":5}},{"line":53,"address":[],"length":0,"stats":{"Line":6}},{"line":55,"address":[],"length":0,"stats":{"Line":6}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":6}},{"line":70,"address":[],"length":0,"stats":{"Line":6}},{"line":71,"address":[],"length":0,"stats":{"Line":6}},{"line":74,"address":[],"length":0,"stats":{"Line":6}},{"line":75,"address":[],"length":0,"stats":{"Line":6}},{"line":76,"address":[],"length":0,"stats":{"Line":6}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":92,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":147,"address":[],"length":0,"stats":{"Line":2}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}}],"covered":20,"coverable":59},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","utils","formatter.rs"],"content":"// src/utils/formatter.rs\n\nuse crate::types::{ArbitrageOpportunity, ArbitrageType, ExchangeIdEnum};\n#[cfg(not(test))]\nuse chrono::{DateTime, Utc};\n\n/// Escape MarkdownV2 characters for Telegram\n/// See: https://core.telegram.org/bots/api#markdownv2-style\npub fn escape_markdown_v2(text: \u0026str) -\u003e String {\n    // Characters to escape: _ * [ ] ( ) ~ ` \u003e # + - = | { } . !\n    let chars_to_escape = [\n        '_', '*', '[', ']', '(', ')', '~', '`', '\u003e', '#', '+', '-', '=', '|', '{', '}', '.', '!',\n    ];\n\n    text.chars()\n        .map(|c| {\n            if chars_to_escape.contains(\u0026c) {\n                format!(\"\\\\{}\", c)\n            } else {\n                c.to_string()\n            }\n        })\n        .collect()\n}\n\n/// Format an optional value with fallback to \"N/A\"\npub fn format_optional\u003cT: std::fmt::Display\u003e(value: \u0026Option\u003cT\u003e) -\u003e String {\n    match value {\n        Some(v) =\u003e escape_markdown_v2(\u0026v.to_string()),\n        None =\u003e escape_markdown_v2(\"N/A\"),\n    }\n}\n\n/// Format a percentage value\npub fn format_percentage(value: f64) -\u003e String {\n    format!(\"{:.4}\", value * 100.0)\n}\n\n/// Format an optional percentage value\npub fn format_optional_percentage(value: \u0026Option\u003cf64\u003e) -\u003e String {\n    match value {\n        Some(v) =\u003e escape_markdown_v2(\u0026format_percentage(*v)),\n        None =\u003e escape_markdown_v2(\"N/A\"),\n    }\n}\n\n/// Format timestamp to readable string\npub fn format_timestamp(timestamp: u64) -\u003e String {\n    #[cfg(test)]\n    {\n        // In test environment, just return a simple formatted string\n        format!(\"2022-01-01 00:00:00 UTC ({})\", timestamp)\n    }\n    #[cfg(not(test))]\n    {\n        let datetime =\n            DateTime::from_timestamp_millis(timestamp as i64).unwrap_or_else(Utc::now);\n        datetime.format(\"%Y-%m-%d %H:%M:%S UTC\").to_string()\n    }\n}\n\n/// Format exchange name for display\npub fn format_exchange(exchange: \u0026Option\u003cExchangeIdEnum\u003e) -\u003e String {\n    match exchange {\n        Some(exchange) =\u003e exchange.to_string(),\n        None =\u003e \"N/A\".to_string(),\n    }\n}\n\n/// Format monetary value\npub fn format_money(value: \u0026Option\u003cf64\u003e) -\u003e String {\n    match value {\n        Some(v) =\u003e escape_markdown_v2(\u0026format!(\"{:.2}\", v)),\n        None =\u003e escape_markdown_v2(\"N/A\"),\n    }\n}\n\n/// Format an ArbitrageOpportunity into a MarkdownV2 string for Telegram\npub fn format_opportunity_message(opportunity: \u0026ArbitrageOpportunity) -\u003e String {\n    // Extract and format values\n    let pair_escaped = escape_markdown_v2(\u0026opportunity.pair);\n    let long_exchange_escaped = format_exchange(\u0026opportunity.long_exchange);\n    let short_exchange_escaped = format_exchange(\u0026opportunity.short_exchange);\n    let long_rate_escaped = format_optional_percentage(\u0026opportunity.long_rate);\n    let short_rate_escaped = format_optional_percentage(\u0026opportunity.short_rate);\n    let diff_escaped = escape_markdown_v2(\u0026format_percentage(opportunity.rate_difference));\n    let net_diff_escaped = format_optional_percentage(\u0026opportunity.net_rate_difference);\n    let potential_profit_escaped = format_money(\u0026opportunity.potential_profit_value);\n    let date_escaped = escape_markdown_v2(\u0026format_timestamp(opportunity.timestamp));\n    let details_escaped = opportunity\n        .details\n        .as_ref()\n        .map(|d| escape_markdown_v2(d))\n        .unwrap_or_default();\n\n    // Build the message using MarkdownV2 syntax\n    let mut message = format!(\n        \" *Arbitrage Opportunity Detected* \\n\\n *Pair:* `{}`\",\n        pair_escaped\n    );\n\n    // Format based on opportunity type\n    match opportunity.r#type {\n        ArbitrageType::FundingRate\n            if opportunity.long_exchange.is_some() \u0026\u0026 opportunity.short_exchange.is_some() =\u003e\n        {\n            message.push_str(\u0026format!(\n                \"\\n *Action:* LONG `{}` / SHORT `{}`\\n\\n*Rates \\\\(Funding\\\\):*\\n   \\\\- Long \\\\({}\\\\): `{}%`\\n   \\\\- Short \\\\({}\\\\): `{}%`\\n *Gross Difference:* `{}%`\",\n                long_exchange_escaped,\n                short_exchange_escaped,\n                long_exchange_escaped,\n                long_rate_escaped,\n                short_exchange_escaped,\n                short_rate_escaped,\n                diff_escaped\n            ));\n        }\n        _ =\u003e {\n            // Generic message for other types or if specific fields are missing\n            let type_str = match opportunity.r#type {\n                ArbitrageType::FundingRate =\u003e \"Funding Rate\",\n                ArbitrageType::SpotFutures =\u003e \"Spot Futures\",\n                ArbitrageType::CrossExchange =\u003e \"Cross Exchange\",\n            };\n            message.push_str(\u0026format!(\n                \"\\n *Type:* {}\\n *Gross Metric:* `{}%`\",\n                escape_markdown_v2(type_str),\n                diff_escaped\n            ));\n\n            if opportunity.long_exchange.is_some() {\n                message.push_str(\u0026format!(\"\\n *Exchange 1:* `{}`\", long_exchange_escaped));\n            }\n            if opportunity.short_exchange.is_some() {\n                message.push_str(\u0026format!(\"\\n *Exchange 2:* `{}`\", short_exchange_escaped));\n            }\n        }\n    }\n\n    // Add net difference if available\n    if opportunity.net_rate_difference.is_some() \u0026\u0026 net_diff_escaped != escape_markdown_v2(\"N/A\") {\n        message.push_str(\u0026format!(\"\\n *Net Difference:* `{}%`\", net_diff_escaped));\n    }\n\n    // Add potential profit if available\n    if opportunity.potential_profit_value.is_some()\n        \u0026\u0026 potential_profit_escaped != escape_markdown_v2(\"N/A\")\n    {\n        message.push_str(\u0026format!(\n            \"\\n *Potential Profit:* \\\\~${}\",\n            potential_profit_escaped\n        ));\n    }\n\n    // Add details if available\n    if !details_escaped.is_empty() {\n        message.push_str(\u0026format!(\"\\n *Details:* {}\", details_escaped));\n    }\n\n    // Add timestamp\n    message.push_str(\u0026format!(\"\\n *Timestamp:* {}\", date_escaped));\n\n    message\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::{ArbitrageOpportunity, ArbitrageType, ExchangeIdEnum};\n\n    #[test]\n    fn test_escape_markdown_v2() {\n        assert_eq!(escape_markdown_v2(\"test_string\"), \"test\\\\_string\");\n        assert_eq!(escape_markdown_v2(\"test*bold*\"), \"test\\\\*bold\\\\*\");\n        assert_eq!(escape_markdown_v2(\"test-dash\"), \"test\\\\-dash\");\n    }\n\n    #[test]\n    fn test_format_percentage() {\n        assert_eq!(format_percentage(0.1234), \"12.3400\");\n        assert_eq!(format_percentage(0.0001), \"0.0100\");\n    }\n\n    #[test]\n    #[ignore] // Skip this test for now due to WASM binding issues in test environment\n    fn test_format_opportunity_message() {\n        let mut opportunity = ArbitrageOpportunity::new(\n            \"BTC/USDT\".to_string(),\n            Some(ExchangeIdEnum::Binance),\n            Some(ExchangeIdEnum::Bybit),\n            Some(0.0001),\n            Some(-0.0005),\n            0.0006,\n            ArbitrageType::FundingRate,\n        );\n\n        // Set a fixed timestamp to avoid WASM binding issues in tests\n        opportunity.timestamp = 1640995200000; // 2022-01-01 00:00:00 UTC\n\n        let message = format_opportunity_message(\u0026opportunity);\n        assert!(message.contains(\"BTC/USDT\"));\n        assert!(message.contains(\"binance\"));\n        assert!(message.contains(\"bybit\"));\n        assert!(message.contains(\"Funding\"));\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":6}},{"line":11,"address":[],"length":0,"stats":{"Line":6}},{"line":12,"address":[],"length":0,"stats":{"Line":6}},{"line":15,"address":[],"length":0,"stats":{"Line":6}},{"line":16,"address":[],"length":0,"stats":{"Line":93}},{"line":17,"address":[],"length":0,"stats":{"Line":87}},{"line":18,"address":[],"length":0,"stats":{"Line":26}},{"line":20,"address":[],"length":0,"stats":{"Line":61}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}}],"covered":10,"coverable":76},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","utils","helpers.rs"],"content":"use serde_json::Value;\n\n/// Safely parses a value to a floating-point number.\n/// If parsing fails or results in NaN, returns a default value.\npub fn safe_parse_float(value: \u0026Value, default_value: f64) -\u003e f64 {\n    match value {\n        Value::Null =\u003e default_value,\n        Value::Number(n) =\u003e n.as_f64().unwrap_or(default_value),\n        Value::String(s) =\u003e {\n            if s.trim().is_empty() {\n                default_value\n            } else {\n                s.parse::\u003cf64\u003e().unwrap_or(default_value)\n            }\n        }\n        Value::Bool(b) =\u003e {\n            if *b {\n                1.0\n            } else {\n                0.0\n            }\n        }\n        _ =\u003e default_value,\n    }\n}\n\n/// Safely parses a string to a floating-point number.\npub fn safe_parse_float_str(value: \u0026str, default_value: f64) -\u003e f64 {\n    if value.trim().is_empty() {\n        return default_value;\n    }\n\n    value.parse::\u003cf64\u003e().unwrap_or(default_value)\n}\n\n/// Safely parses an optional string to a floating-point number.\npub fn safe_parse_float_opt(value: Option\u003c\u0026str\u003e, default_value: f64) -\u003e f64 {\n    match value {\n        Some(s) =\u003e safe_parse_float_str(s, default_value),\n        None =\u003e default_value,\n    }\n}\n\n/// Performs a deep clone of a JSON-serializable value.\n/// This is equivalent to JSON.parse(JSON.stringify()) in JavaScript.\npub fn deep_clone\u003cT\u003e(value: \u0026T) -\u003e Result\u003cT, serde_json::Error\u003e\nwhere\n    T: serde::Serialize + for\u003c'de\u003e serde::Deserialize\u003c'de\u003e,\n{\n    let json_str = serde_json::to_string(value)?;\n    serde_json::from_str(\u0026json_str)\n}\n\n/// Clamps a value between a minimum and maximum\npub fn clamp\u003cT: PartialOrd\u003e(value: T, min: T, max: T) -\u003e T {\n    if value \u003c min {\n        min\n    } else if value \u003e max {\n        max\n    } else {\n        value\n    }\n}\n\n/// Rounds a float to a specified number of decimal places\npub fn round_to_decimal_places(value: f64, decimal_places: u32) -\u003e f64 {\n    let multiplier = 10_f64.powi(decimal_places as i32);\n    (value * multiplier).round() / multiplier\n}\n\n/// Converts a percentage string (e.g., \"1.5%\") to a decimal\npub fn percentage_to_decimal(percentage_str: \u0026str) -\u003e Result\u003cf64, String\u003e {\n    let cleaned = percentage_str.trim().trim_end_matches('%');\n    cleaned\n        .parse::\u003cf64\u003e()\n        .map(|p| p / 100.0)\n        .map_err(|_| format!(\"Invalid percentage format: {}\", percentage_str))\n}\n\n/// Converts a decimal to a percentage string\npub fn decimal_to_percentage(decimal: f64, decimal_places: u32) -\u003e String {\n    format!(\n        \"{:.prec$}%\",\n        decimal * 100.0,\n        prec = decimal_places as usize\n    )\n}\n\n/// Checks if a float is approximately equal to another within a tolerance\npub fn approximately_equal(a: f64, b: f64, tolerance: f64) -\u003e bool {\n    (a - b).abs() \u003c tolerance\n}\n\n/// Calculates the absolute percentage difference between two values\n/// Returns None when one value is zero and the other is not (undefined percentage)\npub fn percentage_difference(value1: f64, value2: f64) -\u003e Option\u003cf64\u003e {\n    if value1 == 0.0 \u0026\u0026 value2 == 0.0 {\n        Some(0.0)\n    } else if value1 == 0.0 || value2 == 0.0 {\n        None // Undefined percentage difference when one value is zero\n    } else {\n        Some(((value1 - value2).abs() / ((value1 + value2) / 2.0)) * 100.0)\n    }\n}\n\n/// Validates that a value is within a specific range\npub fn validate_range\u003cT: PartialOrd + std::fmt::Display\u003e(\n    value: T,\n    min: T,\n    max: T,\n    field_name: \u0026str,\n) -\u003e Result\u003cT, String\u003e {\n    if value \u003c min || value \u003e max {\n        Err(format!(\n            \"{} must be between {} and {}, got {}\",\n            field_name, min, max, value\n        ))\n    } else {\n        Ok(value)\n    }\n}\n\n/// Calculates the moving average of a slice of values\npub fn moving_average(values: \u0026[f64], window_size: usize) -\u003e Vec\u003cf64\u003e {\n    if window_size == 0 || values.is_empty() {\n        return Vec::new();\n    }\n\n    let mut result = Vec::new();\n    for i in 0..values.len() {\n        let start = (i + 1).saturating_sub(window_size);\n        let end = i + 1;\n        let window = \u0026values[start..end];\n        let avg = window.iter().sum::\u003cf64\u003e() / window.len() as f64;\n        result.push(avg);\n    }\n    result\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn test_safe_parse_float() {\n        assert_eq!(safe_parse_float(\u0026json!(42.5), 0.0), 42.5);\n        assert_eq!(safe_parse_float(\u0026json!(\"123.45\"), 0.0), 123.45);\n        assert_eq!(safe_parse_float(\u0026json!(null), 10.0), 10.0);\n        assert_eq!(safe_parse_float(\u0026json!(\"\"), 5.0), 5.0);\n        assert_eq!(safe_parse_float(\u0026json!(\"invalid\"), 7.0), 7.0);\n        assert_eq!(safe_parse_float(\u0026json!(true), 0.0), 1.0);\n        assert_eq!(safe_parse_float(\u0026json!(false), 0.0), 0.0);\n    }\n\n    #[test]\n    fn test_safe_parse_float_str() {\n        assert_eq!(safe_parse_float_str(\"123.45\", 0.0), 123.45);\n        assert_eq!(safe_parse_float_str(\"\", 10.0), 10.0);\n        assert_eq!(safe_parse_float_str(\"  \", 5.0), 5.0);\n        assert_eq!(safe_parse_float_str(\"invalid\", 7.0), 7.0);\n    }\n\n    #[test]\n    fn test_clamp() {\n        assert_eq!(clamp(5, 1, 10), 5);\n        assert_eq!(clamp(0, 1, 10), 1);\n        assert_eq!(clamp(15, 1, 10), 10);\n    }\n\n    #[test]\n    fn test_round_to_decimal_places() {\n        let pi_2_decimal = round_to_decimal_places(std::f64::consts::PI, 2);\n        let pi_4_decimal = round_to_decimal_places(std::f64::consts::PI, 4);\n        \n        // Test that the function works correctly by checking the rounded values\n        // Compute expected values to avoid hardcoded PI approximations\n        let expected_2_decimal = (std::f64::consts::PI * 100.0).round() / 100.0;\n        let expected_4_decimal = (std::f64::consts::PI * 10000.0).round() / 10000.0;\n        \n        assert_eq!(pi_2_decimal, expected_2_decimal);\n        assert_eq!(pi_4_decimal, expected_4_decimal);\n        \n        // Also test with a simple known value\n        assert_eq!(round_to_decimal_places(2.56789, 2), 2.57);\n        assert_eq!(round_to_decimal_places(2.56789, 3), 2.568);\n    }\n\n    #[test]\n    fn test_percentage_to_decimal() {\n        assert_eq!(percentage_to_decimal(\"50%\").unwrap(), 0.5);\n        assert_eq!(percentage_to_decimal(\"1.5%\").unwrap(), 0.015);\n        assert_eq!(percentage_to_decimal(\"100\").unwrap(), 1.0);\n        assert!(percentage_to_decimal(\"invalid%\").is_err());\n    }\n\n    #[test]\n    fn test_decimal_to_percentage() {\n        assert_eq!(decimal_to_percentage(0.5, 1), \"50.0%\");\n        assert_eq!(decimal_to_percentage(0.015, 3), \"1.500%\");\n    }\n\n    #[test]\n    fn test_approximately_equal() {\n        assert!(approximately_equal(1.0, 1.001, 0.01));\n        assert!(!approximately_equal(1.0, 1.1, 0.01));\n    }\n\n    #[test]\n    fn test_percentage_difference() {\n        let expected = 200.0 * 10.0 / 190.0; // ~10.526315789473685\n        let actual = percentage_difference(100.0, 90.0).unwrap();\n        assert!(approximately_equal(actual, expected, 1e-10));\n        assert_eq!(percentage_difference(0.0, 0.0), Some(0.0));\n        assert_eq!(percentage_difference(100.0, 0.0), None);\n        assert_eq!(percentage_difference(0.0, 100.0), None);\n    }\n\n    #[test]\n    fn test_validate_range() {\n        assert_eq!(validate_range(5, 1, 10, \"test\").unwrap(), 5);\n        assert!(validate_range(0, 1, 10, \"test\").is_err());\n        assert!(validate_range(15, 1, 10, \"test\").is_err());\n    }\n\n    #[test]\n    fn test_moving_average() {\n        let values = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n        let result = moving_average(\u0026values, 3);\n        assert_eq!(result.len(), 5);\n        assert_eq!(result[0], 1.0); // [1] avg = 1\n        assert_eq!(result[1], 1.5); // [1,2] avg = 1.5\n        assert_eq!(result[2], 2.0); // [1,2,3] avg = 2\n        assert_eq!(result[3], 3.0); // [2,3,4] avg = 3\n        assert_eq!(result[4], 4.0); // [3,4,5] avg = 4\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":7}},{"line":6,"address":[],"length":0,"stats":{"Line":7}},{"line":7,"address":[],"length":0,"stats":{"Line":1}},{"line":8,"address":[],"length":0,"stats":{"Line":1}},{"line":9,"address":[],"length":0,"stats":{"Line":3}},{"line":10,"address":[],"length":0,"stats":{"Line":3}},{"line":11,"address":[],"length":0,"stats":{"Line":1}},{"line":13,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":2}},{"line":18,"address":[],"length":0,"stats":{"Line":1}},{"line":20,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":4}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":3}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":4}},{"line":67,"address":[],"length":0,"stats":{"Line":4}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":72,"address":[],"length":0,"stats":{"Line":4}},{"line":73,"address":[],"length":0,"stats":{"Line":4}},{"line":74,"address":[],"length":0,"stats":{"Line":4}},{"line":76,"address":[],"length":0,"stats":{"Line":11}},{"line":77,"address":[],"length":0,"stats":{"Line":9}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":82,"address":[],"length":0,"stats":{"Line":2}},{"line":84,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":90,"address":[],"length":0,"stats":{"Line":3}},{"line":91,"address":[],"length":0,"stats":{"Line":3}},{"line":96,"address":[],"length":0,"stats":{"Line":4}},{"line":97,"address":[],"length":0,"stats":{"Line":6}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":99,"address":[],"length":0,"stats":{"Line":5}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":3}},{"line":113,"address":[],"length":0,"stats":{"Line":5}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":1}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[],"length":0,"stats":{"Line":5}}],"covered":52,"coverable":61},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","utils","logger.rs"],"content":"// src/utils/logger.rs\n\nuse serde_json::{json, Value};\nuse std::collections::HashMap;\nuse std::sync::OnceLock;\nuse worker::console_log;\n\n/// Log levels supported by the logger\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]\npub enum LogLevel {\n    Error = 0,\n    Warn = 1,\n    Info = 2,\n    Debug = 3,\n}\n\nimpl LogLevel {\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            LogLevel::Error =\u003e \"ERROR\",\n            LogLevel::Warn =\u003e \"WARN\",\n            LogLevel::Info =\u003e \"INFO\",\n            LogLevel::Debug =\u003e \"DEBUG\",\n        }\n    }\n\n    pub fn from_str(s: \u0026str) -\u003e LogLevel {\n        match s.to_lowercase().as_str() {\n            \"error\" =\u003e LogLevel::Error,\n            \"warn\" | \"warning\" =\u003e LogLevel::Warn,\n            \"info\" =\u003e LogLevel::Info,\n            \"debug\" =\u003e LogLevel::Debug,\n            _ =\u003e LogLevel::Info, // default\n        }\n    }\n}\n\n/// Simple logger for Cloudflare Workers\npub struct Logger {\n    level: LogLevel,\n    context: HashMap\u003cString, Value\u003e,\n}\n\nimpl Logger {\n    pub fn new(level: LogLevel) -\u003e Self {\n        Self {\n            level,\n            context: HashMap::new(),\n        }\n    }\n\n    pub fn from_env() -\u003e Self {\n        // Try to get log level from environment, default to Info\n        let level_str = std::env::var(\"LOG_LEVEL\").unwrap_or_else(|_| \"info\".to_string());\n        Self::new(LogLevel::from_str(\u0026level_str))\n    }\n\n    pub fn set_level(\u0026mut self, level: LogLevel) {\n        self.level = level;\n    }\n\n    pub fn get_level(\u0026self) -\u003e \u0026LogLevel {\n        \u0026self.level\n    }\n\n    pub fn add_context(\u0026mut self, key: \u0026str, value: Value) {\n        self.context.insert(key.to_string(), value);\n    }\n\n    pub fn child(\u0026self, context: HashMap\u003cString, Value\u003e) -\u003e Self {\n        let mut new_context = self.context.clone();\n        new_context.extend(context);\n\n        Self {\n            level: self.level.clone(),\n            context: new_context,\n        }\n    }\n\n    fn should_log(\u0026self, level: \u0026LogLevel) -\u003e bool {\n        level \u003c= \u0026self.level\n    }\n\n    fn format_message(\u0026self, level: \u0026LogLevel, message: \u0026str, meta: Option\u003c\u0026Value\u003e) -\u003e String {\n        let timestamp = chrono::Utc::now().format(\"%Y-%m-%d %H:%M:%S%.3f UTC\");\n\n        let mut log_obj = serde_json::json!({\n            \"timestamp\": timestamp.to_string(),\n            \"level\": level.as_str(),\n            \"message\": message,\n        });\n\n        // Add context\n        if !self.context.is_empty() {\n            log_obj[\"context\"] = serde_json::Value::Object(\n                self.context\n                    .iter()\n                    .map(|(k, v)| (k.clone(), v.clone()))\n                    .collect(),\n            );\n        }\n\n        // Add metadata if provided\n        if let Some(meta) = meta {\n            log_obj[\"meta\"] = meta.clone();\n        }\n\n        serde_json::to_string(\u0026log_obj)\n            .unwrap_or_else(|_| format!(\"[{}] {}: {}\", timestamp, level.as_str(), message))\n    }\n\n    pub fn error(\u0026self, message: \u0026str) {\n        self.error_with_meta(message, None);\n    }\n\n    pub fn error_with_meta(\u0026self, message: \u0026str, meta: Option\u003c\u0026Value\u003e) {\n        if self.should_log(\u0026LogLevel::Error) {\n            let formatted = self.format_message(\u0026LogLevel::Error, message, meta);\n            console_log!(\"{}\", formatted);\n        }\n    }\n\n    pub fn warn(\u0026self, message: \u0026str) {\n        self.warn_with_meta(message, None);\n    }\n\n    pub fn warn_with_meta(\u0026self, message: \u0026str, meta: Option\u003c\u0026Value\u003e) {\n        if self.should_log(\u0026LogLevel::Warn) {\n            let formatted = self.format_message(\u0026LogLevel::Warn, message, meta);\n            console_log!(\"{}\", formatted);\n        }\n    }\n\n    pub fn info(\u0026self, message: \u0026str) {\n        self.info_with_meta(message, None);\n    }\n\n    pub fn info_with_meta(\u0026self, message: \u0026str, meta: Option\u003c\u0026Value\u003e) {\n        if self.should_log(\u0026LogLevel::Info) {\n            let formatted = self.format_message(\u0026LogLevel::Info, message, meta);\n            console_log!(\"{}\", formatted);\n        }\n    }\n\n    pub fn debug(\u0026self, message: \u0026str) {\n        self.debug_with_meta(message, None);\n    }\n\n    pub fn debug_with_meta(\u0026self, message: \u0026str, meta: Option\u003c\u0026Value\u003e) {\n        if self.should_log(\u0026LogLevel::Debug) {\n            let formatted = self.format_message(\u0026LogLevel::Debug, message, meta);\n            console_log!(\"{}\", formatted);\n        }\n    }\n\n    pub fn add_error(\u0026self, error: \u0026dyn std::error::Error, context: Option\u003c\u0026Value\u003e) {\n        let error_meta = serde_json::json!({\n            \"error\": error.to_string(),\n            \"error_type\": std::any::type_name_of_val(error),\n        });\n\n        let combined_meta = match context {\n            Some(ctx) =\u003e {\n                let mut combined = ctx.clone();\n                if let Value::Object(ref mut map) = combined {\n                    if let Value::Object(error_map) = error_meta {\n                        map.extend(error_map);\n                    }\n                }\n                combined\n            }\n            None =\u003e error_meta,\n        };\n\n        self.error_with_meta(\"An error occurred\", Some(\u0026combined_meta));\n    }\n}\n\n/// Global logger instance - thread-safe singleton\nstatic GLOBAL_LOGGER: OnceLock\u003cLogger\u003e = OnceLock::new();\n\n/// Initialize the global logger\npub fn init_logger(level: LogLevel) {\n    GLOBAL_LOGGER.set(Logger::new(level)).ok();\n}\n\n/// Get a reference to the global logger\npub fn logger() -\u003e \u0026'static Logger {\n    GLOBAL_LOGGER.get_or_init(|| Logger::from_env())\n}\n\n/// Convenience macros for logging\n#[macro_export]\nmacro_rules! log_error {\n    ($msg:expr) =\u003e {\n        $crate::utils::logger::logger().error($msg)\n    };\n    ($msg:expr, $meta:expr) =\u003e {\n        $crate::utils::logger::logger().error_with_meta($msg, Some(\u0026$meta))\n    };\n}\n\n#[macro_export]\nmacro_rules! log_warn {\n    ($msg:expr) =\u003e {\n        $crate::utils::logger::logger().warn($msg)\n    };\n    ($msg:expr, $meta:expr) =\u003e {\n        $crate::utils::logger::logger().warn_with_meta($msg, Some(\u0026$meta))\n    };\n}\n\n#[macro_export]\nmacro_rules! log_info {\n    ($msg:expr) =\u003e {\n        $crate::utils::logger::logger().info($msg)\n    };\n    ($msg:expr, $meta:expr) =\u003e {\n        $crate::utils::logger::logger().info_with_meta($msg, Some(\u0026$meta))\n    };\n}\n\n#[macro_export]\nmacro_rules! log_debug {\n    ($msg:expr) =\u003e {\n        $crate::utils::logger::logger().debug($msg)\n    };\n    ($msg:expr, $meta:expr) =\u003e {\n        $crate::utils::logger::logger().debug_with_meta($msg, Some(\u0026$meta))\n    };\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_log_level_ordering() {\n        assert!(LogLevel::Error \u003c LogLevel::Warn);\n        assert!(LogLevel::Warn \u003c LogLevel::Info);\n        assert!(LogLevel::Info \u003c LogLevel::Debug);\n    }\n\n    #[test]\n    fn test_log_level_from_str() {\n        assert_eq!(LogLevel::from_str(\"error\"), LogLevel::Error);\n        assert_eq!(LogLevel::from_str(\"WARN\"), LogLevel::Warn);\n        assert_eq!(LogLevel::from_str(\"info\"), LogLevel::Info);\n        assert_eq!(LogLevel::from_str(\"debug\"), LogLevel::Debug);\n        assert_eq!(LogLevel::from_str(\"invalid\"), LogLevel::Info);\n    }\n\n    #[test]\n    fn test_logger_should_log() {\n        let logger = Logger::new(LogLevel::Warn);\n        assert!(logger.should_log(\u0026LogLevel::Error));\n        assert!(logger.should_log(\u0026LogLevel::Warn));\n        assert!(!logger.should_log(\u0026LogLevel::Info));\n        assert!(!logger.should_log(\u0026LogLevel::Debug));\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":5}},{"line":28,"address":[],"length":0,"stats":{"Line":5}},{"line":29,"address":[],"length":0,"stats":{"Line":6}},{"line":30,"address":[],"length":0,"stats":{"Line":8}},{"line":31,"address":[],"length":0,"stats":{"Line":4}},{"line":32,"address":[],"length":0,"stats":{"Line":3}},{"line":33,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}}],"covered":11,"coverable":87},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","src","utils","mod.rs"],"content":"// src/utils/mod.rs\n\npub mod calculations;\npub mod error;\npub mod formatter;\npub mod helpers;\npub mod logger;\n\n// Re-export commonly used items\npub use error::{ArbitrageError, ArbitrageResult};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","irfandi","Coding","2025","ArbEdge","tests","integration_tests.rs"],"content":"use serde_json::json;\nuse std::collections::HashMap;\nuse chrono::Utc;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_basic_functionality() {\n        // Basic test to verify the module compiles and runs\n        assert_eq!(2 + 2, 4);\n    }\n\n    #[test]\n    fn test_json_serialization() {\n        // Test JSON handling that will be used in endpoints\n        let test_data = json!({\n            \"trading_pair\": \"BTCUSDT\",\n            \"exchange_a\": \"binance\",\n            \"exchange_b\": \"bybit\",\n            \"quantity\": 0.01,\n            \"funding_rate_diff\": 0.05\n        });\n\n        assert_eq!(test_data[\"trading_pair\"], \"BTCUSDT\");\n        assert_eq!(test_data[\"exchange_a\"], \"binance\");\n        assert_eq!(test_data[\"quantity\"], 0.01);\n    }\n\n    #[test]\n    fn test_query_parameter_parsing() {\n        // Test URL query parameter handling\n        let query_string = \"exchange=binance\u0026symbol=BTCUSDT\u0026limit=100\";\n        let query_pairs: HashMap\u003cString, String\u003e = query_string\n            .split('\u0026')\n            .filter_map(|pair| {\n                let mut split = pair.split('=');\n                let key = split.next()?;\n                let value = split.next()?;\n                Some((key.to_string(), value.to_string()))\n            })\n            .collect();\n\n        assert_eq!(query_pairs.get(\"exchange\"), Some(\u0026\"binance\".to_string()));\n        assert_eq!(query_pairs.get(\"symbol\"), Some(\u0026\"BTCUSDT\".to_string()));\n        assert_eq!(query_pairs.get(\"limit\"), Some(\u0026\"100\".to_string()));\n    }\n\n    #[test]\n    fn test_http_method_routing() {\n        // Test the logic for HTTP method and path matching\n        let routes = vec![\n            (\"GET\", \"/health\"),\n            (\"GET\", \"/exchange/markets\"),\n            (\"GET\", \"/exchange/ticker\"),\n            (\"GET\", \"/exchange/funding\"),\n            (\"POST\", \"/find-opportunities\"),\n            (\"POST\", \"/webhook\"),\n            (\"POST\", \"/positions\"),\n            (\"GET\", \"/positions\"),\n            (\"PUT\", \"/positions/123\"),\n            (\"DELETE\", \"/positions/123\"),\n        ];\n\n        for (method, path) in routes {\n            match (method, path) {\n                (\"GET\", \"/health\") =\u003e {\n                    // Health endpoint should be GET - this is correct\n                }\n                (\"POST\", \"/find-opportunities\") =\u003e {\n                    // Find opportunities should be POST - this is correct\n                }\n                (\"POST\", \"/webhook\") =\u003e {\n                    // Webhook should be POST - this is correct\n                }\n                (\"POST\", \"/positions\") =\u003e {\n                    // Create position should be POST - this is correct\n                }\n                (\"GET\", \"/positions\") =\u003e {\n                    // Get positions should be GET - this is correct\n                }\n                (_, path) if path.starts_with(\"/positions/\") =\u003e {\n                    assert!([\"GET\", \"PUT\", \"DELETE\"].contains(\u0026method), \n                           \"Position operations should be GET, PUT, or DELETE\");\n                }\n                (_, path) if path.starts_with(\"/exchange/\") =\u003e {\n                    assert_eq!(method, \"GET\", \"Exchange endpoints should be GET\");\n                }\n                _ =\u003e {}\n            }\n        }\n    }\n\n    #[test]\n    fn test_error_response_format() {\n        // Test error response formatting\n        let error_msg = \"Failed to process request\";\n        let status_code = 500;\n        \n        let error_response = json!({\n            \"error\": error_msg,\n            \"status\": status_code,\n            \"timestamp\": chrono::Utc::now().to_rfc3339()\n        });\n\n        assert_eq!(error_response[\"error\"], error_msg);\n        assert_eq!(error_response[\"status\"], status_code);\n        assert!(error_response[\"timestamp\"].is_string());\n    }\n\n    #[test]\n    fn test_opportunity_data_structure() {\n        // Test the structure of opportunity data\n        let opportunity = json!({\n            \"trading_pair\": \"BTCUSDT\",\n            \"exchange_a\": \"binance\",\n            \"exchange_b\": \"bybit\",\n            \"funding_rate_a\": 0.01,\n            \"funding_rate_b\": -0.01,\n            \"funding_rate_diff\": 0.02,\n            \"potential_profit\": 120.50,\n            \"timestamp\": chrono::Utc::now().to_rfc3339()\n        });\n\n        // Verify all required fields are present\n        assert!(opportunity[\"trading_pair\"].is_string());\n        assert!(opportunity[\"exchange_a\"].is_string());\n        assert!(opportunity[\"exchange_b\"].is_string());\n        assert!(opportunity[\"funding_rate_a\"].is_number());\n        assert!(opportunity[\"funding_rate_b\"].is_number());\n        assert!(opportunity[\"funding_rate_diff\"].is_number());\n        assert!(opportunity[\"potential_profit\"].is_number());\n        assert!(opportunity[\"timestamp\"].is_string());\n    }\n\n    #[test]\n    fn test_position_data_structure() {\n        // Test the structure of position data\n        let position = json!({\n            \"id\": \"pos_123456\",\n            \"trading_pair\": \"BTCUSDT\",\n            \"exchange_a\": \"binance\",\n            \"exchange_b\": \"bybit\",\n            \"quantity\": 0.01,\n            \"entry_funding_rate_diff\": 0.02,\n            \"current_funding_rate_diff\": 0.015,\n            \"status\": \"open\",\n            \"profit_loss\": 0.0,\n            \"created_at\": chrono::Utc::now().to_rfc3339(),\n            \"updated_at\": chrono::Utc::now().to_rfc3339()\n        });\n\n        // Verify all required fields are present\n        assert!(position[\"id\"].is_string());\n        assert!(position[\"trading_pair\"].is_string());\n        assert!(position[\"exchange_a\"].is_string());\n        assert!(position[\"exchange_b\"].is_string());\n        assert!(position[\"quantity\"].is_number());\n        assert!(position[\"status\"].is_string());\n        assert!(position[\"created_at\"].is_string());\n    }\n\n    #[test]\n    fn test_telegram_webhook_data() {\n        // Test Telegram webhook message structure\n        let webhook_data = json!({\n            \"update_id\": 123456789,\n            \"message\": {\n                \"message_id\": 1,\n                \"from\": {\n                    \"id\": 987654321,\n                    \"first_name\": \"Test\",\n                    \"username\": \"testuser\"\n                },\n                \"chat\": {\n                    \"id\": 987654321,\n                    \"type\": \"private\"\n                },\n                \"date\": 1640995200,\n                \"text\": \"/start\"\n            }\n        });\n\n        assert!(webhook_data[\"update_id\"].is_number());\n        assert!(webhook_data[\"message\"][\"text\"].is_string());\n        assert!(webhook_data[\"message\"][\"chat\"][\"id\"].is_number());\n    }\n\n    #[test]\n    fn test_exchange_configuration() {\n        // Test exchange configuration parsing\n        let exchanges_config = \"binance,bybit,okx,bitget\";\n        let exchanges: Vec\u003c\u0026str\u003e = exchanges_config.split(',').collect();\n        \n        assert!(exchanges.contains(\u0026\"binance\"));\n        assert!(exchanges.contains(\u0026\"bybit\"));\n        assert!(exchanges.contains(\u0026\"okx\"));\n        assert!(exchanges.contains(\u0026\"bitget\"));\n        assert_eq!(exchanges.len(), 4);\n    }\n\n    #[test]\n    fn test_funding_rate_calculations() {\n        // Test funding rate difference calculations\n        let rate_a = 0.01; // 1%\n        let rate_b = -0.01; // -1%\n        let diff = rate_a - rate_b;\n        let percentage_diff = diff * 100.0;\n        \n        assert_eq!(diff, 0.02);\n        assert_eq!(percentage_diff, 2.0);\n        \n        // Test minimum threshold\n        let min_threshold = 0.015; // 1.5%\n        assert!(diff \u003e min_threshold, \"Difference should exceed minimum threshold\");\n    }\n\n    #[test]\n    fn test_profit_calculations() {\n        // Test potential profit calculations\n        let funding_rate_diff = 0.02; // 2%\n        let position_size = 1000.0; // $1000\n        let holding_period_hours = 8.0; // 8 hours\n        let annualized_hours = 365.0 * 24.0; // Hours in a year\n        \n        let potential_profit = (funding_rate_diff * position_size * holding_period_hours) / annualized_hours;\n        \n        assert!(potential_profit \u003e 0.0);\n        assert!(potential_profit \u003c position_size); // Profit should be reasonable\n    }\n\n    #[test]\n    fn test_environment_variable_parsing() {\n        // Test environment variable parsing logic\n        let mock_env_vars = HashMap::from([\n            (\"EXCHANGES\".to_string(), \"binance,bybit\".to_string()),\n            (\"MIN_FUNDING_RATE_DIFF\".to_string(), \"0.01\".to_string()),\n            (\"TELEGRAM_BOT_TOKEN\".to_string(), \"123456:ABC-DEF\".to_string()),\n            (\"CHAT_ID\".to_string(), \"987654321\".to_string()),\n        ]);\n\n        // Test exchanges parsing\n        let exchanges = mock_env_vars.get(\"EXCHANGES\").unwrap();\n        let exchange_list: Vec\u003c\u0026str\u003e = exchanges.split(',').collect();\n        assert_eq!(exchange_list.len(), 2);\n\n        // Test numeric parsing\n        let min_diff: f64 = mock_env_vars.get(\"MIN_FUNDING_RATE_DIFF\")\n            .unwrap()\n            .parse()\n            .unwrap();\n        assert_eq!(min_diff, 0.01);\n\n        // Test chat ID parsing\n        let chat_id: i64 = mock_env_vars.get(\"CHAT_ID\")\n            .unwrap()\n            .parse()\n            .unwrap();\n        assert_eq!(chat_id, 987654321);\n    }\n\n    #[test]\n    fn test_scheduled_event_timing() {\n        // Test cron expression validation for scheduled events\n        let cron_expressions = vec![\n            \"* * * * *\",     // Every minute\n            \"*/5 * * * *\",   // Every 5 minutes\n            \"0 * * * *\",     // Every hour\n            \"0 0 * * *\",     // Every day\n        ];\n\n        for cron in cron_expressions {\n            assert!(!cron.is_empty(), \"Cron expression should not be empty\");\n            assert!(cron.contains('*'), \"Cron expression should contain asterisks\");\n            let parts: Vec\u003c\u0026str\u003e = cron.split_whitespace().collect();\n            assert_eq!(parts.len(), 5, \"Cron expression should have 5 parts\");\n        }\n    }\n\n    #[test]\n    fn test_api_response_structure() {\n        // Test standardized API response structure\n        let success_response = json!({\n            \"success\": true,\n            \"data\": {\n                \"message\": \"Operation completed successfully\"\n            },\n            \"timestamp\": chrono::Utc::now().to_rfc3339()\n        });\n\n        let error_response = json!({\n            \"success\": false,\n            \"error\": {\n                \"message\": \"Operation failed\",\n                \"code\": \"INTERNAL_ERROR\"\n            },\n            \"timestamp\": chrono::Utc::now().to_rfc3339()\n        });\n\n        assert_eq!(success_response[\"success\"], true);\n        assert_eq!(error_response[\"success\"], false);\n        assert!(success_response[\"timestamp\"].is_string());\n        assert!(error_response[\"timestamp\"].is_string());\n    }\n} ","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>